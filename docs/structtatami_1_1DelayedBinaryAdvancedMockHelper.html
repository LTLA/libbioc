<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tatami: tatami::DelayedBinaryAdvancedMockHelper Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tatami
   </div>
   <div id="projectbrief">C++ API for different matrix representations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetatami.html">tatami</a></li><li class="navelem"><a class="el" href="structtatami_1_1DelayedBinaryAdvancedMockHelper.html">DelayedBinaryAdvancedMockHelper</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="structtatami_1_1DelayedBinaryAdvancedMockHelper-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">tatami::DelayedBinaryAdvancedMockHelper Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Advanced mock operation for <code><a class="el" href="classtatami_1_1DelayedBinaryIsometricOp.html" title="Delayed isometric operations on two matrices.">DelayedBinaryIsometricOp</a></code>.  
 <a href="structtatami_1_1DelayedBinaryAdvancedMockHelper.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="binary_2mock__helpers_8hpp_source.html">mock_helpers.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6a12e19e5693e899c84f0e8d890894fc" id="r_a6a12e19e5693e899c84f0e8d890894fc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; </td></tr>
<tr class="memitem:a6a12e19e5693e899c84f0e8d890894fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedBinaryAdvancedMockHelper.html#a6a12e19e5693e899c84f0e8d890894fc">fill</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">i</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a6a12e19e5693e899c84f0e8d890894fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac864ee425da7d1f3025e79dbbb9bac8b" id="r_ac864ee425da7d1f3025e79dbbb9bac8b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; </td></tr>
<tr class="memitem:ac864ee425da7d1f3025e79dbbb9bac8b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedBinaryAdvancedMockHelper.html#ac864ee425da7d1f3025e79dbbb9bac8b">dense</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">row</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">i</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">start</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> length, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> *<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">left_buffer</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> *<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">right_buffer</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:ac864ee425da7d1f3025e79dbbb9bac8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3fb5ab83763694a88ff18ca0540a73b" id="r_ae3fb5ab83763694a88ff18ca0540a73b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; </td></tr>
<tr class="memitem:ae3fb5ab83763694a88ff18ca0540a73b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedBinaryAdvancedMockHelper.html#ae3fb5ab83763694a88ff18ca0540a73b">dense</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">row</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">i</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> std::vector&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &amp;indices, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> *<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">left_buffer</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> *<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">right_buffer</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:ae3fb5ab83763694a88ff18ca0540a73b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab37b1eda201f1fb006ad84f41a7ec83f" id="r_ab37b1eda201f1fb006ad84f41a7ec83f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; </td></tr>
<tr class="memitem:ab37b1eda201f1fb006ad84f41a7ec83f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedBinaryAdvancedMockHelper.html#ab37b1eda201f1fb006ad84f41a7ec83f">sparse</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">row</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">i</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &amp;left, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &amp;right, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> *<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">output_value</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> *<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">output_index</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">report_value</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">report_index</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:ab37b1eda201f1fb006ad84f41a7ec83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1811439f3c999f2cf98dee6633524d0a" id="r_a1811439f3c999f2cf98dee6633524d0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedBinaryAdvancedMockHelper.html#a1811439f3c999f2cf98dee6633524d0a">is_sparse</a> () <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a1811439f3c999f2cf98dee6633524d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a8e38562b6403a45e7f891f0c8bb80c1c" id="r_a8e38562b6403a45e7f891f0c8bb80c1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">static</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">constexpr</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedBinaryAdvancedMockHelper.html#a8e38562b6403a45e7f891f0c8bb80c1c">zero_depends_on_row</a> = <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">false</a></td></tr>
<tr class="separator:a8e38562b6403a45e7f891f0c8bb80c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db6d35193bb89cbf4c21a706536601f" id="r_a1db6d35193bb89cbf4c21a706536601f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">static</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">constexpr</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedBinaryAdvancedMockHelper.html#a1db6d35193bb89cbf4c21a706536601f">zero_depends_on_column</a> = <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">false</a></td></tr>
<tr class="separator:a1db6d35193bb89cbf4c21a706536601f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Advanced mock operation for <code><a class="el" href="classtatami_1_1DelayedBinaryIsometricOp.html" title="Delayed isometric operations on two matrices.">DelayedBinaryIsometricOp</a></code>. </p>
<p>This class defines the advanced expectations for an operation in <code><a class="el" href="classtatami_1_1DelayedBinaryIsometricOp.html" title="Delayed isometric operations on two matrices.">DelayedBinaryIsometricOp</a></code>, which improves efficiency by taking advantage of any sparsity in the underlying matrices. Either the operation itself preserves sparsity, or any loss of sparsity is predictable, i.e., zeros are transformed into a constant non-zero value that does not depend on its position in the <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code>.</p>
<p>Actual operations aren't expected to inherit from this class; this is only provided for documentation purposes. Operations only need to implement methods with the same signatures for compile-time polymorphism. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a6a12e19e5693e899c84f0e8d890894fc" name="a6a12e19e5693e899c84f0e8d890894fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a12e19e5693e899c84f0e8d890894fc">&#9670;&#160;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> tatami::DelayedBinaryAdvancedMockHelper::fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of index value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the row containing the zero, if <code>zero_depends_on_row = true</code>; the index of the column containing the zero, if <code>zero_depends_on_column = true</code>; or ignored, if neither are true.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation being applied on zeros from both the left and right matrices. This should be constant for all elements in the row/column/matrix, depending on the interpretation of <code>i</code>.</dd></dl>
<p>This method will be called with an explicit <code>Value_</code> template parameter. Implementations of this method should either ensure that <code>Index_</code> is deducible or use a fixed integer type in the method signature. </p>

</div>
</div>
<a id="ac864ee425da7d1f3025e79dbbb9bac8b" name="ac864ee425da7d1f3025e79dbbb9bac8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac864ee425da7d1f3025e79dbbb9bac8b">&#9670;&#160;</a></span>dense() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">void</a> tatami::DelayedBinaryAdvancedMockHelper::dense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> *&#160;</td>
          <td class="paramname"><em>left_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> *&#160;</td>
          <td class="paramname"><em>right_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method should apply the operation to corresponding values of <code>left_buffer</code> and <code>right_buffer</code>. These buffers represent the same element of the target dimension from the left and right matrices, respectively, in dense form. Each buffer holds values from a contiguous block of the non-target dimension.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of index value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">row</td><td>Whether the rows are the target dimension. If true, <code>left_buffer</code> and <code>right_buffer</code> hold the contents of the <code>i</code>-th row from both matrices; otherwise, they hold the contents of the <code>i</code>-th column. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">i</td><td>Index of the extracted row (if <code>row = true</code>) or column (otherwise). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">start</td><td>Start of the contiguous block of columns (if <code>row = true</code>) or rows (otherwise) extracted from <code>i</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">length</td><td>Length of the contiguous block. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">left_buffer</td><td>Contents of the row/column extracted from the left matrix. This has <code>length</code> addressable elements, and the result of the operation should be stored here. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right_buffer</td><td>Contents of the row/column extracted from the right matrix. This has <code>length</code> addressable elements.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that implementations of this method do not necessarily need to have the same template arguments as shown here. It will be called without any explicit template arguments so anything can be used as long as type deduction works. </p>

</div>
</div>
<a id="ae3fb5ab83763694a88ff18ca0540a73b" name="ae3fb5ab83763694a88ff18ca0540a73b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3fb5ab83763694a88ff18ca0540a73b">&#9670;&#160;</a></span>dense() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">void</a> tatami::DelayedBinaryAdvancedMockHelper::dense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> std::vector&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> *&#160;</td>
          <td class="paramname"><em>left_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> *&#160;</td>
          <td class="paramname"><em>right_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method should apply the operation to corresponding values of <code>left_buffer</code> and <code>right_buffer</code>, These buffers represent the same element of the target dimension from the left and right matrices, respectively, in dense form. Each buffer holds values from an indexed subset of the non-target dimension.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of index value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">row</td><td>Whether the rows are the target dimension. If true, <code>left_buffer</code> and <code>right_buffer</code> hold the contents of the <code>i</code>-th row from both matrices; otherwise, they hold the contents of the <code>i</code>-th column. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">i</td><td>Index of the extracted row (if <code>row = true</code>) or column (otherwise). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">indices</td><td>Sorted and unique indices of columns (if <code>row = true</code>) or rows (otherwise) extracted from <code>i</code>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">left_buffer</td><td>Contents of the row/column extracted from the left matrix. This has <code>length</code> addressable elements, and the result of the operation should be stored here. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right_buffer</td><td>Contents of the row/column extracted from the right matrix. This has <code>length</code> addressable elements.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that implementations of this method do not necessarily need to have the same template arguments as shown here. It will be called without any explicit template arguments so anything can be used as long as type deduction works. </p>

</div>
</div>
<a id="ab37b1eda201f1fb006ad84f41a7ec83f" name="ab37b1eda201f1fb006ad84f41a7ec83f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab37b1eda201f1fb006ad84f41a7ec83f">&#9670;&#160;</a></span>sparse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> tatami::DelayedBinaryAdvancedMockHelper::sparse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> *&#160;</td>
          <td class="paramname"><em>output_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> *&#160;</td>
          <td class="paramname"><em>output_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td>
          <td class="paramname"><em>report_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td>
          <td class="paramname"><em>report_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method applies the operation to the sparse ranges in <code>left</code> and <code>right</code>, containing values from the same element of the target dimension from the left and right matrices, respectively. Specifically, the operation only needs to be applied to the structural non-zeros, and results of the operation should be stored in the <code>output_*</code> buffers. Structural zeros are either ignored for sparsity-preserving operations, or the result of the operation on zeros will be populated by <code><a class="el" href="structtatami_1_1DelayedBinaryAdvancedMockHelper.html#a6a12e19e5693e899c84f0e8d890894fc">fill()</a></code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of index value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">row</td><td>Whether the rows are the target dimension. If true, <code>left_buffer</code> and <code>right_buffer</code> hold the contents of the <code>i</code>-th row from both matrices; otherwise, they hold the contents of the <code>i</code>-th column. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">i</td><td>Index of the extracted row (if <code>row = true</code>) or column (otherwise). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">left</td><td>Contents of row/column <code>i</code> extracted from the left matrix. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">right</td><td>Contents of row/column <code>i</code> extracted from the right matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_value</td><td>Pointer to an array for storing output values of the operation. This is guaranteed to have enough space for the union of indices in <code>left</code> and <code>right</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_index</td><td>Pointer to an array for storing output indices. This is guaranteed to have enough space for the union of indices in <code>left</code> and <code>right</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">report_value</td><td>Whether to return the values in <code>output_value</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">report_index</td><td>Whether to return the indices in <code>output_index</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of structural non-zero elements in the <code>output_*</code> buffers.</dd></dl>
<p>If <code>report_value = true</code>, <code>left.value</code> and <code>right.value</code> and <code>output_value</code> are all guaranteed to be non-NULL. Otherwise, any of these pointers may be NULL and should be ignored.</p>
<p>If <code>report_index = true</code>, <code>output_index</code> is guaranteed to be non-NULL; otherwise, <code>output_index</code> should be ignored. <code>left.index</code> and <code>right.index</code> will always return be non-NULL regardless of <code>report_index</code>. Indices in <code>left.index</code> and <code>right.index</code> are also guaranteed to be in ascending order.</p>
<p>It is expected that the results of the operation are sorted in ascending order, i.e., indices in <code>output_index</code> should be increasing.</p>
<p>The settings of <code>report_index</code> and <code>report_value</code> should not change the number or ordering of the results. That is, <code>output_index</code> should have the same indices regardless of <code>report_value</code>, and <code>output_value</code> should have the same values regardless of <code>report_index</code>. This implies that implementations should not omit structural non-zeros even if the actual value is zero, as the computation of the actual value requires <code>report_value = true</code>.</p>
<p>Note that implementations of this method do not necessarily need to have the same template arguments as shown here. It will be called without any explicit template arguments so anything can be used as long as type deduction works. </p>

</div>
</div>
<a id="a1811439f3c999f2cf98dee6633524d0a" name="a1811439f3c999f2cf98dee6633524d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1811439f3c999f2cf98dee6633524d0a">&#9670;&#160;</a></span>is_sparse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> tatami::DelayedBinaryAdvancedMockHelper::is_sparse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Does this operation preserve sparsity? This may return false. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a8e38562b6403a45e7f891f0c8bb80c1c" name="a8e38562b6403a45e7f891f0c8bb80c1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e38562b6403a45e7f891f0c8bb80c1c">&#9670;&#160;</a></span>zero_depends_on_row</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">constexpr</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> tatami::DelayedBinaryAdvancedMockHelper::zero_depends_on_row = <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">false</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Conversion of zeros to non-zero values is not dependent on rows. Implementations of the advanced operation interface may set this to <code>true</code> provided that <code>zero_depends_on_column = false</code>; at least one of these must be false, otherwise a basic operation interface is expected (see <code><a class="el" href="structtatami_1_1DelayedBinaryBasicMockHelper.html" title="Basic mock operation for DelayedBinaryIsometricOp.">DelayedBinaryBasicMockHelper</a></code>). </p>

</div>
</div>
<a id="a1db6d35193bb89cbf4c21a706536601f" name="a1db6d35193bb89cbf4c21a706536601f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1db6d35193bb89cbf4c21a706536601f">&#9670;&#160;</a></span>zero_depends_on_column</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">constexpr</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> tatami::DelayedBinaryAdvancedMockHelper::zero_depends_on_column = <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">false</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Conversion of zeros to non-zero values is not dependent on columns. Implementations of the advanced operation interface may set this to <code>true</code> provided that <code>zero_depends_on_row = false</code>; at least one of these must be false, otherwise a basic operation interface is expected (see <code><a class="el" href="structtatami_1_1DelayedBinaryBasicMockHelper.html" title="Basic mock operation for DelayedBinaryIsometricOp.">DelayedBinaryBasicMockHelper</a></code>). </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>tatami/isometric/binary/<a class="el" href="binary_2mock__helpers_8hpp_source.html">mock_helpers.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
