<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tatami: tatami/stats/apply.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tatami
   </div>
   <div id="projectbrief">C++ API for different matrix representations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_7c74ace1909d0ad6f313cc91d6fa66af.html">tatami</a></li><li class="navelem"><a class="el" href="dir_519d06fd38201b4c866e88fbbe3bc8bc.html">stats</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">apply.hpp File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Apply arbitrary calculations along rows or columns.  
<a href="#details">More...</a></p>

<p><a href="apply_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a794620bd9c24e6c2bc39f4c65d7f1a16"><td class="memTemplParams" colspan="2">template&lt;int MARGIN, typename T , typename IDX , class Factory &gt; </td></tr>
<tr class="memitem:a794620bd9c24e6c2bc39f4c65d7f1a16"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="apply_8hpp.html#a794620bd9c24e6c2bc39f4c65d7f1a16">tatami::apply</a> (const Matrix&lt; T, IDX &gt; *p, Factory &amp;factory)</td></tr>
<tr class="separator:a794620bd9c24e6c2bc39f4c65d7f1a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Apply arbitrary calculations along rows or columns. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a794620bd9c24e6c2bc39f4c65d7f1a16" name="a794620bd9c24e6c2bc39f4c65d7f1a16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a794620bd9c24e6c2bc39f4c65d7f1a16">&#9670;&nbsp;</a></span>apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int MARGIN, typename T , typename IDX , class Factory &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tatami::apply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Factory &amp;&#160;</td>
          <td class="paramname"><em>factory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MARGIN</td><td>The dimension over which to apply the calculation of statistics, i.e., rows (0) or columns (1). </td></tr>
    <tr><td class="paramname">T</td><td>Type of the matrix value, should be summable. </td></tr>
    <tr><td class="paramname">IDX</td><td>Type of the row/column indices. </td></tr>
    <tr><td class="paramname">Factory</td><td>Factory class to create the statistic-calculating classes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">factory</td><td>Instance of a factory.</td></tr>
  </table>
  </dd>
</dl>
<p>In this function, we consider the matrix to be a collection of "target vectors". When <code>MARGIN = 0</code>, each row is a target vector, whereas when <code>MARGIN = 1</code>, each column is a target vector. The goal is to compute some statistic along each of these target vectors, e.g., the per-row sums (<code><a class="el" href="sums_8hpp.html#a2911cbe4f7140539f015cc59edf22904">row_sums()</a></code>) or the per-column variances (<code><a class="el" href="variances_8hpp.html#a5ec25554e8927b70cf39398cf77e744f">row_variances()</a></code>). For brevity, we will refer to the vectors along the other dimension as "running vectors".</p>
<p >Arbitrary computations are supported via the supplied instance of the factory class. The factory class should have a <code>dense_direct()</code> method that accepts no arguments and returns an arbitrary <code>struct</code>. The returned <code>struct</code> should have a <code>compute()</code> method that accepts the index of the target vector, a pointer to the target vector, and a buffer of length equal to the target vector. Optionally, the factory class may have one or more of:</p>
<ul>
<li>A <code>sparse_direct()</code> method that accepts no arguments and returns an arbitrary <code>struct</code>. The returned <code>struct</code> should have a <code>compute()</code> method that accepts the index of the target vector, a <code>SparseRange</code> object containing the non-zero elements of the target vector, and two buffers of length equal to the target vector (one for the non-zero values, another for their positional indices).</li>
<li>A <code>dense_running()</code> method that accepts no arguments and returns an arbitrary <code>struct</code>. The returned <code>struct</code> should have an <code>add()</code> method that accepts a pointer to a running vector, plus a buffer of the same length. It should also have a <code>finish()</code> method, to be called to finalize any calculations after all running vectors are supplied.</li>
<li>A <code>sparse_running()</code> method that accepts no arguments and returns an arbitrary <code>struct</code>. The returned <code>struct</code> should have an <code>add()</code> method that accepts a <code>SparseRange</code> object, specifying the non-zero elements at a running vector; and two buffers of length equal to the total number of target vectors (one for the non-zero values, another for their positional indices). It should also have a <code>finish()</code> method, to be called to finalize any calculations after all running vectors are supplied.</li>
</ul>
<p >The idea is that <code><a class="el" href="apply_8hpp.html#a794620bd9c24e6c2bc39f4c65d7f1a16">apply()</a></code> will automatically choose the most appropriate calculation based on whether the matrix is sparse, whether it prefers row/column access, whether we want row/column statistics, and whether the calculation supports sparse and/or running calculations (based on the availability of the methods above). Each of these <code>compute()</code> and <code>add()</code> methods should modify the contents of <code>factory</code> by reference, which is usually achieved by passing pointers from <code>factory</code> to each returned <code>struct</code> and writing to those pointers in <code>compute()</code> and <code>add()</code>. Computed statistics can then be extracted from <code>factory</code> once <code><a class="el" href="apply_8hpp.html#a794620bd9c24e6c2bc39f4c65d7f1a16">apply()</a></code> has finished running. We expect that the results are agnostic to the choice of calculation, notwithstanding minor differences due to numerical precision.</p>
<p ><code><a class="el" href="apply_8hpp.html#a794620bd9c24e6c2bc39f4c65d7f1a16">apply()</a></code> also supports parallelization via OpenMP. Thread safety is <em>not</em> required in each call to <code>compute()</code> and <code>add()</code> within the same instance of a returned <code>struct</code>. However, there should be thread safety across instances, which is most relevant when results are being written back to the shared memory in <code>factory</code>. This is usually easy to achieve as long as the memory spaces for the results of two target vectors do not overlap. If parallelization is desired, we require some overloads to the <code>dense_running()</code> and <code>sparse_running()</code> methods:</p>
<ul>
<li><code>dense_running()</code> now accepts two arguments: namely, the indices of the first and one-past-the-last target vectors to be processed. This should return a <code>struct</code> with an <code>add()</code> method that accepts a pointer to the subinterval of the running vector, corresponding to the target vectors to be processed; plus a buffer of the same length as that subinterval. It should also have a <code>finish()</code> method, to be called to finalize any calculations after all running vectors are supplied.</li>
<li><code>sparse_running()</code> now accepts two arguments: namely, the indices of the first and one-past-the-last target vectors to be processed. The returned <code>struct</code> should have an <code>add()</code> method that accepts a <code>SparseRange</code> object, specifying the non-zero elements in the subinterval of the running vector; plus two buffers of the same length as that subinterval (one for the non-zero values, another for their positional indices). It should also have a <code>finish()</code> method, to be called to finalize any calculations after all running vectors are supplied.</li>
</ul>
<p >These overloads are optional and the function will fall back to serial processing if they are not supplied (and the function decides perform a running calculation).</p>
<p >See the <code>VarianceFactory</code> in <code><a class="el" href="variances_8hpp.html">variances.hpp</a></code> for an example of a valid factory class.</p>
<dl class="section return"><dt>Returns</dt><dd><code>factory</code> is modified by reference. This is done by passing in row- or column-wise (sparse) vectors extracted from <code>mat</code>, if <code>ROW</code> is 0 or 1 respectively. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
