<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tatami: tatami::DelayedUnaryAdvancedMockHelper Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tatami
   </div>
   <div id="projectbrief">C++ API for different matrix representations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetatami.html">tatami</a></li><li class="navelem"><a class="el" href="structtatami_1_1DelayedUnaryAdvancedMockHelper.html">DelayedUnaryAdvancedMockHelper</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="structtatami_1_1DelayedUnaryAdvancedMockHelper-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">tatami::DelayedUnaryAdvancedMockHelper Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Advanced mock operation for <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOp.html" title="Delayed isometric operations on a single matrix.">DelayedUnaryIsometricOp</a></code>.  
 <a href="structtatami_1_1DelayedUnaryAdvancedMockHelper.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="unary_2mock__helpers_8hpp_source.html">mock_helpers.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad412007ef9d18673fece69f47a1b605b" id="r_ad412007ef9d18673fece69f47a1b605b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; </td></tr>
<tr class="memitem:ad412007ef9d18673fece69f47a1b605b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedUnaryAdvancedMockHelper.html#ad412007ef9d18673fece69f47a1b605b">dense</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">row</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">i</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">start</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> length, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> *<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">buffer</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:ad412007ef9d18673fece69f47a1b605b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f51a30c3a30845bc7c40d590a07c26" id="r_a91f51a30c3a30845bc7c40d590a07c26"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; </td></tr>
<tr class="memitem:a91f51a30c3a30845bc7c40d590a07c26"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedUnaryAdvancedMockHelper.html#a91f51a30c3a30845bc7c40d590a07c26">dense</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">row</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">i</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> std::vector&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &amp;indices, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> *<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">buffer</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a91f51a30c3a30845bc7c40d590a07c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff269446c0a7beb65eb43b715a984e0" id="r_a2ff269446c0a7beb65eb43b715a984e0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; </td></tr>
<tr class="memitem:a2ff269446c0a7beb65eb43b715a984e0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedUnaryAdvancedMockHelper.html#a2ff269446c0a7beb65eb43b715a984e0">sparse</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">row</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">i</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> num, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> *value, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> *index) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a2ff269446c0a7beb65eb43b715a984e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055072152c604036d39142453fa1acc8" id="r_a055072152c604036d39142453fa1acc8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; </td></tr>
<tr class="memitem:a055072152c604036d39142453fa1acc8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedUnaryAdvancedMockHelper.html#a055072152c604036d39142453fa1acc8">fill</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">i</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a055072152c604036d39142453fa1acc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2907274f16032deefe2bd9b3b1b08900" id="r_a2907274f16032deefe2bd9b3b1b08900"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedUnaryAdvancedMockHelper.html#a2907274f16032deefe2bd9b3b1b08900">is_sparse</a> () <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a2907274f16032deefe2bd9b3b1b08900"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ae191e5641bb7bf9de1f871c436f13480" id="r_ae191e5641bb7bf9de1f871c436f13480"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">static</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">constexpr</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedUnaryAdvancedMockHelper.html#ae191e5641bb7bf9de1f871c436f13480">zero_depends_on_row</a> = <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">false</a></td></tr>
<tr class="separator:ae191e5641bb7bf9de1f871c436f13480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e45d0e04cc055b59940dd3499546e7" id="r_a54e45d0e04cc055b59940dd3499546e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">static</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">constexpr</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedUnaryAdvancedMockHelper.html#a54e45d0e04cc055b59940dd3499546e7">zero_depends_on_column</a> = <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">false</a></td></tr>
<tr class="separator:a54e45d0e04cc055b59940dd3499546e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a3438a78b1979cd6877c0ec239a780" id="r_a66a3438a78b1979cd6877c0ec239a780"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">static</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">constexpr</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedUnaryAdvancedMockHelper.html#a66a3438a78b1979cd6877c0ec239a780">non_zero_depends_on_row</a> = <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">false</a></td></tr>
<tr class="separator:a66a3438a78b1979cd6877c0ec239a780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee361e39d7d9b5b712bbfcee3484a273" id="r_aee361e39d7d9b5b712bbfcee3484a273"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">static</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">constexpr</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedUnaryAdvancedMockHelper.html#aee361e39d7d9b5b712bbfcee3484a273">non_zero_depends_on_column</a> = <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">false</a></td></tr>
<tr class="separator:aee361e39d7d9b5b712bbfcee3484a273"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Advanced mock operation for <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOp.html" title="Delayed isometric operations on a single matrix.">DelayedUnaryIsometricOp</a></code>. </p>
<p>This class defines the advanced expectations for an operation in <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOp.html" title="Delayed isometric operations on a single matrix.">DelayedUnaryIsometricOp</a></code>, which improves efficiency by taking advantage of any sparsity in the underlying matrix. Either the operation itself preserves sparsity, or any loss of sparsity is predictable, i.e., zeros are transformed into a constant non-zero value that does not depend on its position in the <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code>.</p>
<p>Actual operations aren't expected to inherit from this class; this is only provided for documentation purposes. Operations only need to implement methods with the same signatures for compile-time polymorphism. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ad412007ef9d18673fece69f47a1b605b" name="ad412007ef9d18673fece69f47a1b605b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad412007ef9d18673fece69f47a1b605b">&#9670;&#160;</a></span>dense() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">void</a> tatami::DelayedUnaryAdvancedMockHelper::dense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method should apply the operation to values in <code>buffer</code>, representing a contiguous block of values from a row/column.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of index value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">row</td><td>Whether <code>buffer</code> contains the row contents. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">i</td><td>Index of the extracted row (if <code>row = true</code>) or column (otherwise). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">start</td><td>Start of the contiguous block of columns (if <code>row = true</code>) or rows (otherwise) extracted from <code>i</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">length</td><td>Length of the contiguous block. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>Contents of the row/column extracted from the matrix. This has <code>length</code> addressable elements, and the result of the operation should be stored here.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that implementions of this method do not necessarily need to have the same template arguments as shown here. It will be called without any explicit template arguments so anything can be used as long as type deduction works. </p>

</div>
</div>
<a id="a91f51a30c3a30845bc7c40d590a07c26" name="a91f51a30c3a30845bc7c40d590a07c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91f51a30c3a30845bc7c40d590a07c26">&#9670;&#160;</a></span>dense() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">void</a> tatami::DelayedUnaryAdvancedMockHelper::dense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> std::vector&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method should apply the operation to values in <code>buffer</code>, representing an indexed subset of values from a row/column.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of index value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">row</td><td>Whether <code>buffer</code> contains the row contents. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">i</td><td>Index of the extracted row (if <code>row = true</code>) or column (otherwise). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">indices</td><td>Sorted and unique indices of columns (if <code>row = true</code>) or rows (otherwise) extracted from <code>i</code>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>Contents of the row/column extracted from the matrix. This has <code>length</code> addressable elements, and the result of the operation should be stored here.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that implementions of this method do not necessarily need to have the same template arguments as shown here. It will be called without any explicit template arguments so anything can be used as long as type deduction works. </p>

</div>
</div>
<a id="a2ff269446c0a7beb65eb43b715a984e0" name="a2ff269446c0a7beb65eb43b715a984e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ff269446c0a7beb65eb43b715a984e0">&#9670;&#160;</a></span>sparse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">void</a> tatami::DelayedUnaryAdvancedMockHelper::sparse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method applies the operation to a sparse range representing the contents of a row/column from the underyling matrix. Specifically, the operation only needs to be applied to the structural non-zeros; structural zeros are either ignored for sparsity-preserving operations, or the result of the operation on zeros will be populated by <code><a class="el" href="structtatami_1_1DelayedUnaryAdvancedMockHelper.html#a055072152c604036d39142453fa1acc8">fill()</a></code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of index value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">row</td><td>Whether <code>buffer</code> contains the row contents. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">i</td><td>Index of the extracted row (if <code>row = true</code>) or column (otherwise). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">num</td><td>Number of non-zero elements for row/column <code>i</code>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">value</td><td>Pointer to an array of values of the non-zero elements. This is guaranteed to have <code>num</code> addressable elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Pointer to an array of column (if <code>row = true</code>) or row indices (otherwise) of the non-zero elements. Alternatively NULL.</td></tr>
  </table>
  </dd>
</dl>
<p>This method is expected to iterate over <code>value</code> and modify it in place, i.e., replace each value with the result of the operation on that value.</p>
<p>If <code>non_zero_depends_on_row &amp;&amp; !row</code> or <code>non_zero_depends_on_column &amp;&amp; row</code>, <code>index</code> is guaranteed to be non-NULL. Otherwise, it may be NULL and should be ignored. Even if non-NULL, indices are not guaranteed to be sorted.</p>
<p>Note that implementations of this method do not necessarily need to have the same template arguments as shown here. It will be called without any explicit template arguments so anything can be used as long as type deduction works. </p>

</div>
</div>
<a id="a055072152c604036d39142453fa1acc8" name="a055072152c604036d39142453fa1acc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a055072152c604036d39142453fa1acc8">&#9670;&#160;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> tatami::DelayedUnaryAdvancedMockHelper::fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of index value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the row containing the zero, if <code>zero_depends_on_row = true</code>; the index of the column containing the zero, if <code>zero_depends_on_column = true</code>; or ignored, if both <code>zero_depends_on_row</code> and <code>zero_depends_on_column</code> are both false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation being applied on zeros from both the left and right matrices. This should be constant for all elements in the row/column/matrix, depending on the interpretation of <code>i</code>.</dd></dl>
<p>This method will be called with an explicit <code>Value_</code> template parameter. Implementations of this method should either ensure that <code>Index_</code> is deducible or use a fixed integer type in the method signature. </p>

</div>
</div>
<a id="a2907274f16032deefe2bd9b3b1b08900" name="a2907274f16032deefe2bd9b3b1b08900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2907274f16032deefe2bd9b3b1b08900">&#9670;&#160;</a></span>is_sparse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> tatami::DelayedUnaryAdvancedMockHelper::is_sparse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Does this operation preserve sparsity? This may return false. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae191e5641bb7bf9de1f871c436f13480" name="ae191e5641bb7bf9de1f871c436f13480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae191e5641bb7bf9de1f871c436f13480">&#9670;&#160;</a></span>zero_depends_on_row</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">constexpr</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> tatami::DelayedUnaryAdvancedMockHelper::zero_depends_on_row = <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">false</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Conversion of zeros to non-zero values is not dependent on the row of origin. Implementations of the advanced operation interface may set this to <code>true</code> provided that <code>zero_depends_on_column = false</code>; at least one of these must be false, otherwise a basic operation interface is expected (see <code><a class="el" href="structtatami_1_1DelayedUnaryBasicMockHelper.html" title="Basic mock operation for a DelayedUnaryIsometricOp.">DelayedUnaryBasicMockHelper</a></code>). </p>

</div>
</div>
<a id="a54e45d0e04cc055b59940dd3499546e7" name="a54e45d0e04cc055b59940dd3499546e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54e45d0e04cc055b59940dd3499546e7">&#9670;&#160;</a></span>zero_depends_on_column</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">constexpr</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> tatami::DelayedUnaryAdvancedMockHelper::zero_depends_on_column = <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">false</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Conversion of zeros to non-zero values is not dependent on the column of origin. Implementations of the advanced operation interface may set this to <code>true</code> provided that <code>zero_depends_on_row = false</code>. at least one of these must be false, otherwise a basic operation interface is expected (see <code><a class="el" href="structtatami_1_1DelayedUnaryBasicMockHelper.html" title="Basic mock operation for a DelayedUnaryIsometricOp.">DelayedUnaryBasicMockHelper</a></code>). </p>

</div>
</div>
<a id="a66a3438a78b1979cd6877c0ec239a780" name="a66a3438a78b1979cd6877c0ec239a780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a3438a78b1979cd6877c0ec239a780">&#9670;&#160;</a></span>non_zero_depends_on_row</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">constexpr</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> tatami::DelayedUnaryAdvancedMockHelper::non_zero_depends_on_row = <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">false</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether the operation requires the identity of the row of origin. This only determines whether <code>index = NULL</code> in <code><a class="el" href="structtatami_1_1DelayedUnaryAdvancedMockHelper.html#a2ff269446c0a7beb65eb43b715a984e0">sparse()</a></code>. May be true or false. </p>

</div>
</div>
<a id="aee361e39d7d9b5b712bbfcee3484a273" name="aee361e39d7d9b5b712bbfcee3484a273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee361e39d7d9b5b712bbfcee3484a273">&#9670;&#160;</a></span>non_zero_depends_on_column</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">constexpr</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> tatami::DelayedUnaryAdvancedMockHelper::non_zero_depends_on_column = <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">false</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether the operation requires the identity of the column of origin. This only determines whether <code>index = NULL</code> in <code><a class="el" href="structtatami_1_1DelayedUnaryAdvancedMockHelper.html#a2ff269446c0a7beb65eb43b715a984e0">sparse()</a></code>. May be true or false. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>tatami/isometric/unary/<a class="el" href="unary_2mock__helpers_8hpp_source.html">mock_helpers.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
