<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tatami: tatami::DelayedUnaryIsometricMockAdvanced Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tatami
   </div>
   <div id="projectbrief">C++ API for different matrix representations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetatami.html">tatami</a></li><li class="navelem"><a class="el" href="classtatami_1_1DelayedUnaryIsometricMockAdvanced.html">DelayedUnaryIsometricMockAdvanced</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classtatami_1_1DelayedUnaryIsometricMockAdvanced-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">tatami::DelayedUnaryIsometricMockAdvanced Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Advanced mock operation for <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>.  
 <a href="classtatami_1_1DelayedUnaryIsometricMockAdvanced.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="unary_2mock__helpers_8hpp_source.html">mock_helpers.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a09a1f20f737d635148079185c0121271" id="r_a09a1f20f737d635148079185c0121271"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">OutputValue_</a> &gt; </td></tr>
<tr class="memitem:a09a1f20f737d635148079185c0121271"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricMockAdvanced.html#a09a1f20f737d635148079185c0121271">dense</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">row</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">i</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">start</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">length</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a> *<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">input</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">OutputValue_</a> *<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">output</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a09a1f20f737d635148079185c0121271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a979faba017a5f0a4b6e8803d82455fdc" id="r_a979faba017a5f0a4b6e8803d82455fdc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">OutputValue_</a> &gt; </td></tr>
<tr class="memitem:a979faba017a5f0a4b6e8803d82455fdc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricMockAdvanced.html#a979faba017a5f0a4b6e8803d82455fdc">dense</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">row</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">i</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> std::vector&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">indices</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a> *<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">input</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">OutputValue_</a> *<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">output</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a979faba017a5f0a4b6e8803d82455fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ea600da94f5e0f8789f3bb2fe5ac81" id="r_ac8ea600da94f5e0f8789f3bb2fe5ac81"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">OutputValue_</a> &gt; </td></tr>
<tr class="memitem:ac8ea600da94f5e0f8789f3bb2fe5ac81"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricMockAdvanced.html#ac8ea600da94f5e0f8789f3bb2fe5ac81">sparse</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">row</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">i</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">num</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a> *<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">input_value</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> *index, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">OutputValue_</a> *<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">output_value</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:ac8ea600da94f5e0f8789f3bb2fe5ac81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c7d1aa30f41981075ba593e297fa1e" id="r_a38c7d1aa30f41981075ba593e297fa1e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">OutputValue_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; </td></tr>
<tr class="memitem:a38c7d1aa30f41981075ba593e297fa1e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">OutputValue_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricMockAdvanced.html#a38c7d1aa30f41981075ba593e297fa1e">fill</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">row</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">i</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a38c7d1aa30f41981075ba593e297fa1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecaacba2933b651a7332bb0606f8285f" id="r_aecaacba2933b651a7332bb0606f8285f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricMockAdvanced.html#aecaacba2933b651a7332bb0606f8285f">zero_depends_on_row</a> () <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:aecaacba2933b651a7332bb0606f8285f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6f6dc2ce03c242813f56c7e3f12e84" id="r_a4e6f6dc2ce03c242813f56c7e3f12e84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricMockAdvanced.html#a4e6f6dc2ce03c242813f56c7e3f12e84">zero_depends_on_column</a> () <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a4e6f6dc2ce03c242813f56c7e3f12e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a007536cd7ed1abc5411ba1e3526e200a" id="r_a007536cd7ed1abc5411ba1e3526e200a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricMockAdvanced.html#a007536cd7ed1abc5411ba1e3526e200a">non_zero_depends_on_row</a> () <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a007536cd7ed1abc5411ba1e3526e200a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a975c8c1eb8914048d2c03586241240a3" id="r_a975c8c1eb8914048d2c03586241240a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricMockAdvanced.html#a975c8c1eb8914048d2c03586241240a3">non_zero_depends_on_column</a> () <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a975c8c1eb8914048d2c03586241240a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909893bf9fda253bd08d0e0db298b3c4" id="r_a909893bf9fda253bd08d0e0db298b3c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricMockAdvanced.html#a909893bf9fda253bd08d0e0db298b3c4">is_sparse</a> () <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a909893bf9fda253bd08d0e0db298b3c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a2f82879f68e6672d7c33d0d3afdf831a" id="r_a2f82879f68e6672d7c33d0d3afdf831a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">static</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">constexpr</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricMockAdvanced.html#a2f82879f68e6672d7c33d0d3afdf831a">is_basic</a> = <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">false</a></td></tr>
<tr class="separator:a2f82879f68e6672d7c33d0d3afdf831a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Advanced mock operation for <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </p>
<p>This class defines the advanced expectations for an operation in <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>, which improves efficiency by taking advantage of any sparsity in the underlying matrix. Either the operation itself preserves sparsity, or any loss of sparsity is predictable, i.e., zeros are transformed into a constant non-zero value that does not depend on its position in the <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code>.</p>
<p>Actual operations aren't expected to inherit from this class; this is only provided for documentation purposes. Operations only need to implement methods with the same signatures for compile-time polymorphism. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a09a1f20f737d635148079185c0121271" name="a09a1f20f737d635148079185c0121271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09a1f20f737d635148079185c0121271">&#9670;&#160;</a></span>dense() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">OutputValue_</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">void</a> tatami::DelayedUnaryIsometricMockAdvanced::dense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a> *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">OutputValue_</a> *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method accepts a contiguous block of an element of the target dimension from the underlying matrix (<code>input</code>), applies the operation to each value, and stores the result in another array of different type (<code>output</code>).</p>
<p>Implementions of this method do not necessarily need to have the same template arguments as shown here. It will be called without any explicit template arguments so anything can be used as long as type deduction works.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index_</td><td>Type of index value. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of matrix value to use in the operation. </td></tr>
    <tr><td class="paramname">OutputValue_</td><td>Type of matrix value returned by the operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">row</td><td>Whether the rows are the target dimension. If true, <code>buffer</code> contains row <code>i</code>, otherwise it contains column <code>i</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">i</td><td>Index of the extracted row (if <code>row = true</code>) or column (otherwise). This argument should be ignored if the operation does not depend on the row/column (i.e., when all of <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricMockAdvanced.html#aecaacba2933b651a7332bb0606f8285f">zero_depends_on_row()</a></code> and friends return false), in which case an arbitrary placeholder may be supplied. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">start</td><td>Start of the contiguous block of columns (if <code>row = true</code>) or rows (otherwise) extracted from <code>i</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">length</td><td>Length of the contiguous block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Pointer to an array containing a contiguous block of a row/column extracted from the matrix. This has <code>length</code> addressable elements. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Pointer to an array to store the results of the operation applied to elements of <code>input</code>. This has <code>length</code> addressable elements. If <code>InputValue_ == OutputValue_</code>, this is guaranteed to be the same as <code>input</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a979faba017a5f0a4b6e8803d82455fdc" name="a979faba017a5f0a4b6e8803d82455fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a979faba017a5f0a4b6e8803d82455fdc">&#9670;&#160;</a></span>dense() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">OutputValue_</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">void</a> tatami::DelayedUnaryIsometricMockAdvanced::dense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> std::vector&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a> *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">OutputValue_</a> *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method accepts an indexed subset of an element of the target dimension from the underlying matrix (<code>input</code>), applies the operation to each value, and stores the result in another array of different type (<code>output</code>).</p>
<p>Implementions of this method do not necessarily need to have the same template arguments as shown here. It will be called without any explicit template arguments so anything can be used as long as type deduction works.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputValue_</td><td>Type of matrix value to use in the operation. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of index value. </td></tr>
    <tr><td class="paramname">OutputValue_</td><td>Type of matrix value returned by the operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">row</td><td>Whether the rows are the target dimension. If true, <code>buffer</code> contains row <code>i</code>, otherwise it contains column <code>i</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">i</td><td>Index of the extracted row (if <code>row = true</code>) or column (otherwise). This argument should be ignored if the operation does not depend on the row/column (i.e., when all of <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricMockAdvanced.html#aecaacba2933b651a7332bb0606f8285f">zero_depends_on_row()</a></code> and friends return false), in which case an arbitrary placeholder may be supplied. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">indices</td><td>Sorted and unique indices of columns (if <code>row = true</code>) or rows (otherwise) extracted from <code>i</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Pointer to an array containing an indexed subset of a row/column extracted from the matrix. This has <code>length</code> addressable elements. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Pointer to an array to store the results of the operation applied to elements of <code>input</code>. This has <code>length</code> addressable elements. If <code>InputValue_ == OutputValue_</code>, this is guaranteed to be the same as <code>input</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8ea600da94f5e0f8789f3bb2fe5ac81" name="ac8ea600da94f5e0f8789f3bb2fe5ac81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8ea600da94f5e0f8789f3bb2fe5ac81">&#9670;&#160;</a></span>sparse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">OutputValue_</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">void</a> tatami::DelayedUnaryIsometricMockAdvanced::sparse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a> *&#160;</td>
          <td class="paramname"><em>input_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">OutputValue_</a> *&#160;</td>
          <td class="paramname"><em>output_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method is expected to iterate over <code>input_value</code>, apply the operation to each value, and store the result in <code>output_value</code>. We assume that the operation only needs to be applied to the structural non-zeros; structural zeros are either ignored for sparsity-preserving operations, or the result of the operation on zeros will be populated by <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricMockAdvanced.html#a38c7d1aa30f41981075ba593e297fa1e">fill()</a></code>.</p>
<p>If <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricMockAdvanced.html#a007536cd7ed1abc5411ba1e3526e200a">non_zero_depends_on_row()</a> &amp;&amp; !row</code> or <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricMockAdvanced.html#a975c8c1eb8914048d2c03586241240a3">non_zero_depends_on_column()</a> &amp;&amp; row</code>, <code>index</code> is guaranteed to be non-NULL. Otherwise, it may be NULL and should be ignored. Even if non-NULL, indices are not guaranteed to be sorted.</p>
<p>Implementations of this method do not necessarily need to have the same template arguments as shown here. It will be called without any explicit template arguments so anything can be used as long as type deduction works.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index_</td><td>Type of index value. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of matrix value to use in the operation. </td></tr>
    <tr><td class="paramname">OutputValue_</td><td>Type of matrix value returned by the operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">row</td><td>Whether the rows are the target dimension. If true, <code>buffer</code> contains row <code>i</code>, otherwise it contains column <code>i</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">i</td><td>Index of the extracted row (if <code>row = true</code>) or column (otherwise). This argument should be ignored if the operation does not depend on the row/column (i.e., when all of <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricMockAdvanced.html#aecaacba2933b651a7332bb0606f8285f">zero_depends_on_row()</a></code> and friends return false), in which case an arbitrary placeholder may be supplied. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">num</td><td>Number of non-zero elements for row/column <code>i</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input_value</td><td>Pointer to an array of values of the structural non-zero elements from the row/column of the matrix. This is guaranteed to have <code>num</code> addressable elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Pointer to an array of column (if <code>row = true</code>) or row indices (otherwise) of the non-zero elements. Alternatively NULL. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_value</td><td>Pointer to an array in which to store the result of the operation on each element of <code>input_value</code>. This is guaranteed to have <code>num</code> addressable elements. If <code>InputValue_ == OutputValue_</code>, this is guaranteed to be the same as <code>input</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38c7d1aa30f41981075ba593e297fa1e" name="a38c7d1aa30f41981075ba593e297fa1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38c7d1aa30f41981075ba593e297fa1e">&#9670;&#160;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">OutputValue_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">OutputValue_</a> tatami::DelayedUnaryIsometricMockAdvanced::fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the operation. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the operation. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of index value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Whether <code>i</code> refers to the row or column index. </td></tr>
    <tr><td class="paramname">i</td><td>The index of the row (if <code>row = true</code>) or column (otherwise) containing the zeros. This argument should be ignored if the operation does not depend on the row/column (i.e., when all of <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricMockAdvanced.html#aecaacba2933b651a7332bb0606f8285f">zero_depends_on_row()</a></code> and friends return false), in which case an arbitrary placeholder may be supplied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation being applied on zeros from the <code>i</code>-th row/column of the matrix.</dd></dl>
<p>This method will be called with the explicit <code>OutputValue_</code> and <code>InputValue_</code> template parameters. Implementations of this method should either ensure that <code>Index_</code> is deducible or use a fixed integer type in the method signature. </p>

</div>
</div>
<a id="aecaacba2933b651a7332bb0606f8285f" name="aecaacba2933b651a7332bb0606f8285f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecaacba2933b651a7332bb0606f8285f">&#9670;&#160;</a></span>zero_depends_on_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> tatami::DelayedUnaryIsometricMockAdvanced::zero_depends_on_row </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Whether the operation will convert a structural zero to a non-zero value, in a manner that depends on the identity of the column in which the structural zero occurs.</dd></dl>
<p>This method is only called when <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricMockAdvanced.html#a909893bf9fda253bd08d0e0db298b3c4">is_sparse()</a></code> returns false. It is not necessary to explicitly return <code>false</code> here for sparsity-preserving operations, as <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code> will automatically recognize such operations as being row-independent.</p>
<p>This method may be omitted from the class definition, in which case it is assumed to always return false. </p>

</div>
</div>
<a id="a4e6f6dc2ce03c242813f56c7e3f12e84" name="a4e6f6dc2ce03c242813f56c7e3f12e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e6f6dc2ce03c242813f56c7e3f12e84">&#9670;&#160;</a></span>zero_depends_on_column()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> tatami::DelayedUnaryIsometricMockAdvanced::zero_depends_on_column </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Whether the operation will convert a structural zero to a non-zero value, in a manner that depends on the identity of the column in which the structural zero occurs.</dd></dl>
<p>This method is only called when <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricMockAdvanced.html#a909893bf9fda253bd08d0e0db298b3c4">is_sparse()</a></code> returns false. It is not necessary to explicitly return <code>false</code> here for sparsity-preserving operations, as <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code> will automatically recognize such operations as being row-independent.</p>
<p>This method may be omitted from the class definition, in which case it is assumed to always return false. </p>

</div>
</div>
<a id="a007536cd7ed1abc5411ba1e3526e200a" name="a007536cd7ed1abc5411ba1e3526e200a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a007536cd7ed1abc5411ba1e3526e200a">&#9670;&#160;</a></span>non_zero_depends_on_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> tatami::DelayedUnaryIsometricMockAdvanced::non_zero_depends_on_row </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Whether the result of the operation on a non-zero operand depends on the identity of the row containing the operand.</dd></dl>
<p>This method may be omitted from the class definition, in which case it is assumed to always return false. </p>

</div>
</div>
<a id="a975c8c1eb8914048d2c03586241240a3" name="a975c8c1eb8914048d2c03586241240a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a975c8c1eb8914048d2c03586241240a3">&#9670;&#160;</a></span>non_zero_depends_on_column()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> tatami::DelayedUnaryIsometricMockAdvanced::non_zero_depends_on_column </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Whether the result of the operation on a non-zero operand depends on the identity of the column containing the operand.</dd></dl>
<p>This method may also omitted from the class definition, in which case it is assumed to always return false. </p>

</div>
</div>
<a id="a909893bf9fda253bd08d0e0db298b3c4" name="a909893bf9fda253bd08d0e0db298b3c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a909893bf9fda253bd08d0e0db298b3c4">&#9670;&#160;</a></span>is_sparse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> tatami::DelayedUnaryIsometricMockAdvanced::is_sparse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Does this operation preserve sparsity? This may return false. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a2f82879f68e6672d7c33d0d3afdf831a" name="a2f82879f68e6672d7c33d0d3afdf831a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f82879f68e6672d7c33d0d3afdf831a">&#9670;&#160;</a></span>is_basic</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">constexpr</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> tatami::DelayedUnaryIsometricMockAdvanced::is_basic = <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">false</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether this is a basic operation. This should be false, otherwise a basic operation interface is expected (see <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricMockBasic.html" title="Basic mock operation for a DelayedUnaryIsometricOperation.">DelayedUnaryIsometricMockBasic</a></code>). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>tatami/isometric/unary/<a class="el" href="unary_2mock__helpers_8hpp_source.html">mock_helpers.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
