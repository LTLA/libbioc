<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tatami: A C++ API for all sorts of matrices</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tatami
   </div>
   <div id="projectbrief">C++ API for different matrix representations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">A C++ API for all sorts of matrices </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__github_workspace_README"></a> <img src="https://github.com/LTLA/tatami/actions/workflows/run-tests.yaml/badge.svg" alt="Unit tests" style="pointer-events: none;" class="inline"/> <img src="https://github.com/LTLA/tatami/actions/workflows/run-gallery.yaml/badge.svg" alt="Gallery" style="pointer-events: none;" class="inline"/> <img src="https://github.com/LTLA/tatami/actions/workflows/doxygenate.yaml/badge.svg" alt="Documentation" style="pointer-events: none;" class="inline"/> <a href="https://codecov.io/gh/LTLA/tatami"><img src="https://codecov.io/gh/LTLA/tatami/branch/master/graph/badge.svg?token=Z189ORCLLR" alt="Codecov" style="pointer-events: none;" class="inline"/></a></p>
<h1>Overview</h1>
<p><b>tatami</b> is a spiritual successor to the <a href="https://github.com/LTLA/beachmat"><b>beachmat</b> C++ API</a> that provides read access to different matrix representations. Specifically, applications can use <b>tatami</b> to read rows and/or columns of a matrix without any knowledge of the specific matrix representation. This allows application developers to write a single piece of code that will work seamlessly with different inputs, even if the underlying representation varies at run-time.</p>
<p><b>tatami</b> (and <b>beachmat</b> before it) is motivated by analyses of processed genomics data, where matrices are often interpreted as a collection of row- or column-wise vectors. Many applications involve looping over rows or columns to compute some statistic or summary - for example, testing for differential expression within each row of the matrix. <b>tatami</b> aims to optimize this access pattern across a variety of different matrix representations, depending on how the data is provided to the application.</p>
<p>Currently supported representations include:</p>
<ul>
<li>Dense row/column major matrices, with user-defined storage modes and containers.</li>
<li>Compressed sparse row/column matrices, with user-defined storage modes and containers.</li>
<li>Matrices generated by delayed operations, ~stolen~ inspired by those in <a href="https://github.com/Bioconductor/DelayedArray"><b>DelayedArray</b></a>.</li>
</ul>
<h1>Quick start</h1>
<p><b>tatami</b> is a header-only library, so it can be easily used by just <code>#include</code>ing the relevant source files:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="tatami_8hpp.html">tatami/tatami.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line">std::shared_ptr&lt;tatami::NumericMatrix&gt; mat(<span class="keyword">new</span> <a class="code hl_class" href="classtatami_1_1DenseMatrix.html">tatami::DenseRowMatrix&lt;double&gt;</a>(nrows, ncols, vals));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get the dimensions:</span></div>
<div class="line"><span class="keywordtype">size_t</span> NR = mat-&gt;nrow(), NC = mat-&gt;ncol();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Extract a column &#39;i&#39;:</span></div>
<div class="line">std::vector&lt;double&gt; buffer(NR);</div>
<div class="line"><span class="keyword">auto</span> workspace = mat-&gt;new_column_workspace();</div>
<div class="line"><span class="keyword">auto</span> ptr = mat-&gt;column(i, buffer.data(), workspace.get());</div>
<div class="line">ptr[0]; <span class="comment">// first element of the column.</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Extract the [5, 10) rows of the &#39;i&#39;-th column.</span></div>
<div class="line"><span class="keyword">auto</span> slicedwork = mat-&gt;new_column_workspace(5, 5)</div>
<div class="line"><span class="keyword">auto</span> ptr = mat-&gt;column(i, buffer.data(), slicedwork.get());</div>
<div class="ttc" id="aclasstatami_1_1DenseMatrix_html"><div class="ttname"><a href="classtatami_1_1DenseMatrix.html">tatami::DenseMatrix</a></div><div class="ttdoc">Dense matrix representation.</div><div class="ttdef"><b>Definition:</b> DenseMatrix.hpp:35</div></div>
<div class="ttc" id="atatami_8hpp_html"><div class="ttname"><a href="tatami_8hpp.html">tatami.hpp</a></div><div class="ttdoc">Flexible representations of matrix data.</div></div>
</div><!-- fragment --><p>The key idea here is that, once <code>mat</code> is created, the application does not need to worry about the exact format of the matrix referenced by the pointer. Application developers can write code that works interchangeably with a variety of different matrix representations.</p>
<h1>Access patterns</h1>
<p>The <b>tatami</b> API is designed for read-only access - it is not possible to alter the matrix contents via the API. This is especially relevant for matrices with delayed operations or those referring to remote data stores, where reading the matrix data is trivial but writing is not guaranteed to work. As a result, supported operations are limited to reading data from the matrix:</p>
<ul>
<li><code>nrow()</code> and <code>ncol()</code> return the number of rows and columns, respectively.</li>
<li><code>row()</code> and <code>column()</code> return pointers to the start of a (contiguous slice of a) row and column, respectively.</li>
<li><code>sparse_row()</code> and <code>sparse_column()</code> return pointers to the values and indices of the non-zero elements in a row and column, respectively.</li>
</ul>
<div class="fragment"><div class="line">std::vector&lt;double&gt; ibuffer(NC), vbuffer(NC);</div>
<div class="line"><span class="keyword">auto</span> rowspace = mat-&gt;new_row_workspace();</div>
<div class="line"><span class="keyword">auto</span> indexed = mat-&gt;sparse_row(i, vbuffer.data(), ibuffer.data(), rowspace.get());</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; indexed.number; ++i) {</div>
<div class="line">    indexed.index[i]; <span class="comment">// index of the element</span></div>
<div class="line">    indexed.value[i]; <span class="comment">// value of the element</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>For performance-critical sections, it may be desirable to customize the client code based on properties of the matrix. This is supported with the following methods:</p>
<ul>
<li><code>sparse()</code> indicates whether a matrix is sparse.</li>
<li><code>prefer_rows()</code> indicates whether a matrix is more efficiently access along its rows (e.g., row-major dense matrices).</li>
</ul>
<p>This allows client developers to design special code paths to take advantage of these properties - the <a href="https://github.com/LTLA/tatami/tree/master/gallery/src/colsums.cpp"><code>colsums.cpp</code></a> example is particularly demonstrative.</p>
<p>All methods in <b>tatami</b> are <code>const</code> and thus can be used concurrently. Any mutable information that needs to persist across API calls is handled by passing a writeable pointer to a <code>workspace</code> object to each call. This can be used to cache information across calls for greater efficiency, e.g., when iterating across consecutive rows or columns of a matrix; run the <a href="https://github.com/LTLA/tatami/tree/master/gallery/src/sparse_workspace.cpp"><code>sparse_workspace.cpp</code></a> example to compare performance.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> wrk = mat-&gt;new_row_workspace();</div>
<div class="line">std::vector&lt;double&gt; buffer2(NC);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; mat-&gt;nrow(); ++i) {</div>
<div class="line">    <span class="keyword">auto</span> ptr = mat-&gt;row(i, buffer2.data(), wrk.get());</div>
<div class="line">}</div>
</div><!-- fragment --><p>Check out the <a href="https://ltla.github.io/tatami">reference documentation</a> for more details on the available classes and operations. The <a href="https://github.com/LTLA/tatami/tree/master/gallery">gallery</a> also contains worked examples for common operations based on row/column traversals.</p>
<h1>API design</h1>
<p>We use templating to define the type of values returned by the interface. This includes the type of the data (most typically <code>double</code>) as well as the type of row/column indices (default <code>int</code>, but one could imagine using, e.g., <code>size_t</code>). It is worth noting that the storage type does not need to be the same as the interface type. For example, developers could store a matrix of small counts as <code>uint16_t</code> while returning <code>double</code>s for compatibility with downstream mathematical code.</p>
<p>Most of the examples in the <b>tatami</b> documentation use a <code>shared_ptr</code> to a <code><a class="el" href="namespacetatami.html#a35c670894994f1d620abb55953f98441">tatami::NumericMatrix</a></code>, relying on run-time polymorphism to determine the right method to call. This allows applications to easily handle a variety of different input representations. Alternatively, applications may use templating to achieve compile-time polymorphism on the different <b>tatami</b> subclasses, but this is rather restrictive without providing obvious performance benefits.</p>
<p>Classes are named with <code>CamelCase</code>, while all functions, methods and members use <code>snake_case</code>.</p>
<h1>Other operations</h1>
<p>As previously mentioned, <b>tatami</b> is designed to pull out rows or columns of a matrix, and little else. Some support is provided for basic statistics in the same vein as the <a href="https://github.com/HenrikBengtsson/matrixStats"><b>matrixStats</b></a> package:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> colsums = <a class="code hl_function" href="namespacetatami.html#a3b06061261eeb15d1827dd7290162ae8">tatami::column_sums</a>(mat);</div>
<div class="line"><span class="keyword">auto</span> rowvars = <a class="code hl_function" href="namespacetatami.html#a2aa54193cf4c92ace983cba8c118ca1a">tatami::row_variances</a>(mat);</div>
<div class="ttc" id="anamespacetatami_html_a2aa54193cf4c92ace983cba8c118ca1a"><div class="ttname"><a href="namespacetatami.html#a2aa54193cf4c92ace983cba8c118ca1a">tatami::row_variances</a></div><div class="ttdeci">std::vector&lt; Output &gt; row_variances(const Matrix&lt; T, IDX &gt; *p, int threads=1)</div><div class="ttdef"><b>Definition:</b> variances.hpp:364</div></div>
<div class="ttc" id="anamespacetatami_html_a3b06061261eeb15d1827dd7290162ae8"><div class="ttname"><a href="namespacetatami.html#a3b06061261eeb15d1827dd7290162ae8">tatami::column_sums</a></div><div class="ttdeci">std::vector&lt; Output &gt; column_sums(const Matrix&lt; T, IDX &gt; *p, int threads=1)</div><div class="ttdef"><b>Definition:</b> sums.hpp:120</div></div>
</div><!-- fragment --><p><b>tatami</b> does not support matrix algebra or decompositions. For this we typically use <a href="https://eigen.tuxfamily.org/"><b>Eigen</b></a>, effectively trading the diversity of representations for a much more comprehensive suite of operations. A frequent pattern is to use <b>tatami</b> to load the input data, which is usually in a custom format to save memory for large datasets; process it into a smaller submatrix, e.g., by selecting features of interest in a genome-scale analysis; and then copy this cheaply into an <code>Eigen::MatrixXd</code> or <code>Eigen::SparseMatrix</code> for more computationally intensive work.</p>
<h1>Building projects</h1>
<p>If you're using CMake, you just need to add something like this to your <code>CMakeLists.txt</code>:</p>
<div class="fragment"><div class="line">include(FetchContent)</div>
<div class="line"> </div>
<div class="line">FetchContent_Declare(</div>
<div class="line">  tatami</div>
<div class="line">  GIT_REPOSITORY https://github.com/LTLA/tatami</div>
<div class="line">  GIT_TAG master # or any version of interest </div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">FetchContent_MakeAvailable(tatami)</div>
</div><!-- fragment --><p>Then you can link to <b>tatami</b> to make the headers available during compilation:</p>
<div class="fragment"><div class="line"># For executables:</div>
<div class="line">target_link_libraries(myexe tatami)</div>
<div class="line"> </div>
<div class="line"># For libaries</div>
<div class="line">target_link_libraries(mylib INTERFACE tatami)</div>
</div><!-- fragment --><p>If you're not using CMake, the simple approach is to just copy the files - either directly or with Git submodules - and include their path during compilation with, e.g., GCC's <code>-I</code>. If you want to read Matrix Market files, you'll also need to add the <a href="https://github.com/clusterfork/buffin"><b>buffin</b></a> header-only library to the compiler's search path.</p>
<h1>TODO</h1>
<ul>
<li>Add bindings for TileDB. </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
