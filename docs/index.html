<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tatami: A C++ API for all sorts of matrices</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tatami
   </div>
   <div id="projectbrief">C++ API for different matrix representations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">A C++ API for all sorts of matrices </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__github_workspace_README"></a> </p><h1>Overview</h1>
<p><b>tatami</b> is a spiritual successor to the <a href="https://github.com/LTLA/beachmat"><b>beachmat</b> C++ API</a> that provides a C++ API into various matrix representations:</p>
<ul>
<li>Dense row/column major matrices, with user-defined containers.</li>
<li>Compressed sparse row/column matrices, with user-defined containers.</li>
<li>Matrices generated by delayed operations, ~stolen~ inspired by those in <a href="https://github.com/Bioconductor/DelayedArray"><b>DelayedArray</b></a>.</li>
</ul>
<p>Our design uses polymorphism to support a consistent set of methods across different matrix representations. For example, all numeric matrices support extraction of a vector of <code>double</code>s from a single row via the <code>row()</code> method. By using the <b>tatami</b> interface, client code can operate on all supported representations with minimal customization.</p>
<h1>Quick start</h1>
<p><b>tatami</b> is a header-only library so can be easily used by just including the source files:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;tatami/tatami.h&quot;</span></div>
</div><!-- fragment --><p>The key data structure is a shared pointer to a <code>typed_matrix</code> class. This is most commonly a <code>numeric_matrix</code>, where the values are specified as <code>double</code>s and the row/column indices are specified as <code>int</code>s. Here, we fill up a dense row-major matrix:</p>
<div class="fragment"><div class="line">std::vector&lt;double&gt; vals(50);</div>
<div class="line">std::iota(vals.begin(), vals.end(), 0.0);</div>
<div class="line">std::shared_ptr&lt;tatami::numeric_matrix&gt; mat(<span class="keyword">new</span> <a class="code" href="classtatami_1_1DenseMatrix.html">tatami::DenseRowMatrix&lt;double&gt;</a>(10, 5, vals));</div>
<div class="ttc" id="aclasstatami_1_1DenseMatrix_html"><div class="ttname"><a href="classtatami_1_1DenseMatrix.html">tatami::DenseMatrix</a></div><div class="ttdoc">Dense matrix representation.</div><div class="ttdef"><b>Definition:</b> DenseMatrix.hpp:31</div></div>
</div><!-- fragment --><p>We can then call a variety of methods without worrying about the exact class of the matrix referenced by <code>mat</code>. For example, to get the number of rows and columns:</p>
<div class="fragment"><div class="line"><span class="keywordtype">size_t</span> NR = mat-&gt;nrow(), NC = mat-&gt;ncol();</div>
</div><!-- fragment --><p>To extract a row or column, we use the <code>column()</code> method to pull out a dense vector. This requires the caller to supply a buffer though it may not actually be used if the values are already contiguous in memory in the underlying representation.</p>
<div class="fragment"><div class="line">std::vector&lt;double&gt; buffer(NR);</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span>* ptr = mat-&gt;column(i, buffer.data());</div>
</div><!-- fragment --><p>And that's it.</p>
<h1>Concepts</h1>
<p>As previously mentioned, we make heavy use of polymorphism to determine the right method to call at run-time. This motivates the use of a <code>shared_ptr</code> to a <code>tatami::numeric_matrix</code> rather than a more conventionally constructed object. In the example above, after the construction of <code>mat</code>, downstream code does not have to care about the exact representation of the matrix data; this allows clients to write one piece of C++ code that works immediately with a variety of input matrices.</p>
<p>The API is designed for read-only access - it is not possible to alter the matrix contents via the API. (This is especially true for matrices where the data is remotely hosted, e.g., on AWS S3.) All methods in the API are similiarly <code>const</code> and thus are safe for concurrent use. Any information that needs to persist across API calls is handled by passing a writeable pointer to a <code>workspace</code> object to each call.</p>
<p>For performance-critical sections, it may be desirable to customize the client code based on properties of the matrix. <b>tatami</b> offers the <code>sparse()</code> and <code>prefer_rows()</code> methods that indicate whether a matrix is sparse and if it prefers extraction on the rows (e.g., for row-major matrices). This allows client developers to design special code paths to take advantage of these properties - the <a href="gallery/colsums.cpp"><code>colsums.cpp</code></a> example is particularly demonstrative.</p>
<p>We use templating to define the type of values returned by the interface. This includes the type of the data (most typically <code>double</code>) as well as the type of row/column indices (default <code>int</code>, but one could imagine using, e.g., <code>size_t</code>). It is worth noting that the storage type does not need to be the same as the interface type. For example, developers could store a matrix of small counts as <code>uint16_t</code> while returning <code>double</code>s for compatibility with downstream mathematical code.</p>
<p>Matrix classes named with <code>snake_case</code> are virtual and intended for use as interfaces - these cannot be directly constructed. Matrix classes named with <code>CamelCase</code> correspond to actual matrix representations and can be explicitly constructed. All other functions or non-matrix classes use <code>snake_case</code>.</p>
<h1>Documentation</h1>
<p>The `gallery` contains worked examples for common operations based on row/column traversals.</p>
<p>The `include` documentation contains further instructions on use, particularly for extensions.</p>
<p>The <a href="https://ltla.github.io/tatami">reference documentation</a> for the API is generated automatically with Doxygen.</p>
<h1>TODO</h1>
<ul>
<li>Add bindings for TileDB. </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
