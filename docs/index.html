<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tatami: A C++ API for all sorts of matrices</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tatami
   </div>
   <div id="projectbrief">C++ API for different matrix representations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">A C++ API for all sorts of matrices </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__2github_2workspace_2README"></a> <img src="https://github.com/tatami-inc/tatami/actions/workflows/run-tests.yaml/badge.svg" alt="Unit tests" style="pointer-events: none;" class="inline"/> <img src="https://github.com/tatami-inc/tatami/actions/workflows/run-gallery.yaml/badge.svg" alt="Gallery" style="pointer-events: none;" class="inline"/> <img src="https://github.com/tatami-inc/tatami/actions/workflows/doxygenate.yaml/badge.svg" alt="Documentation" style="pointer-events: none;" class="inline"/> <a href="https://codecov.io/gh/tatami-inc/tatami"><img src="https://codecov.io/gh/tatami-inc/tatami/branch/master/graph/badge.svg?token=Z189ORCLLR" alt="Codecov" style="pointer-events: none;" class="inline"/></a></p>
<h1>Overview</h1>
<p><b>tatami</b> is a spiritual successor to the <a href="https://github.com/tatami-inc/beachmat"><b>beachmat</b> C++ API</a> that provides read access to different matrix representations. Specifically, applications can use <b>tatami</b> to read rows and/or columns of a matrix without any knowledge of the specific matrix representation. This allows application developers to write a single piece of code that will work seamlessly with different inputs, even if the underlying representation varies at run-time. In particular, <b>tatami</b> is motivated by analyses of processed genomics data, where matrices are often interpreted as a collection of row- or column-wise vectors. Many applications involve looping over rows or columns to compute some statistic or summary - for example, testing for differential expression within each row of the matrix. <b>tatami</b> aims to optimize this access pattern across a variety of different matrix representations, depending on how the data is provided to the application.</p>
<h1>Quick start</h1>
<p><b>tatami</b> is a header-only library, so it can be easily used by just <code>#include</code>ing the relevant source files:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="tatami_8hpp.html">tatami/tatami.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line">std::shared_ptr&lt;tatami::NumericMatrix&gt; mat(<span class="keyword">new</span> <a class="code hl_class" href="classtatami_1_1DenseMatrix.html">tatami::DenseRowMatrix&lt;double&gt;</a>(nrows, ncols, vals));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get the dimensions:</span></div>
<div class="line"><span class="keywordtype">int</span> NR = mat-&gt;nrow(), NC = mat-&gt;ncol();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Extract the &#39;i&#39;-th column.</span></div>
<div class="line"><span class="keyword">auto</span> extractor = mat-&gt;dense_column();</div>
<div class="line">std::vector&lt;double&gt; buffer(NR);</div>
<div class="line"><span class="keyword">auto</span> ptr = extractor-&gt;fetch(i, buffer.data());</div>
<div class="line">ptr[0]; </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Extract the [5, 12) rows of the &#39;i&#39;-th column.</span></div>
<div class="line"><span class="keyword">auto</span> sliced_extractor = mat-&gt;dense_column(5, 7)</div>
<div class="line"><span class="keyword">auto</span> sliced_ptr = sliced_extractor-&gt;fetch(i, buffer.data());</div>
<div class="ttc" id="aclasstatami_1_1DenseMatrix_html"><div class="ttname"><a href="classtatami_1_1DenseMatrix.html">tatami::DenseMatrix</a></div><div class="ttdoc">Dense matrix representation.</div><div class="ttdef"><b>Definition</b> DenseMatrix.hpp:34</div></div>
<div class="ttc" id="atatami_8hpp_html"><div class="ttname"><a href="tatami_8hpp.html">tatami.hpp</a></div><div class="ttdoc">Flexible representations of matrix data.</div></div>
</div><!-- fragment --><p>The key idea here is that, once <code>mat</code> is created, the application does not need to worry about the exact format of the matrix referenced by the pointer. Application developers can write code that works interchangeably with a variety of different matrix representations.</p>
<h1>Instructions</h1>
<h2>Creating a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code></h2>
<p>Users can create an instance of a concrete <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code> subclass by using one of the constructors or the equivalent <code>make_*</code> utility:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Class or function    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Dense matrix   </td><td class="markdownTableBodyNone"><code>DenseMatrix</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Compressed sparse matrix   </td><td class="markdownTableBodyNone"><code>CompressedSparseMatrix</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">"Semi-compressed" sparse matrix   </td><td class="markdownTableBodyNone"><code>SemiCompressedSparseMatrix</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Delayed isometric unary operation   </td><td class="markdownTableBodyNone"><code>make_DelayedIsometricOp()</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Delayed combination   </td><td class="markdownTableBodyNone"><code>make_DelayedBind()</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Delayed subset   </td><td class="markdownTableBodyNone"><code>make_DelayedSubset()</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Delayed transpose   </td><td class="markdownTableBodyNone"><code>make_DelayedTranspose()</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Delayed cast   </td><td class="markdownTableBodyNone"><code>make_DelayedCast()</code>   </td></tr>
</table>
<p>For example, to create a compressed sparse matrix from sparse triplet data, we could do:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="tatami_8hpp.html">tatami/tatami.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> NROW = 10, NCOL = 20;</div>
<div class="line"><span class="keyword">auto</span> indptrs = tatami::compress_sparse_triplets&lt;false&gt;(NR, NC, x, i, j);</div>
<div class="line"><span class="keyword">auto</span> raw_ptr = <span class="keyword">new</span> <a class="code hl_typedef" href="namespacetatami.html#a18cee3a5d9734f0092b03d023cfe4b6a">tatami::CompressedSparseColumnMatrix</a>(</div>
<div class="line">    NR, </div>
<div class="line">    NC, </div>
<div class="line">    std::move(x), </div>
<div class="line">    std::move(i), </div>
<div class="line">    std::move(indptrs)</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">std::shared_ptr&lt;tatami::Matrix&lt;double, int&gt; &gt; mat(raw_ptr);</div>
<div class="ttc" id="anamespacetatami_html_a18cee3a5d9734f0092b03d023cfe4b6a"><div class="ttname"><a href="namespacetatami.html#a18cee3a5d9734f0092b03d023cfe4b6a">tatami::CompressedSparseColumnMatrix</a></div><div class="ttdeci">CompressedSparseMatrix&lt; false, Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt; CompressedSparseColumnMatrix</div><div class="ttdef"><b>Definition</b> CompressedSparseMatrix.hpp:735</div></div>
</div><!-- fragment --><p>We typically create a <code>shared_ptr</code> to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code> to leverage run-time polymorphism. This enables downstream applications to accept many different matrix representations by compiling against the <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code> interface. Alternatively, applications may use templating to achieve compile-time polymorphism on the different <b>tatami</b> subclasses, but this is rather restrictive without providing obvious performance benefits.</p>
<p>We use templating to define the type of values returned by the interface. This includes the type of the data (most typically <code>double</code>) as well as the type of row/column indices (default <code>int</code>, but one could imagine using, e.g., <code>size_t</code>). It is worth noting that the storage type does not need to be the same as the interface type. For example, developers could store a matrix of small counts as <code>uint16_t</code> while returning <code>double</code>s for compatibility with downstream mathematical code.</p>
<p>The delayed operations are ~stolen from~ inspired by those in the <a href="https://github.com/Bioconductor/DelayedArray"><b>DelayedArray</b></a> package. Isometric operations are particularly useful as they accommodate matrix-scalar/vector arithmetic and various mathematical operations. For example, we could apply a sparsity-breaking delayed operation to our sparse matrix <code>mat</code> without actually creating a dense matrix:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structtatami_1_1DelayedAddScalarHelper.html">tatami::DelayedAddScalarHelper&lt;double&gt;</a> op(1);</div>
<div class="line"><span class="keyword">auto</span> mat2 = tatami::make_DelayedIsometricOp(mat, std::move(op));</div>
<div class="ttc" id="astructtatami_1_1DelayedAddScalarHelper_html"><div class="ttname"><a href="structtatami_1_1DelayedAddScalarHelper.html">tatami::DelayedAddScalarHelper</a></div><div class="ttdoc">Add a scalar to all values of a matrix.</div><div class="ttdef"><b>Definition</b> arith_scalar_helpers.hpp:24</div></div>
</div><!-- fragment --><p>Some libraries in the <a href="https://github.com/tatami-inc"><b>@tatami-inc</b></a> organization implement further extensions of <b>tatami</b>'s interface, e.g., for <a href="https://github.com/tatami-inc/tatami_hdf5">HDF5-backed matrices</a> and <a href="https://github.com/tatami-inc/tatami_r">R-based matrices</a>.</p>
<h2>Extracting matrix contents</h2>
<p>Given an abstract <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>, we create an <code>Extractor</code> to actually extract the matrix data. Each <code>Extractor</code> object can store intermediate data for re-use during iteration through the matrix, which is helpful for some matrix implementations that do not easily support random access. For example, to perform extract dense rows from our <code>mat</code>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> NR = mat-&gt;nrow();</div>
<div class="line"><span class="keywordtype">int</span> NC = mat-&gt;ncol();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> ext = mat-&gt;dense_row();</div>
<div class="line">std::vector&lt;double&gt; buffer(NC);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> r = 0; r &lt; NR; ++r) {</div>
<div class="line">    <span class="keyword">auto</span> current = ext-&gt;fetch(r, buffer.data());</div>
<div class="line">    <span class="comment">// Do something with the &#39;current&#39; pointer.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code><a class="el" href="classtatami_1_1DenseExtractor.html#a809f1682a0ba66035066175e37bb0e83">tatami::DenseExtractor::fetch()</a></code> method returns a pointer to an array of length equal to the number of columns that contains each row's contents. In some matrix representations (e.g., <code>DenseMatrix</code>), the returned pointer directly refers to the matrix's internal data store. However, this is not the case in general so we need to allocate a buffer of appropriate length (<code>buffer</code>) in which the dense contents can be stored; if this buffer is used, the returned pointer refers to the buffer start. Users can also use <code><a class="el" href="classtatami_1_1DenseExtractor.html#a67bd8c1e45a792c99014e1ea625fa13f">tatami::DenseExtractor::fetch_copy()</a></code> if they want to force a copy of the row contents into the buffer, regardless of the representation.</p>
<p>Alternatively, we could extract sparse columns via <code><a class="el" href="classtatami_1_1SparseExtractor.html#a721c2b7e0bf9958e122570dea88bb41c">tatami::SparseExtractor::fetch()</a></code>, which returns a <code><a class="el" href="structtatami_1_1SparseRange.html" title="A range of a sparse vector.">tatami::SparseRange</a></code> containing pointers to arrays of (structurally non-zero) values and their row indices. This provides some opportunities for optimization in algorithms that only need to operate on non-zero values. The <code>fetch()</code> call requires buffers for both arrays - again, this may not be used for matrix subclasses with contiguous internal storage of the values/indices.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> sext = mat-&gt;sparse_column();</div>
<div class="line">std::vector&lt;double&gt; vbuffer(NR);</div>
<div class="line">std::vector&lt;int&gt; ibuffer(NR);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> c = 0; c &lt; NC; ++c) {</div>
<div class="line">    <span class="keyword">auto</span> current = sext-&gt;fetch(c, vbuffer.data(), ibuffer.data());</div>
<div class="line">    current.number; <span class="comment">// Number of structural non-zeros</span></div>
<div class="line">    current.value; <span class="comment">// Pointer to the value array</span></div>
<div class="line">    current.index; <span class="comment">// Pointer to the index array</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>In both the dense and sparse cases, we can restrict the values that are extracted by <code>fetch()</code>. This provides some opportunities for optimization by avoiding the unnecessary extraction of uninteresting data. To do so, we define a range of elements or supply a vector containing the indices of the elements of interest during <code>Extractor</code> construction:</p>
<div class="fragment"><div class="line"><span class="comment">// Get rows [5, 17) from each column.</span></div>
<div class="line"><span class="keyword">auto</span> bext = mat-&gt;dense_column(5, 12); </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get these columns from each row.</span></div>
<div class="line"><span class="keyword">auto</span> iext = mat-&gt;sparse_row(std::vector&lt;int&gt;{ 1, 3, 5, 7 });</div>
</div><!-- fragment --><h2>Handling different access patterns</h2>
<p>In performance-critical sections, it may be desirable to customize the extraction based on properties of the matrix. This is supported with the following methods:</p>
<ul>
<li><code><a class="el" href="classtatami_1_1Matrix.html#a9de24a05a6aee62d4ba59799a73242e7">tatami::Matrix::sparse()</a></code> indicates whether a matrix is sparse.</li>
<li><code><a class="el" href="classtatami_1_1Matrix.html#a69382d2a4e66cda1a9eb48dc25ab113a">tatami::Matrix::prefer_rows()</a></code> indicates whether a matrix is more efficiently accessed along its rows (e.g., row-major dense matrices).</li>
</ul>
<p>Users can then write dedicated code paths to take advantage of these properties. For example, we might use different algorithms for dense data, where we don't have to look up indices; and for sparse data, if we can avoid the uninteresting zero values. Similarly, if we want to compute a row-wise statistic, but the matrix is more efficiently accessed by column according to <code>prefer_rows()</code>, we could iterate on the columns and attempt to compute the statistic in a "running" manner (see <a href="gallery/src/colsums.cpp"><code>colsums.cpp</code></a> for an example). In the most complex cases, this leads to code like:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (mat-&gt;sparse()) {</div>
<div class="line">    <span class="keywordflow">if</span> (mat-&gt;prefer_rows()) {</div>
<div class="line">        <span class="keyword">auto</span> sext = mat-&gt;sparse_row();</div>
<div class="line">        <span class="comment">// Do compute along sparse rows.</span></div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keyword">auto</span> sext = mat-&gt;sparse_column();</div>
<div class="line">        <span class="comment">// Do compute along sparse columns.</span></div>
<div class="line">    }</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="keywordflow">if</span> (mat-&gt;prefer_rows()) {</div>
<div class="line">        <span class="keyword">auto</span> sext = mat-&gt;dense_row();</div>
<div class="line">        <span class="comment">// Do compute along dense rows.</span></div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keyword">auto</span> sext = mat-&gt;dense_column();</div>
<div class="line">        <span class="comment">// Do compute along dense columns.</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Of course, this assumes that it is possible to provide sparse-specific optimizations as well as running calculations for the statistic of interest. In most cases, only a subset of the extraction patterns are actually feasible so special code paths would not be beneficial.</p>
<h2>Supporting parallelization</h2>
<p>The mutable nature of an <code>Extractor</code> instance means that the <code>fetch()</code> calls themselves are not <code>const</code>. This means that the same extractor cannot be safely re-used across different threads as each call to <code>fetch()</code> will modify the extractor's contents. Fortunately, the solution is simple - just create a separate <code>Extractor</code> (and the associated buffers) for each thread. With OpenMP, this looks like:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#pragma omp parallel num_threads(nthreads);</span></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> wrk = mat-&gt;dense_row();</div>
<div class="line">    std::vector&lt;double&gt; buffer(NC);</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">    #pragma omp for</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r = 0; r &lt; NR; ++r) {</div>
<div class="line">        <span class="keyword">auto</span> ptr = wrk-&gt;fetch(r, buffer.data());</div>
<div class="line">        <span class="comment">// Do something in each thread.</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Users may also consider using the <code><a class="el" href="namespacetatami.html#a29ce7a2219ea60d45de1aa3d4de66063">tatami::parallelize()</a></code> function, which accepts a function with the range of jobs (in this case, rows) to be processed in each thread. This responds to the <code>TATAMI_CUSTOM_PARALLEL</code> macro, which allows applications to easily change their parallelization scheme. For example, if a toolchain does not support OpenMP, an application can set the macro to switch to <code>&lt;thread&gt;</code> instead.</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="namespacetatami.html#a29ce7a2219ea60d45de1aa3d4de66063">tatami::parallelize</a>([&amp;](<span class="keywordtype">int</span> thread, <span class="keywordtype">int</span> start, <span class="keywordtype">int</span> length) -&gt; <span class="keywordtype">void</span> {</div>
<div class="line">    <span class="keyword">auto</span> wrk = mat-&gt;dense_row();</div>
<div class="line">    std::vector&lt;double&gt; buffer(NC);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r = 0; r &lt; length; ++r) {</div>
<div class="line">        <span class="keyword">auto</span> ptr = wrk-&gt;fetch(r + start, buffer.data());</div>
<div class="line">        <span class="comment">// Do something in each thread.</span></div>
<div class="line">    }</div>
<div class="line">}, NR, nthreads);</div>
<div class="ttc" id="anamespacetatami_html_a29ce7a2219ea60d45de1aa3d4de66063"><div class="ttname"><a href="namespacetatami.html#a29ce7a2219ea60d45de1aa3d4de66063">tatami::parallelize</a></div><div class="ttdeci">void parallelize(Function_ fun, size_t tasks, size_t threads)</div><div class="ttdef"><b>Definition</b> utils.hpp:36</div></div>
</div><!-- fragment --><h2>Defining an oracle</h2>
<p>Advanced users can provide each <code>Extractor</code> with an <code>Oracle</code> that specifies the rows/columns to be accessed by future calls to <code>fetch()</code>. Knowledge of the future access pattern enables optimizations in some <code>Matrix</code> implementations, e.g., file-backed matrices can reduce the number of disk reads by pre-fetching the right data for future accesses. The most obvious use case involves accessing consecutive rows/columns:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> wrk = mat-&gt;dense_row();</div>
<div class="line">wrk-&gt;set_oracle(std::make_unique&lt;ConsecutiveOracle&lt;int&gt; &gt;(0, NR));</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> r = 0; r &lt; NR; ++r) {</div>
<div class="line">    <span class="keyword">auto</span> ptr = wrk-&gt;fetch(r, buffer.data());</div>
<div class="line">}</div>
</div><!-- fragment --><p>In fact, this use case is so common that we can just use the <code><a class="el" href="namespacetatami.html#a36c6ecf33bcb87e1ed33c0a7d744dd82">tatami::consecutive_extractor()</a></code> wrapper to set the oracle. The first template boolean specifies whether we want row access, the second boolean specifies whether we want sparse extraction, and the numbers specify the start and length of the sequence of consecutive elements.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> cwrk = tatami::consecutive_extractor&lt;true, false&gt;(mat.get(), 0, NR);</div>
</div><!-- fragment --><p>Alternatively, we can use the <code>FixedOracle</code> class with an array of row/column indices that are known ahead of time. Advanced users can also define their own <code>Oracle</code> subclasses to provide dynamic custom predictions, e.g., based on PRNG output.</p>
<p>In all cases where an oracle is supplied, the subsequent <code>fetch()</code> calls should exactly match the predictions returned by the oracle. Failing to do so will result in undefined behavior.</p>
<h1>Comments on other operations</h1>
<p>As previously mentioned, <b>tatami</b> is designed to pull out rows or columns of a matrix, and little else. Some support is provided for basic statistics in the same vein as the <a href="https://github.com/HenrikBengtsson/matrixStats"><b>matrixStats</b></a> package:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> colsums = <a class="code hl_function" href="namespacetatami.html#a3aab6733d637b66abdf45f7300d2e1ba">tatami::column_sums</a>(mat.get());</div>
<div class="line"><span class="keyword">auto</span> rowvars = <a class="code hl_function" href="namespacetatami.html#ab806279616e19f6150376a7c07d5b64b">tatami::row_variances</a>(mat.get());</div>
<div class="ttc" id="anamespacetatami_html_a3aab6733d637b66abdf45f7300d2e1ba"><div class="ttname"><a href="namespacetatami.html#a3aab6733d637b66abdf45f7300d2e1ba">tatami::column_sums</a></div><div class="ttdeci">std::vector&lt; Output_ &gt; column_sums(const Matrix&lt; Value_, Index_ &gt; *p, int threads=1)</div><div class="ttdef"><b>Definition</b> sums.hpp:102</div></div>
<div class="ttc" id="anamespacetatami_html_ab806279616e19f6150376a7c07d5b64b"><div class="ttname"><a href="namespacetatami.html#ab806279616e19f6150376a7c07d5b64b">tatami::row_variances</a></div><div class="ttdeci">std::vector&lt; Output_ &gt; row_variances(const Matrix&lt; Value_, Index_ &gt; *p, int threads=1)</div><div class="ttdef"><b>Definition</b> variances.hpp:343</div></div>
</div><!-- fragment --><p><b>tatami</b> is strictly intended for row/column access and does not directly support matrix algebra or decompositions. If these high-level operations are needed, applications should write their own code, e.g., by using <b>tatami</b>'s extractors to implement matrix multiplication. Alternatively, we can transfer data from <b>tatami</b> into other frameworks like <a href="https://eigen.tuxfamily.org/"><b>Eigen</b></a> for complex matrix operations, effectively trading the diversity of representations for a more comprehensive suite of operations. For example, we like to use <b>tatami</b> to load the input data, which is usually in a custom format to save memory for large datasets; process it into a much smaller submatrix, e.g., by selecting features of interest in a genome-scale analysis; and then copy this cheaply into an <code>Eigen::MatrixXd</code> or <code>Eigen::SparseMatrix</code> for more computationally intensive work.</p>
<p>It is not possible to modify the matrix contents via the <b>tatami</b> API. This is especially relevant for matrices with delayed operations or those referring to remote data stores, where reading the matrix data is trivial but writing is not guaranteed to work. Experience suggests that a matrix writer abstraction is less useful than the equivalent reader abstraction. This is because applications typically control the output format, so there is no need to accommodate a diversity of formats via an abstract interface.</p>
<h1>Building projects</h1>
<p>If you're using CMake, you just need to add something like this to your <code>CMakeLists.txt</code>:</p>
<div class="fragment"><div class="line">include(FetchContent)</div>
<div class="line"> </div>
<div class="line">FetchContent_Declare(</div>
<div class="line">  tatami</div>
<div class="line">  GIT_REPOSITORY https://github.com/tatami-inc/tatami</div>
<div class="line">  GIT_TAG master # or any version of interest </div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">FetchContent_MakeAvailable(tatami)</div>
</div><!-- fragment --><p>Then you can link to <b>tatami</b> to make the headers available during compilation:</p>
<div class="fragment"><div class="line"># For executables:</div>
<div class="line">target_link_libraries(myexe tatami)</div>
<div class="line"> </div>
<div class="line"># For libaries</div>
<div class="line">target_link_libraries(mylib INTERFACE tatami)</div>
</div><!-- fragment --><p>If you're not using CMake, the simple approach is to just copy the files - either directly or with Git submodules - and include their path during compilation with, e.g., GCC's <code>-I</code>. If you want to read Matrix Market files, you'll also need to add the <a href="https://github.com/clusterfork/byteme"><b>byteme</b></a> header-only library to the compiler's search path.</p>
<h1>Links</h1>
<p>Check out the <a href="https://tatami-inc.github.io/tatami">reference documentation</a> for more details on each function and class.</p>
<p>The <a href="gallery/">gallery</a> also contains worked examples for common operations based on row/column traversals.</p>
<p>The <a href="https://github.com/tatami-inc/tatami_hdf5"><b>tatami_hdf5</b></a> repository contains <b>tatami</b> bindings for HDF5-backed matrices.</p>
<p>The <a href="https://github.com/tatami-inc/tatami_r"><b>tatami_r</b></a> repository contains <b>tatami</b> bindings for matrix-like objects in R.</p>
<p>The <a href="https://github.com/tatami-inc/beachmat"><b>beachmat</b></a> package vendors the <b>tatami</b> headers for easy use by other R packages. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
