<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tatami: tatami::Matrix&lt; T, IDX &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tatami
   </div>
   <div id="projectbrief">C++ API for different matrix representations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetatami.html">tatami</a></li><li class="navelem"><a class="el" href="classtatami_1_1Matrix.html">Matrix</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classtatami_1_1Matrix-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">tatami::Matrix&lt; T, IDX &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Virtual class for a matrix with a defined type.  
 <a href="classtatami_1_1Matrix.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Matrix_8hpp_source.html">Matrix.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for tatami::Matrix&lt; T, IDX &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classtatami_1_1Matrix__inherit__graph.png" border="0" usemap="#atatami_1_1Matrix_3_01T_00_01IDX_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="atatami_1_1Matrix_3_01T_00_01IDX_01_4_inherit__map" id="atatami_1_1Matrix_3_01T_00_01IDX_01_4_inherit__map">
<area shape="rect" title="Virtual class for a matrix with a defined type." alt="" coords="5,77,128,117"/>
<area shape="rect" href="classtatami_1_1VirtualDenseMatrix.html" title=" " alt="" coords="179,5,352,45"/>
<area shape="rect" href="classtatami_1_1CompressedSparseMatrix.html" title="Compressed sparse matrix representation." alt="" coords="176,70,355,125"/>
<area shape="rect" href="classtatami_1_1VirtualDenseMatrix.html" title="Virtual class for a dense matrix with a defined type." alt="" coords="179,149,352,189"/>
<area shape="rect" href="classtatami_1_1DenseMatrix.html" title="Dense matrix representation." alt="" coords="403,149,539,189"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8f97683e1dbef330caadc258b0c404b5"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a8f97683e1dbef330caadc258b0c404b5">data_type</a></td></tr>
<tr class="separator:a8f97683e1dbef330caadc258b0c404b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b8f1870fe7f6c40fa5426f11ff82f4"><td class="memItemLeft" align="right" valign="top">typedef IDX&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a09b8f1870fe7f6c40fa5426f11ff82f4">index_type</a></td></tr>
<tr class="separator:a09b8f1870fe7f6c40fa5426f11ff82f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6d505c205ae7ff6fb225450fca5f4307"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a6d505c205ae7ff6fb225450fca5f4307">Matrix</a> (<a class="el" href="classtatami_1_1Matrix.html">Matrix</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a6d505c205ae7ff6fb225450fca5f4307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a3bbc3ba8681438f51a48f5f40b42a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1Matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a54a3bbc3ba8681438f51a48f5f40b42a">operator=</a> (<a class="el" href="classtatami_1_1Matrix.html">Matrix</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a54a3bbc3ba8681438f51a48f5f40b42a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d8e8cfd07b96e1a604cdccd3a8efaf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#ac7d8e8cfd07b96e1a604cdccd3a8efaf">Matrix</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a> &amp;)=default</td></tr>
<tr class="separator:ac7d8e8cfd07b96e1a604cdccd3a8efaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9913765cad84cb6d43271ee213a9d019"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1Matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a9913765cad84cb6d43271ee213a9d019">operator=</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a> &amp;)=default</td></tr>
<tr class="separator:a9913765cad84cb6d43271ee213a9d019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e1342556ff97cc8367b25d244195a9"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a48e1342556ff97cc8367b25d244195a9">nrow</a> () const =0</td></tr>
<tr class="separator:a48e1342556ff97cc8367b25d244195a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1049bd5cbe37b618db795787725930e4"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a1049bd5cbe37b618db795787725930e4">ncol</a> () const =0</td></tr>
<tr class="separator:a1049bd5cbe37b618db795787725930e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9017848eb07fd4e6337dcd384d7f7df"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#ad9017848eb07fd4e6337dcd384d7f7df">sparse</a> () const =0</td></tr>
<tr class="separator:ad9017848eb07fd4e6337dcd384d7f7df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc7c2e5f408a096f92163d3c031f113"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a6fc7c2e5f408a096f92163d3c031f113">prefer_rows</a> () const =0</td></tr>
<tr class="separator:a6fc7c2e5f408a096f92163d3c031f113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0c04c5b051451af78a64e517aae0c1"><td class="memItemLeft" align="right" valign="top">virtual std::pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a8e0c04c5b051451af78a64e517aae0c1">dimension_preference</a> () const</td></tr>
<tr class="separator:a8e0c04c5b051451af78a64e517aae0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935242c6a441cd71ad82f9965ed7e018"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a3e4e7d9c0a3103fe35d6b6b2d5c8167e">DenseRowWorkspace</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a935242c6a441cd71ad82f9965ed7e018">dense_row_workspace</a> (const <a class="el" href="structtatami_1_1WorkspaceOptions.html">WorkspaceOptions</a> &amp;options) const =0</td></tr>
<tr class="separator:a935242c6a441cd71ad82f9965ed7e018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad095a4dabf76686f7105b35215ee6ed4"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a0f817935c6e352d908090a67aff91f2a">DenseColumnWorkspace</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#ad095a4dabf76686f7105b35215ee6ed4">dense_column_workspace</a> (const <a class="el" href="structtatami_1_1WorkspaceOptions.html">WorkspaceOptions</a> &amp;options) const =0</td></tr>
<tr class="separator:ad095a4dabf76686f7105b35215ee6ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb01b715c9918114ba658d279f0c9306"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a94ca69af3e36f805e53326d4f8fc7cba">SparseRowWorkspace</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#abb01b715c9918114ba658d279f0c9306">sparse_row_workspace</a> (const <a class="el" href="structtatami_1_1WorkspaceOptions.html">WorkspaceOptions</a> &amp;options) const =0</td></tr>
<tr class="separator:abb01b715c9918114ba658d279f0c9306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c50f28ce9ca0edc27a4647b6c595b21"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a4182e7ceb1cab3083cfec53b9dc5d561">SparseColumnWorkspace</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a2c50f28ce9ca0edc27a4647b6c595b21">sparse_column_workspace</a> (const <a class="el" href="structtatami_1_1WorkspaceOptions.html">WorkspaceOptions</a> &amp;options) const =0</td></tr>
<tr class="separator:a2c50f28ce9ca0edc27a4647b6c595b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96ddb276e8b641b71d2659098235ad5"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a77143ea2ebbc50e952b51d640376b008">DenseRowBlockWorkspace</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#af96ddb276e8b641b71d2659098235ad5">dense_row_workspace</a> (size_t start, size_t length, const <a class="el" href="structtatami_1_1WorkspaceOptions.html">WorkspaceOptions</a> &amp;options) const =0</td></tr>
<tr class="separator:af96ddb276e8b641b71d2659098235ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a14f0d46805b214bf93c2b89cacaed9"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="namespacetatami.html#aba03c94d01da4c440f052d704e14cdbe">DenseColumnBlockWorkspace</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a3a14f0d46805b214bf93c2b89cacaed9">dense_column_workspace</a> (size_t start, size_t length, const <a class="el" href="structtatami_1_1WorkspaceOptions.html">WorkspaceOptions</a> &amp;options) const =0</td></tr>
<tr class="separator:a3a14f0d46805b214bf93c2b89cacaed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810044d32984857de1d571f120fe97df"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a1798a0b6bf7822a590baee156371c352">SparseRowBlockWorkspace</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a810044d32984857de1d571f120fe97df">sparse_row_workspace</a> (size_t start, size_t length, const <a class="el" href="structtatami_1_1WorkspaceOptions.html">WorkspaceOptions</a> &amp;options) const =0</td></tr>
<tr class="separator:a810044d32984857de1d571f120fe97df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99694353e05bc2d8fe40735b96d9d898"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="namespacetatami.html#ac85be5029bb03a836b329b566c4d89c2">SparseColumnBlockWorkspace</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a99694353e05bc2d8fe40735b96d9d898">sparse_column_workspace</a> (size_t start, size_t length, const <a class="el" href="structtatami_1_1WorkspaceOptions.html">WorkspaceOptions</a> &amp;options) const =0</td></tr>
<tr class="separator:a99694353e05bc2d8fe40735b96d9d898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec95f144f7287a375dfb301974c7d50"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a422993ac842bf906000d6ccebd0c86e6">DenseRowIndexWorkspace</a>&lt; IDX &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#acec95f144f7287a375dfb301974c7d50">dense_row_workspace</a> (std::vector&lt; IDX &gt; indices, const <a class="el" href="structtatami_1_1WorkspaceOptions.html">WorkspaceOptions</a> &amp;options) const =0</td></tr>
<tr class="separator:acec95f144f7287a375dfb301974c7d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2910e520ecd969329a43f9ac9a5598bd"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a0029d39a6fa9fe81a5c85cdf744ebd68">DenseColumnIndexWorkspace</a>&lt; IDX &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a2910e520ecd969329a43f9ac9a5598bd">dense_column_workspace</a> (std::vector&lt; IDX &gt; indices, const <a class="el" href="structtatami_1_1WorkspaceOptions.html">WorkspaceOptions</a> &amp;options) const =0</td></tr>
<tr class="separator:a2910e520ecd969329a43f9ac9a5598bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a2c1606b0b9c0c47c964d4c07fbcd4d"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a1edbb6992ee134f2481b6227300322ce">SparseRowIndexWorkspace</a>&lt; IDX &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a7a2c1606b0b9c0c47c964d4c07fbcd4d">sparse_row_workspace</a> (std::vector&lt; IDX &gt; indices, const <a class="el" href="structtatami_1_1WorkspaceOptions.html">WorkspaceOptions</a> &amp;options) const =0</td></tr>
<tr class="separator:a7a2c1606b0b9c0c47c964d4c07fbcd4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7bb36282f467911ff2573bb96d465b"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a54ba456fea7d955f10d55792cbcc7a58">SparseColumnIndexWorkspace</a>&lt; IDX &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a6d7bb36282f467911ff2573bb96d465b">sparse_column_workspace</a> (std::vector&lt; IDX &gt; indices, const <a class="el" href="structtatami_1_1WorkspaceOptions.html">WorkspaceOptions</a> &amp;options) const =0</td></tr>
<tr class="separator:a6d7bb36282f467911ff2573bb96d465b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675bf1ddd56c6eaf24b1100fdf7122a0"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a3e4e7d9c0a3103fe35d6b6b2d5c8167e">DenseRowWorkspace</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a675bf1ddd56c6eaf24b1100fdf7122a0">dense_row_workspace</a> () const</td></tr>
<tr class="separator:a675bf1ddd56c6eaf24b1100fdf7122a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293cc62cc8a39e4ed66ab99e33cbcf27"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a0f817935c6e352d908090a67aff91f2a">DenseColumnWorkspace</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a293cc62cc8a39e4ed66ab99e33cbcf27">dense_column_workspace</a> () const</td></tr>
<tr class="separator:a293cc62cc8a39e4ed66ab99e33cbcf27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4db842e8742bb6eb9d3456ad9628b2"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a94ca69af3e36f805e53326d4f8fc7cba">SparseRowWorkspace</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a4a4db842e8742bb6eb9d3456ad9628b2">sparse_row_workspace</a> () const</td></tr>
<tr class="separator:a4a4db842e8742bb6eb9d3456ad9628b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a1dd4ef8814f3e748dc6bc9d7c6828"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a4182e7ceb1cab3083cfec53b9dc5d561">SparseColumnWorkspace</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#ae8a1dd4ef8814f3e748dc6bc9d7c6828">sparse_column_workspace</a> () const</td></tr>
<tr class="separator:ae8a1dd4ef8814f3e748dc6bc9d7c6828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15773037446a0221ff0e5a5bf5d4299c"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a77143ea2ebbc50e952b51d640376b008">DenseRowBlockWorkspace</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a15773037446a0221ff0e5a5bf5d4299c">dense_row_workspace</a> (size_t start, size_t length) const</td></tr>
<tr class="separator:a15773037446a0221ff0e5a5bf5d4299c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134a0216419196e100c542f37550ca13"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#aba03c94d01da4c440f052d704e14cdbe">DenseColumnBlockWorkspace</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a134a0216419196e100c542f37550ca13">dense_column_workspace</a> (size_t start, size_t length) const</td></tr>
<tr class="separator:a134a0216419196e100c542f37550ca13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5784d1baf88d06c4b9999ce60dc5b14"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a1798a0b6bf7822a590baee156371c352">SparseRowBlockWorkspace</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#ad5784d1baf88d06c4b9999ce60dc5b14">sparse_row_workspace</a> (size_t start, size_t length) const</td></tr>
<tr class="separator:ad5784d1baf88d06c4b9999ce60dc5b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6950a659cb100964829e9a7ba094796"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#ac85be5029bb03a836b329b566c4d89c2">SparseColumnBlockWorkspace</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#aa6950a659cb100964829e9a7ba094796">sparse_column_workspace</a> (size_t start, size_t length) const</td></tr>
<tr class="separator:aa6950a659cb100964829e9a7ba094796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6cad51f94ab35c4751ae731b1891da6"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a422993ac842bf906000d6ccebd0c86e6">DenseRowIndexWorkspace</a>&lt; IDX &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#ab6cad51f94ab35c4751ae731b1891da6">dense_row_workspace</a> (std::vector&lt; IDX &gt; indices) const</td></tr>
<tr class="separator:ab6cad51f94ab35c4751ae731b1891da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479dcb29b421a743d31a82fe3991d941"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a0029d39a6fa9fe81a5c85cdf744ebd68">DenseColumnIndexWorkspace</a>&lt; IDX &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a479dcb29b421a743d31a82fe3991d941">dense_column_workspace</a> (std::vector&lt; IDX &gt; indices) const</td></tr>
<tr class="separator:a479dcb29b421a743d31a82fe3991d941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ada5a449ab883b911b420d7ed53c9c8"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a1edbb6992ee134f2481b6227300322ce">SparseRowIndexWorkspace</a>&lt; IDX &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a4ada5a449ab883b911b420d7ed53c9c8">sparse_row_workspace</a> (std::vector&lt; IDX &gt; indices) const</td></tr>
<tr class="separator:a4ada5a449ab883b911b420d7ed53c9c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a5563529059a6db56968b8b15558c58"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a54ba456fea7d955f10d55792cbcc7a58">SparseColumnIndexWorkspace</a>&lt; IDX &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a1a5563529059a6db56968b8b15558c58">sparse_column_workspace</a> (std::vector&lt; IDX &gt; indices) const</td></tr>
<tr class="separator:a1a5563529059a6db56968b8b15558c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d3893b5a47b532d30db6780febdeff"><td class="memItemLeft" align="right" valign="top">virtual const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a34d3893b5a47b532d30db6780febdeff">row</a> (size_t r, T *buffer, <a class="el" href="namespacetatami.html#a3e4e7d9c0a3103fe35d6b6b2d5c8167e">DenseRowWorkspace</a> *work) const =0</td></tr>
<tr class="separator:a34d3893b5a47b532d30db6780febdeff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2c72ccd1628c96c40c601e6ceda654"><td class="memItemLeft" align="right" valign="top">virtual const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#ada2c72ccd1628c96c40c601e6ceda654">column</a> (size_t c, T *buffer, <a class="el" href="namespacetatami.html#a0f817935c6e352d908090a67aff91f2a">DenseColumnWorkspace</a> *work) const =0</td></tr>
<tr class="separator:ada2c72ccd1628c96c40c601e6ceda654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2165df9ff4cb9afcc61992e888f7b33"><td class="memItemLeft" align="right" valign="top">virtual const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#ac2165df9ff4cb9afcc61992e888f7b33">row</a> (size_t r, T *buffer, <a class="el" href="namespacetatami.html#a77143ea2ebbc50e952b51d640376b008">DenseRowBlockWorkspace</a> *work) const =0</td></tr>
<tr class="separator:ac2165df9ff4cb9afcc61992e888f7b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee2bfcd96c64ecc4fb1c6682b2527aae"><td class="memItemLeft" align="right" valign="top">virtual const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#aee2bfcd96c64ecc4fb1c6682b2527aae">column</a> (size_t c, T *buffer, <a class="el" href="namespacetatami.html#aba03c94d01da4c440f052d704e14cdbe">DenseColumnBlockWorkspace</a> *work) const =0</td></tr>
<tr class="separator:aee2bfcd96c64ecc4fb1c6682b2527aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e22a1534c0549a2bf5ac818d5a9c1cb"><td class="memItemLeft" align="right" valign="top">virtual const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a0e22a1534c0549a2bf5ac818d5a9c1cb">row</a> (size_t r, T *buffer, <a class="el" href="namespacetatami.html#a422993ac842bf906000d6ccebd0c86e6">DenseRowIndexWorkspace</a>&lt; IDX &gt; *work) const =0</td></tr>
<tr class="separator:a0e22a1534c0549a2bf5ac818d5a9c1cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f503f54c5ebbfdcfb7c313a405f08ac"><td class="memItemLeft" align="right" valign="top">virtual const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a1f503f54c5ebbfdcfb7c313a405f08ac">column</a> (size_t c, T *buffer, <a class="el" href="namespacetatami.html#a0029d39a6fa9fe81a5c85cdf744ebd68">DenseColumnIndexWorkspace</a>&lt; IDX &gt; *work) const =0</td></tr>
<tr class="separator:a1f503f54c5ebbfdcfb7c313a405f08ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2197ca3d05f70127f22de31a645c0ba4"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a2197ca3d05f70127f22de31a645c0ba4">row_copy</a> (size_t r, T *buffer, <a class="el" href="namespacetatami.html#a3e4e7d9c0a3103fe35d6b6b2d5c8167e">DenseRowWorkspace</a> *work) const</td></tr>
<tr class="separator:a2197ca3d05f70127f22de31a645c0ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2682f1537920f6b4db653583ecb38e45"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a2682f1537920f6b4db653583ecb38e45">column_copy</a> (size_t c, T *buffer, <a class="el" href="namespacetatami.html#a0f817935c6e352d908090a67aff91f2a">DenseColumnWorkspace</a> *work) const</td></tr>
<tr class="separator:a2682f1537920f6b4db653583ecb38e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba093df5c7add38c7a65cd0156d3c45"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a7ba093df5c7add38c7a65cd0156d3c45">row_copy</a> (size_t r, T *buffer, <a class="el" href="namespacetatami.html#a77143ea2ebbc50e952b51d640376b008">DenseRowBlockWorkspace</a> *work) const</td></tr>
<tr class="separator:a7ba093df5c7add38c7a65cd0156d3c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2a5e069a31348059ac9b2ee51a6378"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a0f2a5e069a31348059ac9b2ee51a6378">column_copy</a> (size_t c, T *buffer, <a class="el" href="namespacetatami.html#aba03c94d01da4c440f052d704e14cdbe">DenseColumnBlockWorkspace</a> *work) const</td></tr>
<tr class="separator:a0f2a5e069a31348059ac9b2ee51a6378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdcac115721408d4b7991d7e60942028"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#abdcac115721408d4b7991d7e60942028">row_copy</a> (size_t r, T *buffer, <a class="el" href="namespacetatami.html#a422993ac842bf906000d6ccebd0c86e6">DenseRowIndexWorkspace</a>&lt; IDX &gt; *work) const</td></tr>
<tr class="separator:abdcac115721408d4b7991d7e60942028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf8daacc683494db58d2f7ba9f57afd6"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#abf8daacc683494db58d2f7ba9f57afd6">column_copy</a> (size_t c, T *buffer, <a class="el" href="namespacetatami.html#a0029d39a6fa9fe81a5c85cdf744ebd68">DenseColumnIndexWorkspace</a>&lt; IDX &gt; *work) const</td></tr>
<tr class="separator:abf8daacc683494db58d2f7ba9f57afd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45374d30647b638e8901e25be6cf84d2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a45374d30647b638e8901e25be6cf84d2">row</a> (size_t r, <a class="el" href="namespacetatami.html#a3e4e7d9c0a3103fe35d6b6b2d5c8167e">DenseRowWorkspace</a> *work) const</td></tr>
<tr class="separator:a45374d30647b638e8901e25be6cf84d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace200adc8b1c4237f3c734551ef046dc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#ace200adc8b1c4237f3c734551ef046dc">column</a> (size_t c, <a class="el" href="namespacetatami.html#a0f817935c6e352d908090a67aff91f2a">DenseColumnWorkspace</a> *work) const</td></tr>
<tr class="separator:ace200adc8b1c4237f3c734551ef046dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d914be30f58811a241e1e5873ca88b8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a5d914be30f58811a241e1e5873ca88b8">row</a> (size_t r, <a class="el" href="namespacetatami.html#a77143ea2ebbc50e952b51d640376b008">DenseRowBlockWorkspace</a> *work) const</td></tr>
<tr class="separator:a5d914be30f58811a241e1e5873ca88b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27b9c0d027c50e52ad3da0c2c23ad2c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#af27b9c0d027c50e52ad3da0c2c23ad2c">column</a> (size_t c, <a class="el" href="namespacetatami.html#aba03c94d01da4c440f052d704e14cdbe">DenseColumnBlockWorkspace</a> *work) const</td></tr>
<tr class="separator:af27b9c0d027c50e52ad3da0c2c23ad2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c54c0dd2a96ff1c25fba8665d73c38"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a21c54c0dd2a96ff1c25fba8665d73c38">row</a> (size_t r, <a class="el" href="namespacetatami.html#a422993ac842bf906000d6ccebd0c86e6">DenseRowIndexWorkspace</a>&lt; IDX &gt; *work) const</td></tr>
<tr class="separator:a21c54c0dd2a96ff1c25fba8665d73c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7633048ba93256affc03084e2da6f063"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a7633048ba93256affc03084e2da6f063">column</a> (size_t c, <a class="el" href="namespacetatami.html#a0029d39a6fa9fe81a5c85cdf744ebd68">DenseColumnIndexWorkspace</a>&lt; IDX &gt; *work) const</td></tr>
<tr class="separator:a7633048ba93256affc03084e2da6f063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd5de94d342cf00f520a75e44f1112f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a7bd5de94d342cf00f520a75e44f1112f">row</a> (size_t r, T *vbuffer, IDX *ibuffer, <a class="el" href="namespacetatami.html#a94ca69af3e36f805e53326d4f8fc7cba">SparseRowWorkspace</a> *work) const =0</td></tr>
<tr class="separator:a7bd5de94d342cf00f520a75e44f1112f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a809134c6013d89008a5cdc0e2f153fe8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a809134c6013d89008a5cdc0e2f153fe8">column</a> (size_t c, T *vbuffer, IDX *ibuffer, <a class="el" href="namespacetatami.html#a4182e7ceb1cab3083cfec53b9dc5d561">SparseColumnWorkspace</a> *work) const =0</td></tr>
<tr class="separator:a809134c6013d89008a5cdc0e2f153fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17ffa61ac22a28ba583739c32a73a56"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#aa17ffa61ac22a28ba583739c32a73a56">row</a> (size_t r, T *vbuffer, IDX *ibuffer, <a class="el" href="namespacetatami.html#a1798a0b6bf7822a590baee156371c352">SparseRowBlockWorkspace</a> *work) const =0</td></tr>
<tr class="separator:aa17ffa61ac22a28ba583739c32a73a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd7375e9b578e2369b335b5cd70875e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a8bd7375e9b578e2369b335b5cd70875e">column</a> (size_t c, T *vbuffer, IDX *ibuffer, <a class="el" href="namespacetatami.html#ac85be5029bb03a836b329b566c4d89c2">SparseColumnBlockWorkspace</a> *work) const =0</td></tr>
<tr class="separator:a8bd7375e9b578e2369b335b5cd70875e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4f5da8caf94a54cb94e2ff3e602ab6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a6e4f5da8caf94a54cb94e2ff3e602ab6">row</a> (size_t r, T *vbuffer, IDX *ibuffer, <a class="el" href="namespacetatami.html#a1edbb6992ee134f2481b6227300322ce">SparseRowIndexWorkspace</a>&lt; IDX &gt; *work) const =0</td></tr>
<tr class="separator:a6e4f5da8caf94a54cb94e2ff3e602ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57915eab83c7caafac71365c7b56a2a8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a57915eab83c7caafac71365c7b56a2a8">column</a> (size_t c, T *vbuffer, IDX *ibuffer, <a class="el" href="namespacetatami.html#a54ba456fea7d955f10d55792cbcc7a58">SparseColumnIndexWorkspace</a>&lt; IDX &gt; *work) const =0</td></tr>
<tr class="separator:a57915eab83c7caafac71365c7b56a2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64006bdf017d48760f4b1ac4e31bac87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a64006bdf017d48760f4b1ac4e31bac87">row_copy</a> (size_t r, T *vbuffer, IDX *ibuffer, <a class="el" href="namespacetatami.html#a94ca69af3e36f805e53326d4f8fc7cba">SparseRowWorkspace</a> *work) const</td></tr>
<tr class="separator:a64006bdf017d48760f4b1ac4e31bac87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51995cb3d6c2bbcface88087dd7f2e4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a51995cb3d6c2bbcface88087dd7f2e4a">column_copy</a> (size_t c, T *vbuffer, IDX *ibuffer, <a class="el" href="namespacetatami.html#a4182e7ceb1cab3083cfec53b9dc5d561">SparseColumnWorkspace</a> *work) const</td></tr>
<tr class="separator:a51995cb3d6c2bbcface88087dd7f2e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4202cc7b5662376311c683a799a34a6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a4202cc7b5662376311c683a799a34a6c">row_copy</a> (size_t r, T *vbuffer, IDX *ibuffer, <a class="el" href="namespacetatami.html#a1798a0b6bf7822a590baee156371c352">SparseRowBlockWorkspace</a> *work) const</td></tr>
<tr class="separator:a4202cc7b5662376311c683a799a34a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c1c4c8de56f48849cae9aea92df695"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#ae7c1c4c8de56f48849cae9aea92df695">column_copy</a> (size_t c, T *vbuffer, IDX *ibuffer, <a class="el" href="namespacetatami.html#ac85be5029bb03a836b329b566c4d89c2">SparseColumnBlockWorkspace</a> *work) const</td></tr>
<tr class="separator:ae7c1c4c8de56f48849cae9aea92df695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c50c971e2e058faff45de7681f82ded"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a3c50c971e2e058faff45de7681f82ded">row_copy</a> (size_t r, T *vbuffer, IDX *ibuffer, <a class="el" href="namespacetatami.html#a1edbb6992ee134f2481b6227300322ce">SparseRowIndexWorkspace</a>&lt; IDX &gt; *work) const</td></tr>
<tr class="separator:a3c50c971e2e058faff45de7681f82ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41742465767476b745f214080163b3f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a41742465767476b745f214080163b3f2">column_copy</a> (size_t c, T *vbuffer, IDX *ibuffer, <a class="el" href="namespacetatami.html#a54ba456fea7d955f10d55792cbcc7a58">SparseColumnIndexWorkspace</a>&lt; IDX &gt; *work) const</td></tr>
<tr class="separator:a41742465767476b745f214080163b3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a548e337fa5829bc8be7fb482992ca7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1SparseRangeCopy.html">SparseRangeCopy</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a5a548e337fa5829bc8be7fb482992ca7">row</a> (size_t r, <a class="el" href="namespacetatami.html#a94ca69af3e36f805e53326d4f8fc7cba">SparseRowWorkspace</a> *work) const</td></tr>
<tr class="separator:a5a548e337fa5829bc8be7fb482992ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa329d34be396ce9cca9077f47149d2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1SparseRangeCopy.html">SparseRangeCopy</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#aaa329d34be396ce9cca9077f47149d2a">column</a> (size_t c, <a class="el" href="namespacetatami.html#a4182e7ceb1cab3083cfec53b9dc5d561">SparseColumnWorkspace</a> *work) const</td></tr>
<tr class="separator:aaa329d34be396ce9cca9077f47149d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b3b7cd6f455fcdca738c1cc8b4755d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1SparseRangeCopy.html">SparseRangeCopy</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a68b3b7cd6f455fcdca738c1cc8b4755d">row</a> (size_t r, <a class="el" href="namespacetatami.html#a1798a0b6bf7822a590baee156371c352">SparseRowBlockWorkspace</a> *work) const</td></tr>
<tr class="separator:a68b3b7cd6f455fcdca738c1cc8b4755d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212303b5cdddfe60e7d5e882af126d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1SparseRangeCopy.html">SparseRangeCopy</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a2212303b5cdddfe60e7d5e882af126d8">column</a> (size_t c, <a class="el" href="namespacetatami.html#ac85be5029bb03a836b329b566c4d89c2">SparseColumnBlockWorkspace</a> *work) const</td></tr>
<tr class="separator:a2212303b5cdddfe60e7d5e882af126d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b182cbbed5a6fa81c0873078c6fa693"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1SparseRangeCopy.html">SparseRangeCopy</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a2b182cbbed5a6fa81c0873078c6fa693">row</a> (size_t r, <a class="el" href="namespacetatami.html#a1edbb6992ee134f2481b6227300322ce">SparseRowIndexWorkspace</a>&lt; IDX &gt; *work) const</td></tr>
<tr class="separator:a2b182cbbed5a6fa81c0873078c6fa693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d2cbfca03430d24be093142afd7cf6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1SparseRangeCopy.html">SparseRangeCopy</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a06d2cbfca03430d24be093142afd7cf6">column</a> (size_t c, <a class="el" href="namespacetatami.html#a54ba456fea7d955f10d55792cbcc7a58">SparseColumnIndexWorkspace</a>&lt; IDX &gt; *work) const</td></tr>
<tr class="separator:a06d2cbfca03430d24be093142afd7cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T, typename IDX = int&gt;<br />
class tatami::Matrix&lt; T, IDX &gt;</div><p>Virtual class for a matrix with a defined type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the matrix data. </td></tr>
    <tr><td class="paramname">IDX</td><td>Type of the row/column indices. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a8f97683e1dbef330caadc258b0c404b5" name="a8f97683e1dbef330caadc258b0c404b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f97683e1dbef330caadc258b0c404b5">&#9670;&#160;</a></span>data_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::data_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of data to be returned by getters. </p>

</div>
</div>
<a id="a09b8f1870fe7f6c40fa5426f11ff82f4" name="a09b8f1870fe7f6c40fa5426f11ff82f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09b8f1870fe7f6c40fa5426f11ff82f4">&#9670;&#160;</a></span>index_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef IDX <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::index_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of index to be returned by the sparse getters. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6d505c205ae7ff6fb225450fca5f4307" name="a6d505c205ae7ff6fb225450fca5f4307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d505c205ae7ff6fb225450fca5f4307">&#9670;&#160;</a></span>Matrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::Matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default move constructor. </p>

</div>
</div>
<a id="ac7d8e8cfd07b96e1a604cdccd3a8efaf" name="ac7d8e8cfd07b96e1a604cdccd3a8efaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7d8e8cfd07b96e1a604cdccd3a8efaf">&#9670;&#160;</a></span>Matrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::Matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default copy constructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a54a3bbc3ba8681438f51a48f5f40b42a" name="a54a3bbc3ba8681438f51a48f5f40b42a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54a3bbc3ba8681438f51a48f5f40b42a">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1Matrix.html">Matrix</a> &amp; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default move assignment operator. </p>

</div>
</div>
<a id="a9913765cad84cb6d43271ee213a9d019" name="a9913765cad84cb6d43271ee213a9d019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9913765cad84cb6d43271ee213a9d019">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1Matrix.html">Matrix</a> &amp; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default copy assignment operator. </p>

</div>
</div>
<a id="a48e1342556ff97cc8367b25d244195a9" name="a48e1342556ff97cc8367b25d244195a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48e1342556ff97cc8367b25d244195a9">&#9670;&#160;</a></span>nrow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::nrow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Number of rows. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a5c8cbee3334cbc3f860c1b328e254f7d">tatami::CompressedSparseMatrix&lt; ROW, T, IDX, U, V, W &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#aa09ce1f17542ea8b3d7fa52361e2471d">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#a9c1720ac920a7f8ccc32ad9773e15d5a">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#afff7ed215617739acaa9571b43df40db">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#afb9f6fb4d51c4741d1c7ae60dd068a26">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a8a036df3d67b81cb8b513343da4fd762">tatami::DenseMatrix&lt; ROW, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a0b1e46c7058a68bf99d22e1abbfae180">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#ac129143b74bc85931ecbc0171e1306e5">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a1f3a122828d9dfa4aaea94f738598730">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#ae29876550cb25afe75a705adf9da1cbf">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a18522b601bd6dc191dc1b06ffccb4a54">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#aeb402bffe0ca1dcee1921d7dcf3e1a39">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, and <a class="el" href="classtatami_1_1HDF5DenseMatrix.html#a07799029be780dbd14512a44aea27c56">tatami::HDF5DenseMatrix&lt; T, IDX, transpose &gt;</a>.</p>

</div>
</div>
<a id="a1049bd5cbe37b618db795787725930e4" name="a1049bd5cbe37b618db795787725930e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1049bd5cbe37b618db795787725930e4">&#9670;&#160;</a></span>ncol()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::ncol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Number of columns. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a6871fd77991469c12276bd76c01bec59">tatami::CompressedSparseMatrix&lt; ROW, T, IDX, U, V, W &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#aac4be39ad30c0d3f663ae757a0997add">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#a06946f87e0e9f6642d67c7609c569359">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a452bca17a80a3c0813fd17af9a31b954">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a29552de098bd2374ae99ef0e223d8973">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a2aeb481069a05d0fc07da5243b4de981">tatami::DenseMatrix&lt; ROW, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a075542a40a304d609080c1bf6dc76dad">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#abb010d4a45c1a06dfb53003025a1bdca">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a815861e36f3ae9ea433411a5570fc3ab">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#ae8c55ad6177842b2c2a585db1ff7c097">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#ae7791e7dcaba8ef84940c140b3f000ee">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#af389aa35f14aa2bdd1614374456fad87">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, and <a class="el" href="classtatami_1_1HDF5DenseMatrix.html#a8f75d095251002a518febb91a4905b37">tatami::HDF5DenseMatrix&lt; T, IDX, transpose &gt;</a>.</p>

</div>
</div>
<a id="ad9017848eb07fd4e6337dcd384d7f7df" name="ad9017848eb07fd4e6337dcd384d7f7df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9017848eb07fd4e6337dcd384d7f7df">&#9670;&#160;</a></span>sparse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::sparse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Is this matrix sparse? Defaults to <code>false</code> if no specialized method is provided in derived classes. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a6054f2b91d0d98facd1ee30ac314f153">tatami::CompressedSparseMatrix&lt; ROW, T, IDX, U, V, W &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a9bc50acc8abb34153ffb8e6aecca44de">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#a732db9b24219f172bb1a333cd83ca0e4">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a7993cbcf05de154adb696169a7fa4003">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#ad22bbe789d72c8dcc1b2d6ff7e4881c7">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#ad1871b601a312da4fe488be870b6b0c8">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a7cccf979a422cfca026faeb2eff55b16">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a6df37645f5d7f68a366155681c7a40aa">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#ad905ca25aac5131b5df260f019e8e7d3">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a4e73b2ae53eb319074a1f3819a0f75f6">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#ac942a6cecd74e7656045ab5d9db5b80d">tatami::VirtualDenseMatrix&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#ac942a6cecd74e7656045ab5d9db5b80d">tatami::VirtualDenseMatrix&lt; T, int &gt;</a>, <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#ac942a6cecd74e7656045ab5d9db5b80d">tatami::VirtualDenseMatrix&lt; T, IDX &gt;</a>, and <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#a086f4e4560281aa4300e655985afc9c2">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>.</p>

</div>
</div>
<a id="a6fc7c2e5f408a096f92163d3c031f113" name="a6fc7c2e5f408a096f92163d3c031f113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fc7c2e5f408a096f92163d3c031f113">&#9670;&#160;</a></span>prefer_rows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::prefer_rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The preferred dimension for extracting values. If <code>true</code>, row-wise extraction is preferred; if <code>false</code>, column-wise extraction is preferred. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a87ffed12dc9ca20382addba5b6bc944b">tatami::CompressedSparseMatrix&lt; ROW, T, IDX, U, V, W &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a1bccf518ae9d0347e3d35dea911f16a2">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#a7419b6dca60886e56c025f131270049e">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#aac7d662db8f3b0da5431b3035a903e1e">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a13a4810d7d36b07df67b4d0e758d200a">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a94ddae4be909726ce775a3dfb1fd0ea5">tatami::DenseMatrix&lt; ROW, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#ad6a41e31f7986bcac03d1386f57fed55">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#af3d355b674d02c73923828549714d1d2">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a557c3dc9adeea5bb48759404b1b12038">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#aca673b5206e9a03554ccb4675f1799ba">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#afc768868ef39a227db3d5d0b51f9e696">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#a4d92ffb3fbf904f58e404925f109bcde">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, and <a class="el" href="classtatami_1_1HDF5DenseMatrix.html#a1e44e966facadb765b89e4f6791cdeb4">tatami::HDF5DenseMatrix&lt; T, IDX, transpose &gt;</a>.</p>

</div>
</div>
<a id="a8e0c04c5b051451af78a64e517aae0c1" name="a8e0c04c5b051451af78a64e517aae0c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e0c04c5b051451af78a64e517aae0c1">&#9670;&#160;</a></span>dimension_preference()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::pair&lt; double, double &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::dimension_preference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A <code>pair</code> containing the number of matrix elements that prefer row-level access (<code>first</code>) or column-level access (<code>second</code>).</dd></dl>
<p>This method is useful for determining the return value of <code><a class="el" href="classtatami_1_1Matrix.html#a6fc7c2e5f408a096f92163d3c031f113">prefer_rows()</a></code> in combined matrices consisting of both row- and column-preferred submatrices. In such cases, the net preference can be determined based on the combined size of the submatrices for each preference.</p>
<p>For simpler matrices, the return value contains the total size of the matrix in one of the <code>double</code>s and zero in the other. </p>

<p>Reimplemented in <a class="el" href="classtatami_1_1DelayedBind.html#ad2e7e7de5d4bfb9805c1ae30d6349a03">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#a1faa2c83092496f4b575a6b4bb443ae5">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#af90b17efb1122a8c56bdec9cc94bcee0">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#aca10f5c1d320a98115f24ad0af0cc305">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a6e5ad149bb1d004112f56cbd62600223">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a85d21acf4b1dada0d5bd260588050540">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#adf14940f5ee2203b21cdc42e2193ba38">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, and <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a8dcadc7645d0ec7799a28b2cec8f8d5a">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>.</p>

</div>
</div>
<a id="a935242c6a441cd71ad82f9965ed7e018" name="a935242c6a441cd71ad82f9965ed7e018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a935242c6a441cd71ad82f9965ed7e018">&#9670;&#160;</a></span>dense_row_workspace() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a3e4e7d9c0a3103fe35d6b6b2d5c8167e">DenseRowWorkspace</a> &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::dense_row_workspace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1WorkspaceOptions.html">WorkspaceOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>Optional parameters for workspace construction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a <code>DenseRowWorkspace</code> for row-wise data extraction. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1DenseMatrix.html#a17e973932b8496c4734f991784e38794">tatami::DenseMatrix&lt; ROW, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a9224750912444b30b2848701bf398fdc">tatami::CompressedSparseMatrix&lt; ROW, T, IDX, U, V, W &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#ad5ab04d2de1f63e957f0d2d6e9588974">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#a5ae4a75a8e256f2b2566d857bc504fb5">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a0695d83dd7f1fdf1785e7362c4c399b6">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#aa8a869d1f115862248a14320a0174ef2">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a5c8327271f54c064795ea00f4067892c">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a8f4e27f6d64713aeda9f833bbe295125">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#ae01a9e284f8330e8c520051c296b04e3">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#ac0d7bbb512bc6d7ae8931d782c9a14f8">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#abb5f8090c5c5040caf8f8acb3ca242d1">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#a19b0356eb17945c277f77a4025ce205d">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, and <a class="el" href="classtatami_1_1HDF5DenseMatrix.html#abdbed2ba420e7ec7a8af4a00088bb638">tatami::HDF5DenseMatrix&lt; T, IDX, transpose &gt;</a>.</p>

</div>
</div>
<a id="ad095a4dabf76686f7105b35215ee6ed4" name="ad095a4dabf76686f7105b35215ee6ed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad095a4dabf76686f7105b35215ee6ed4">&#9670;&#160;</a></span>dense_column_workspace() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a0f817935c6e352d908090a67aff91f2a">DenseColumnWorkspace</a> &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::dense_column_workspace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1WorkspaceOptions.html">WorkspaceOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>Optional parameters for workspace construction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a <code>DenseColumnWorkspace</code> for column-wise data extraction. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1DenseMatrix.html#af6a32f9dbd38addab005f4cdfff11448">tatami::DenseMatrix&lt; ROW, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a6a83c968fb079572e2157365fc88ef76">tatami::CompressedSparseMatrix&lt; ROW, T, IDX, U, V, W &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a684ce4a501dc4cb81593b8b698a08dbc">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#a05f59d6a6b01bbfac72cb8ec3de4a9b7">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a963f7d8fd41876d6075b7a48e9191107">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a533d8446eb560e9b8cd6b7799622ee66">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#ad66235473f22031e2822b81e6cf23742">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a808c25a306df83c7a0009cc703078802">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a5291acbc6b016c16cd912be660b9424c">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a9fb583c68b9c5d6a46963046efba9a24">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#ac79b790b89a82c6c73d2311e936842e3">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#a562085482f0aade91474af463bef51d9">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, and <a class="el" href="classtatami_1_1HDF5DenseMatrix.html#ad4167765fa77e9ccfb37105a3edbe0cf">tatami::HDF5DenseMatrix&lt; T, IDX, transpose &gt;</a>.</p>

</div>
</div>
<a id="abb01b715c9918114ba658d279f0c9306" name="abb01b715c9918114ba658d279f0c9306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb01b715c9918114ba658d279f0c9306">&#9670;&#160;</a></span>sparse_row_workspace() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a94ca69af3e36f805e53326d4f8fc7cba">SparseRowWorkspace</a> &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::sparse_row_workspace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1WorkspaceOptions.html">WorkspaceOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>Optional parameters for workspace construction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a <code>SparseRowWorkspace</code> for row-wise data extraction. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a6b4b00740528ca1b7aafea83033c0802">tatami::CompressedSparseMatrix&lt; ROW, T, IDX, U, V, W &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a1c2c5d790b601127b9d4678e329f3d09">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#a79f54d233f034c29f1375f0158d092aa">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#abe09254b3cc2ac0b3efdefe3e0ee33fc">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#aedc40d60a4eb2dafaf648b3e6ad17fbe">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#acc554ace1e678bed927c5fbb87c57e68">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a7d62a19ab774993c222e6423c5c8527d">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a31d99cd0b50f46b829ae5a1be9b435ed">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a24d73d31c7c379210b25a42e3cd6af97">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a4d9fdee976b92aafa5b48a7174a82c29">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#a381c91d73fd28af2673ca9891dd1d1c9">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#a171ed87906c06c83d982440d9e40f075">tatami::VirtualDenseMatrix&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#a171ed87906c06c83d982440d9e40f075">tatami::VirtualDenseMatrix&lt; T, int &gt;</a>, and <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#a171ed87906c06c83d982440d9e40f075">tatami::VirtualDenseMatrix&lt; T, IDX &gt;</a>.</p>

</div>
</div>
<a id="a2c50f28ce9ca0edc27a4647b6c595b21" name="a2c50f28ce9ca0edc27a4647b6c595b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c50f28ce9ca0edc27a4647b6c595b21">&#9670;&#160;</a></span>sparse_column_workspace() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a4182e7ceb1cab3083cfec53b9dc5d561">SparseColumnWorkspace</a> &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::sparse_column_workspace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1WorkspaceOptions.html">WorkspaceOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>Optional parameters for workspace construction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a <code>SparseColumnWorkspace</code> for column-wise data extraction. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#ab1d7c8e4207e7ecc2e6101029fdd783a">tatami::CompressedSparseMatrix&lt; ROW, T, IDX, U, V, W &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a1a266d52cbdc9ac550d628bd94d70fdf">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#aff046dfa06e84c8658b5a4a0489130e0">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#adb77e618d10656ef8c069d29919a8997">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a264e66d1b1b44af6c3bb37523e76bd2e">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#ac768438d5b92e1c6ca91f0e96323e527">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a4bdaba3b2d173fd5189c696270b15ea9">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#aecaa62ed3498137c256603a8d3f15a97">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#af3b33f3ddc282644d4271872c7236a15">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a00d44440c2abc289df76d1bcf1518528">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#ad868739fe9ede73bbd01e2f29a828422">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#ae0d5b4b59798f270c83136283ef3fff4">tatami::VirtualDenseMatrix&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#ae0d5b4b59798f270c83136283ef3fff4">tatami::VirtualDenseMatrix&lt; T, int &gt;</a>, and <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#ae0d5b4b59798f270c83136283ef3fff4">tatami::VirtualDenseMatrix&lt; T, IDX &gt;</a>.</p>

</div>
</div>
<a id="af96ddb276e8b641b71d2659098235ad5" name="af96ddb276e8b641b71d2659098235ad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af96ddb276e8b641b71d2659098235ad5">&#9670;&#160;</a></span>dense_row_workspace() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a77143ea2ebbc50e952b51d640376b008">DenseRowBlockWorkspace</a> &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::dense_row_workspace </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1WorkspaceOptions.html">WorkspaceOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>Optional parameters for workspace construction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a <code>DenseRowBlockWorkspace</code> for row-wise extraction of data from a contiguous block of columns from <code>[start, start + length)</code>. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1DelayedSubset.html#ab05250b98f085534ab387a6224699dc6">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#ac76b1dde15b4091dddb613a614427a00">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1HDF5DenseMatrix.html#a433b9b117977ed9f9b149a5dd6a1a5e0">tatami::HDF5DenseMatrix&lt; T, IDX, transpose &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a925255facca925c53ddd486222f26ec8">tatami::DenseMatrix&lt; ROW, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#ad471ad68a71ecf6b03e6324583137741">tatami::CompressedSparseMatrix&lt; ROW, T, IDX, U, V, W &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#aacb982322730cf2d804283f2d4dabc0c">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#a2cad692977bc7dd723bb8d7d0755d302">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#aa72165e815ccbd82fb5d2818de159537">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#af97af9d0c69a2aaca49997f57fa5f724">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a176559f15b75c9212a76d2dff455a065">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#ac464e0edc037db086b71d60028a5f0ce">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#af706b21723aa56376936d6771e65055b">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, and <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a997e1a092c49fbf238dab057e6b92064">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>.</p>

</div>
</div>
<a id="a3a14f0d46805b214bf93c2b89cacaed9" name="a3a14f0d46805b214bf93c2b89cacaed9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a14f0d46805b214bf93c2b89cacaed9">&#9670;&#160;</a></span>dense_column_workspace() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="namespacetatami.html#aba03c94d01da4c440f052d704e14cdbe">DenseColumnBlockWorkspace</a> &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::dense_column_workspace </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1WorkspaceOptions.html">WorkspaceOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Index of the first row in the block. </td></tr>
    <tr><td class="paramname">length</td><td>Number of rows in the block. </td></tr>
    <tr><td class="paramname">options</td><td>Optional parameters for workspace construction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a <code>DenseRowBlockWorkspace</code> for column-wise extraction of data from a contiguous block of rows from <code>[start, start + length)</code>. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1DelayedSubset.html#a5289b7562e1c01f8d9199f743c3bc8f2">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#a0d7c47548b7dc4a950fcfe842d27547c">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1HDF5DenseMatrix.html#a92ac145886191dcf598d9c5637a71be7">tatami::HDF5DenseMatrix&lt; T, IDX, transpose &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a67516b501d1746ae0c3fa86252930170">tatami::DenseMatrix&lt; ROW, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#aed6edd3b6c1dc72eb2467fa804d2910b">tatami::CompressedSparseMatrix&lt; ROW, T, IDX, U, V, W &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#aaaf1c4a3fc32a614a1be8ec4457262b8">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#a06911c97415e22e753c0244b72542fe0">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a01719840a8c166990e443687cd37651b">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a8433eb7a22b79bec94da79531115a68b">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#aea39d8be411322f2358fa38a0624eae4">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#aa856381168c9abc88987e5250c24e9f2">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#afcdf8704397a0a069bef471752d990fc">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, and <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#adcceb75c228849ebefea893479e0964e">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>.</p>

</div>
</div>
<a id="a810044d32984857de1d571f120fe97df" name="a810044d32984857de1d571f120fe97df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a810044d32984857de1d571f120fe97df">&#9670;&#160;</a></span>sparse_row_workspace() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a1798a0b6bf7822a590baee156371c352">SparseRowBlockWorkspace</a> &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::sparse_row_workspace </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1WorkspaceOptions.html">WorkspaceOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Index of the first column in the block. </td></tr>
    <tr><td class="paramname">length</td><td>Number of columns in the block. </td></tr>
    <tr><td class="paramname">options</td><td>Optional parameters for workspace construction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a <code>SparseRowBlockWorkspace</code> for row-wise extraction of data from a contiguous block of columns from <code>[start, start + length)</code>. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1DelayedSubset.html#a0582656c4355fcd3a37c8d39d20297b7">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#a2a7e8fd8a5bd10db290d904e688e5012">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a23e2ff06481ddfcfd5f6c35c4d0109f8">tatami::CompressedSparseMatrix&lt; ROW, T, IDX, U, V, W &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a473e2949214caa729113ede354d83b43">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#ac3c40fb0cd5ee6efdee3c7900d418c89">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a284ad40f4530ce0e1a90ca92447a6830">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a5fa5d43f2d78f61cc0843a21d9530e28">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#aec6cf5cdd0f62b5cf110d5d665e5aac2">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#ac4be8f7daa477cd67dc71c6fc4d36e2d">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a562027e23174375167175db7ec1709aa">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#a33f0344b6a0a8f328656f749ddc763f0">tatami::VirtualDenseMatrix&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#a33f0344b6a0a8f328656f749ddc763f0">tatami::VirtualDenseMatrix&lt; T, int &gt;</a>, <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#a33f0344b6a0a8f328656f749ddc763f0">tatami::VirtualDenseMatrix&lt; T, IDX &gt;</a>, and <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a445392c8425d148968aeec569cefc569">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>.</p>

</div>
</div>
<a id="a99694353e05bc2d8fe40735b96d9d898" name="a99694353e05bc2d8fe40735b96d9d898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99694353e05bc2d8fe40735b96d9d898">&#9670;&#160;</a></span>sparse_column_workspace() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="namespacetatami.html#ac85be5029bb03a836b329b566c4d89c2">SparseColumnBlockWorkspace</a> &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::sparse_column_workspace </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1WorkspaceOptions.html">WorkspaceOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Index of the first row in the block. </td></tr>
    <tr><td class="paramname">length</td><td>Number of rows in the block. </td></tr>
    <tr><td class="paramname">options</td><td>Optional parameters for workspace construction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a <code>SparseColumnBlockWorkspace</code> for column-wise extraction of data from a contiguous block of rows from <code>[start, start + length)</code>. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1DelayedSubset.html#abac7955fe0760b3ba2c530ff4e636d2a">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#a6bb6a52403dcdad0bcc6ecd04c69caf6">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#ae4d4a867e04c06389861de0e0427ae1d">tatami::CompressedSparseMatrix&lt; ROW, T, IDX, U, V, W &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a4bba718191c6dfb2d593a4f8bf49f117">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#a84d46f6b01cd35165eeab712847751d1">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#aa1a776ebe8bb19bbb904164e4b1c62e1">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a52d34a4b67483050a6f93778296b8d8a">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#abd5eaa930c3c026ffa5223ddcde246a2">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a3463310f768f77c1f0b8a3d6c6bb2fd4">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a2d4b0676af052c4720e232f6d03bc32e">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#a6d17a2860f1e7ea7e4973b042f99c683">tatami::VirtualDenseMatrix&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#a6d17a2860f1e7ea7e4973b042f99c683">tatami::VirtualDenseMatrix&lt; T, int &gt;</a>, <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#a6d17a2860f1e7ea7e4973b042f99c683">tatami::VirtualDenseMatrix&lt; T, IDX &gt;</a>, and <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#abe8c3a0526c2e6cc37d92431ac63e5b9">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>.</p>

</div>
</div>
<a id="acec95f144f7287a375dfb301974c7d50" name="acec95f144f7287a375dfb301974c7d50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acec95f144f7287a375dfb301974c7d50">&#9670;&#160;</a></span>dense_row_workspace() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a422993ac842bf906000d6ccebd0c86e6">DenseRowIndexWorkspace</a>&lt; IDX &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::dense_row_workspace </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; IDX &gt;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1WorkspaceOptions.html">WorkspaceOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Vector containing sorted and unique column indices. </td></tr>
    <tr><td class="paramname">options</td><td>Optional parameters for workspace construction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a <code>DenseRowIndexWorkspace</code> for row-wise extraction of data from a subset of columns defined by <code>indices</code>. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1DenseMatrix.html#a7b6b7b3a5585f0449490c36c52eb3fa2">tatami::DenseMatrix&lt; ROW, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#a0e776f4f7500b9538ea4d564023ead18">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1HDF5DenseMatrix.html#acdaa72e95eb76cb0566614aabda89e0a">tatami::HDF5DenseMatrix&lt; T, IDX, transpose &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a92ac35a6a0a636825ede6c606cd6768d">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#ad527970db4edb1b162289a00ed25bd76">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a49339cfcc0f39bdaaa6804f0d73683e4">tatami::CompressedSparseMatrix&lt; ROW, T, IDX, U, V, W &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#aa4f38aae4b88c10e0a7d5185f21598e7">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a08e22a150610441287326f486a689bd2">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a6686e6b3bcb60d72af76a35c0bf9e6e7">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#aa6459407290dfadb49341277907270b6">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#ad4a7ddbccd0804395f15c9a9d8e7f04b">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#ad942a6c1eeb60b7bf78dfc305dd3211c">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#aa2ee2ebb89c0dc22443caee192e35049">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>.</p>

</div>
</div>
<a id="a2910e520ecd969329a43f9ac9a5598bd" name="a2910e520ecd969329a43f9ac9a5598bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2910e520ecd969329a43f9ac9a5598bd">&#9670;&#160;</a></span>dense_column_workspace() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a0029d39a6fa9fe81a5c85cdf744ebd68">DenseColumnIndexWorkspace</a>&lt; IDX &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::dense_column_workspace </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; IDX &gt;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1WorkspaceOptions.html">WorkspaceOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Vector containing sorted and unique row indices. </td></tr>
    <tr><td class="paramname">options</td><td>Optional parameters for workspace construction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a <code>DenseColumnIndexWorkspace</code> for column-wise extraction of data from a subset of rows defined by <code>indices</code> </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1DenseMatrix.html#a5878a38aaf1b6d4fb9fbbf688bec5edf">tatami::DenseMatrix&lt; ROW, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#a7a15a8054765ccfbae499f7cd7aa6f42">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1HDF5DenseMatrix.html#a16ab7406f6d8b5e0735582735e2571d2">tatami::HDF5DenseMatrix&lt; T, IDX, transpose &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a82a44a606cd10b78d32146e79ab69c11">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a8d69aef86747579f95f3a8ba9548619a">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a14b095bc9a4c151d1f19d13716381490">tatami::CompressedSparseMatrix&lt; ROW, T, IDX, U, V, W &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#ab29071cb701d8e57cb5cbee83b11e82c">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#ac1c032800259d80eed9ae52f5057774d">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a6f403488b68975e8cb108e75ad2549b9">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a0e4b8ddf0d84cd10ef29597e5e9e7a08">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#abbf33500f39be1d1af8836c4f4333f83">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a6e8e7889ee53aa78a073df4328604851">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#a7887a65c5e45c5e4a672b6358211b125">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>.</p>

</div>
</div>
<a id="a7a2c1606b0b9c0c47c964d4c07fbcd4d" name="a7a2c1606b0b9c0c47c964d4c07fbcd4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a2c1606b0b9c0c47c964d4c07fbcd4d">&#9670;&#160;</a></span>sparse_row_workspace() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a1edbb6992ee134f2481b6227300322ce">SparseRowIndexWorkspace</a>&lt; IDX &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::sparse_row_workspace </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; IDX &gt;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1WorkspaceOptions.html">WorkspaceOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Vector containing sorted and unique column indices. </td></tr>
    <tr><td class="paramname">options</td><td>Optional parameters for workspace construction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a <code>SparseRowIndexWorkspace</code> for row-wise extraction of data from a subset of columns defined by <code>indices</code>. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#a51f38173653d4477b8b497453373a0ce">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#ae07b28fa358a33e0be1618cfebbec2f6">tatami::VirtualDenseMatrix&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#ae07b28fa358a33e0be1618cfebbec2f6">tatami::VirtualDenseMatrix&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#abd888ac023e5a62236d198215db84e18">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a81490aa82f524ffd32a2ae8c6120cb46">tatami::CompressedSparseMatrix&lt; ROW, T, IDX, U, V, W &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#aa8ebb2d1cdfa157152b03806601e4cf0">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#af6f6e774d77bb91524e6246ece5eca4f">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#af08dffe439dcec4e33c323bb33d2209f">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#aa038bef26d7a595ca061b7974888e967">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a4c24d766144e911ed1db65e3d24ffe00">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#af681a05b2d47eec4985aa8eb53274c2d">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a102ec6fff6403d4c7952e6668784661c">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#aeb52adf2cee35ada459ea6e3206d871f">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>.</p>

</div>
</div>
<a id="a6d7bb36282f467911ff2573bb96d465b" name="a6d7bb36282f467911ff2573bb96d465b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d7bb36282f467911ff2573bb96d465b">&#9670;&#160;</a></span>sparse_column_workspace() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a54ba456fea7d955f10d55792cbcc7a58">SparseColumnIndexWorkspace</a>&lt; IDX &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::sparse_column_workspace </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; IDX &gt;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1WorkspaceOptions.html">WorkspaceOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Vector containing sorted and unique row indices. </td></tr>
    <tr><td class="paramname">options</td><td>Optional parameters for workspace construction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a <code>SparseColumnIndexWorkspace</code> for column-wise extraction of data from a subset of rows defined by <code>indices</code>. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#abdb12c1269e6307ed2fc4ad9bafd9339">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#a0dd42cfb9dcefc79678d1f2c3b476b9e">tatami::VirtualDenseMatrix&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#a0dd42cfb9dcefc79678d1f2c3b476b9e">tatami::VirtualDenseMatrix&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#ae2fb57df8e557b30f0899fec8709dd22">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a297a3a400780d7dc0bece24f0cde4ae0">tatami::CompressedSparseMatrix&lt; ROW, T, IDX, U, V, W &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a0983e22577a0c340a58c5cb66476304b">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a744ac6a8744f9d4627770b3097cc6ef1">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a475dce6fec4cfd4538d5f5d8bad87053">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a03d89b9fe2f7852e77e22e33f4a075bf">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a0d9f7f1b615c0fbc95d0a998a7d47e0e">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#aa8064683a05bbae401bb92c9b72229a3">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a89e06caa3cbbea929fc10533cc866b1f">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#a1519d1644be1d9ebf0d2edee21db3ea6">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>.</p>

</div>
</div>
<a id="a675bf1ddd56c6eaf24b1100fdf7122a0" name="a675bf1ddd56c6eaf24b1100fdf7122a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a675bf1ddd56c6eaf24b1100fdf7122a0">&#9670;&#160;</a></span>dense_row_workspace() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a3e4e7d9c0a3103fe35d6b6b2d5c8167e">DenseRowWorkspace</a> &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::dense_row_workspace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a <code>DenseRowWorkspace</code> for row-wise data extraction, or a null pointer if no workspace is required. </dd></dl>

</div>
</div>
<a id="a293cc62cc8a39e4ed66ab99e33cbcf27" name="a293cc62cc8a39e4ed66ab99e33cbcf27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a293cc62cc8a39e4ed66ab99e33cbcf27">&#9670;&#160;</a></span>dense_column_workspace() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a0f817935c6e352d908090a67aff91f2a">DenseColumnWorkspace</a> &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::dense_column_workspace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a <code>DenseColumnWorkspace</code> for row-wise data extraction, or a null pointer if no workspace is required. </dd></dl>

</div>
</div>
<a id="a4a4db842e8742bb6eb9d3456ad9628b2" name="a4a4db842e8742bb6eb9d3456ad9628b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a4db842e8742bb6eb9d3456ad9628b2">&#9670;&#160;</a></span>sparse_row_workspace() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a94ca69af3e36f805e53326d4f8fc7cba">SparseRowWorkspace</a> &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::sparse_row_workspace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a <code>SparseRowWorkspace</code> for row-wise data extraction, or a null pointer if no workspace is required. </dd></dl>

</div>
</div>
<a id="ae8a1dd4ef8814f3e748dc6bc9d7c6828" name="ae8a1dd4ef8814f3e748dc6bc9d7c6828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8a1dd4ef8814f3e748dc6bc9d7c6828">&#9670;&#160;</a></span>sparse_column_workspace() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a4182e7ceb1cab3083cfec53b9dc5d561">SparseColumnWorkspace</a> &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::sparse_column_workspace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a <code>SparseColumnWorkspace</code> for row-wise data extraction, or a null pointer if no workspace is required. </dd></dl>

</div>
</div>
<a id="a15773037446a0221ff0e5a5bf5d4299c" name="a15773037446a0221ff0e5a5bf5d4299c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15773037446a0221ff0e5a5bf5d4299c">&#9670;&#160;</a></span>dense_row_workspace() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a77143ea2ebbc50e952b51d640376b008">DenseRowBlockWorkspace</a> &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::dense_row_workspace </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Index of the first row in the block. </td></tr>
    <tr><td class="paramname">length</td><td>Number of rows in the block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a <code>DenseRowBlockWorkspace</code> for row-wise extraction of data from a contiguous block of columns from <code>[start, start + length)</code>. </dd></dl>

</div>
</div>
<a id="a134a0216419196e100c542f37550ca13" name="a134a0216419196e100c542f37550ca13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a134a0216419196e100c542f37550ca13">&#9670;&#160;</a></span>dense_column_workspace() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#aba03c94d01da4c440f052d704e14cdbe">DenseColumnBlockWorkspace</a> &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::dense_column_workspace </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Index of the first row in the block. </td></tr>
    <tr><td class="paramname">length</td><td>Number of rows in the block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a <code>DenseRowBlockWorkspace</code> for column-wise extraction of data from a contiguous block of rows from <code>[start, start + length)</code>. </dd></dl>

</div>
</div>
<a id="ad5784d1baf88d06c4b9999ce60dc5b14" name="ad5784d1baf88d06c4b9999ce60dc5b14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5784d1baf88d06c4b9999ce60dc5b14">&#9670;&#160;</a></span>sparse_row_workspace() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a1798a0b6bf7822a590baee156371c352">SparseRowBlockWorkspace</a> &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::sparse_row_workspace </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Index of the first column in the block. </td></tr>
    <tr><td class="paramname">length</td><td>Number of columns in the block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a <code>SparseRowBlockWorkspace</code> for row-wise extraction of data from a contiguous block of columns from <code>[start, start + length)</code>. </dd></dl>

</div>
</div>
<a id="aa6950a659cb100964829e9a7ba094796" name="aa6950a659cb100964829e9a7ba094796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6950a659cb100964829e9a7ba094796">&#9670;&#160;</a></span>sparse_column_workspace() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#ac85be5029bb03a836b329b566c4d89c2">SparseColumnBlockWorkspace</a> &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::sparse_column_workspace </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Index of the first row in the block. </td></tr>
    <tr><td class="paramname">length</td><td>Number of rows in the block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a <code>SparseRowBlockWorkspace</code> for column-wise extraction of data from a contiguous block of rows from <code>[start, start + length)</code>. </dd></dl>

</div>
</div>
<a id="ab6cad51f94ab35c4751ae731b1891da6" name="ab6cad51f94ab35c4751ae731b1891da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6cad51f94ab35c4751ae731b1891da6">&#9670;&#160;</a></span>dense_row_workspace() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a422993ac842bf906000d6ccebd0c86e6">DenseRowIndexWorkspace</a>&lt; IDX &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::dense_row_workspace </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; IDX &gt;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Vector containing sorted and unique column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a <code>DenseRowIndexWorkspace</code> for row-wise extraction of data from a subset of columns defined by <code>indices</code>. </dd></dl>

</div>
</div>
<a id="a479dcb29b421a743d31a82fe3991d941" name="a479dcb29b421a743d31a82fe3991d941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a479dcb29b421a743d31a82fe3991d941">&#9670;&#160;</a></span>dense_column_workspace() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a0029d39a6fa9fe81a5c85cdf744ebd68">DenseColumnIndexWorkspace</a>&lt; IDX &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::dense_column_workspace </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; IDX &gt;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Vector containing sorted and unique row indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a <code>DenseColumnIndexWorkspace</code> for column-wise extraction of data from a subset of rows defined by <code>indices</code> </dd></dl>

</div>
</div>
<a id="a4ada5a449ab883b911b420d7ed53c9c8" name="a4ada5a449ab883b911b420d7ed53c9c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ada5a449ab883b911b420d7ed53c9c8">&#9670;&#160;</a></span>sparse_row_workspace() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a1edbb6992ee134f2481b6227300322ce">SparseRowIndexWorkspace</a>&lt; IDX &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::sparse_row_workspace </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; IDX &gt;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Vector containing sorted and unique column indices. </td></tr>
    <tr><td class="paramname">options</td><td>Optional parameters for workspace construction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a <code>SparseRowIndexWorkspace</code> for row-wise extraction of data from a subset of columns defined by <code>indices</code>. </dd></dl>

</div>
</div>
<a id="a1a5563529059a6db56968b8b15558c58" name="a1a5563529059a6db56968b8b15558c58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a5563529059a6db56968b8b15558c58">&#9670;&#160;</a></span>sparse_column_workspace() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a54ba456fea7d955f10d55792cbcc7a58">SparseColumnIndexWorkspace</a>&lt; IDX &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::sparse_column_workspace </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; IDX &gt;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Vector containing sorted and unique row indices. </td></tr>
    <tr><td class="paramname">options</td><td>Optional parameters for workspace construction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a <code>SparseColumnIndexWorkspace</code> for column-wise extraction of data from a subset of rows defined by <code>indices</code>. </dd></dl>

</div>
</div>
<a id="a34d3893b5a47b532d30db6780febdeff" name="a34d3893b5a47b532d30db6780febdeff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34d3893b5a47b532d30db6780febdeff">&#9670;&#160;</a></span>row() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const T * <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::row </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a3e4e7d9c0a3103fe35d6b6b2d5c8167e">DenseRowWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><code>buffer</code> may not necessarily be filled upon extraction if a pointer can be returned to the underlying data store. This can be checked by comparing the returned pointer to <code>buffer</code>; if they are the same, <code>buffer</code> has been filled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Index of the row. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1Matrix.html#a1049bd5cbe37b618db795787725930e4">ncol()</a></code> values. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to the workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#a675bf1ddd56c6eaf24b1100fdf7122a0">dense_row_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the values of row <code>r</code>, containing <code><a class="el" href="classtatami_1_1Matrix.html#a1049bd5cbe37b618db795787725930e4">ncol()</a></code> valid entries. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a7a629e46369d348ffae67dbb50f573d7">tatami::CompressedSparseMatrix&lt; ROW, T, IDX, U, V, W &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#ad8590f8eb02434e1e19597ffc7b60c34">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#ae7c5d39cbdff4d73d810a326be24a528">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a36b9e80b53f27089e9ce2423bc7d3aff">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#aa660966b32c9d436fe644e2172cdc8ef">tatami::DenseMatrix&lt; ROW, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a44f071a8068e7c908f1604edccfdfcc4">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a5e510f597fb379027da82b0b920ecfff">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#aff1267ac3c45aa3c159b14c753868cce">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#afdace6618aeb144e29da1ec1e7069e9f">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a32a9476af9ecb94d08007649be5ef088">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#a7111cb3433e743b4c856b2182399095a">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1HDF5DenseMatrix.html#a966a1829774b77756f92137e730f47aa">tatami::HDF5DenseMatrix&lt; T, IDX, transpose &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#ad323b63ac00283c615d8c6fec025ee1a">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>.</p>

</div>
</div>
<a id="ada2c72ccd1628c96c40c601e6ceda654" name="ada2c72ccd1628c96c40c601e6ceda654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada2c72ccd1628c96c40c601e6ceda654">&#9670;&#160;</a></span>column() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const T * <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::column </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a0f817935c6e352d908090a67aff91f2a">DenseColumnWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><code>buffer</code> may not necessarily be filled upon extraction if a pointer can be returned to the underlying data store. This can be checked by comparing the returned pointer to <code>buffer</code>; if they are the same, <code>buffer</code> has been filled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Index of the column. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1Matrix.html#a48e1342556ff97cc8367b25d244195a9">nrow()</a></code> values. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to the workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#a293cc62cc8a39e4ed66ab99e33cbcf27">dense_column_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the values of column <code>c</code>, containing <code><a class="el" href="classtatami_1_1Matrix.html#a1049bd5cbe37b618db795787725930e4">ncol()</a></code> valid entries. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a3cfe959afef37065779d6ae4f1e943b2">tatami::CompressedSparseMatrix&lt; ROW, T, IDX, U, V, W &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#abedcd7653c77ce1065b03578282c6a00">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#acc73048dd301698b0644b0340f0a6530">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a1f99e1a182118d887e2eb69e748eb452">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a39e59ca0c01ca724b531ed778002e463">tatami::DenseMatrix&lt; ROW, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a5e53e722959521d79dabdabfe8459dd8">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a70e36bf2d16ce49e5f156695dfe05095">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#acd20211ca1a65e34329d537dca188719">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a27ea53078370f58b64c1fbf1150e8adc">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#af505bcd07879d5e738f7b8ad8fffc8c4">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#aac74ca31fe49a7a3c8b782ab7b81443c">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1HDF5DenseMatrix.html#ab68254039a82643caeef7fb9a9d04b30">tatami::HDF5DenseMatrix&lt; T, IDX, transpose &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#a65ae1b30c2db482ff1a1164804dd75ce">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>.</p>

</div>
</div>
<a id="ac2165df9ff4cb9afcc61992e888f7b33" name="ac2165df9ff4cb9afcc61992e888f7b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2165df9ff4cb9afcc61992e888f7b33">&#9670;&#160;</a></span>row() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const T * <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::row </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a77143ea2ebbc50e952b51d640376b008">DenseRowBlockWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><code>buffer</code> may not necessarily be filled upon extraction if a pointer can be returned to the underlying data store. This can be checked by comparing the returned pointer to <code>buffer</code>; if they are the same, <code>buffer</code> has been filled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Index of the row. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1BlockWorkspace.html#a818b80115792369f2d48407b464c45d2">DenseRowBlockWorkspace::length</a></code> values. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to the workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#a675bf1ddd56c6eaf24b1100fdf7122a0">dense_row_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to an array containing a block of values from row <code>r</code>, where the array is of length <code>RowBlockWorkspace::length</code>. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#ab05d991dcc733a90253d3bab0fdce994">tatami::CompressedSparseMatrix&lt; ROW, T, IDX, U, V, W &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#ab1e5c8fa35e290556904a052dffddca1">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a490abb3fd2e81043887b13099dfe4bd8">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a92a8e9219c65ccaace336bb48ecde340">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a53446d6f49a21fe2c9ff38a8739ec5b2">tatami::DenseMatrix&lt; ROW, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#ad5dacf5a5aba93bd76abe6875191d903">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a95602cdb5c3dbeadaea273168afed3c5">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a264581cbf42e6103a67c1362fea8b282">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#abdf0ba2655627d14dbeffea2cd74415d">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#aec2a1e30bd09a595cd43904d04ced9b3">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#a73bab3b44b034dd57e0d747b87d6d684">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1HDF5DenseMatrix.html#a265db70b6d52b7482d160d2e1f95a402">tatami::HDF5DenseMatrix&lt; T, IDX, transpose &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#ac19598fe6d1bfb7693f824aa95663fab">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>.</p>

</div>
</div>
<a id="aee2bfcd96c64ecc4fb1c6682b2527aae" name="aee2bfcd96c64ecc4fb1c6682b2527aae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee2bfcd96c64ecc4fb1c6682b2527aae">&#9670;&#160;</a></span>column() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const T * <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::column </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#aba03c94d01da4c440f052d704e14cdbe">DenseColumnBlockWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><code>buffer</code> may not necessarily be filled upon extraction if a pointer can be returned to the underlying data store. This can be checked by comparing the returned pointer to <code>buffer</code>; if they are the same, <code>buffer</code> has been filled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Index of the column. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1BlockWorkspace.html#a818b80115792369f2d48407b464c45d2">DenseColumnBlockWorkspace::length</a></code> values. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to the workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#a293cc62cc8a39e4ed66ab99e33cbcf27">dense_column_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to an array containing a block of values from column <code>c</code>, where the array is of length <code>ColumnBlockWorkspace::length</code>. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a5d3f8a842f7154f93ec9a2f5d574d168">tatami::CompressedSparseMatrix&lt; ROW, T, IDX, U, V, W &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#ab34dbebdf284370847fa4c55b727642f">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a4f6e61c8efa298fa2e5194ad395b319b">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a07857547ed2f6aca6f82d844ee059188">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#ad9cb725a013fbacd54e19bbcbc88f10f">tatami::DenseMatrix&lt; ROW, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#abfb35f4231907ce0169cfd770db7a58f">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a352b04c58beb5967ceaa0091298767fb">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a858ebb9b8ca549d06616f43b579b971a">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#ae289b3ec2d82036090e22dd533a98d7d">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#ae87d25e00834989a41fe744e677510bd">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#af7af4f5640cb250b0c6d211395d7241f">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1HDF5DenseMatrix.html#a2e14ce640841d22b068bdef1d8e2e358">tatami::HDF5DenseMatrix&lt; T, IDX, transpose &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#a12799fb40cb6e10cf19ca1dfca908821">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>.</p>

</div>
</div>
<a id="a0e22a1534c0549a2bf5ac818d5a9c1cb" name="a0e22a1534c0549a2bf5ac818d5a9c1cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e22a1534c0549a2bf5ac818d5a9c1cb">&#9670;&#160;</a></span>row() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const T * <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::row </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a422993ac842bf906000d6ccebd0c86e6">DenseRowIndexWorkspace</a>&lt; IDX &gt; *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Index of the row. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1IndexWorkspace.html#a01e3f1497ad171dec73398872c4bd2aa">DenseRowIndexWorkspace::length</a></code> values. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to the workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#a675bf1ddd56c6eaf24b1100fdf7122a0">dense_row_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The array pointed to by <code>buffer</code> is filled with a subset of values from column <code>r</code>. <code>buffer</code> itself is returned. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a515fe870d1e4df2d1bd74ad530abb50b">tatami::CompressedSparseMatrix&lt; ROW, T, IDX, U, V, W &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#ae6cf66092e8dc2b28b755c5abd185376">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a758d6a531431429e142524b198ad434a">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a82e70868392ab987a2022f9b2c603e83">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a62d499ad1768a898f54dbf07030b304a">tatami::DenseMatrix&lt; ROW, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a26ebf454f71a42e4a366a2438253250a">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#ab1dca42566a27801f9ed7432b667f745">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a1d73c8d02a4f0b323c075971b99502d1">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a31135ce512b0c93cae2c99ee8ea16f91">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#ac21c3f02db6739430112e7295c825e87">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#ad5ff291cc5e0f34bc9f0c77e68be929b">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1HDF5DenseMatrix.html#ad166373de5e9bce6104f1c70b1b38752">tatami::HDF5DenseMatrix&lt; T, IDX, transpose &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#ac2d3341990244dc5fbbdd821d95aa5df">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>.</p>

</div>
</div>
<a id="a1f503f54c5ebbfdcfb7c313a405f08ac" name="a1f503f54c5ebbfdcfb7c313a405f08ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f503f54c5ebbfdcfb7c313a405f08ac">&#9670;&#160;</a></span>column() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const T * <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::column </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a0029d39a6fa9fe81a5c85cdf744ebd68">DenseColumnIndexWorkspace</a>&lt; IDX &gt; *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Index of the column. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1IndexWorkspace.html#a01e3f1497ad171dec73398872c4bd2aa">DenseColumnIndexWorkspace::length</a></code> values. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to the workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#a293cc62cc8a39e4ed66ab99e33cbcf27">dense_column_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The array pointed to by <code>buffer</code> is filled with a subset of values from column <code>c</code>. <code>buffer</code> itself is returned. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a338f8a2af7377c4a0640edfabc4dcea2">tatami::CompressedSparseMatrix&lt; ROW, T, IDX, U, V, W &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a221ac990fcfc8d5d9a33758a0c43cf42">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a9946ecebda6ded85794d5ebefb108dcd">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a079ba855baa55ed58802c076a3d48060">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#ae9f9d5a6a051a251ee434109b669c753">tatami::DenseMatrix&lt; ROW, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a56a348f66a2b7eea75997823b11b1615">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#aecaedce6fe36beeb0450b7ad6b89fbf8">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a15b12fc81a9b8bf0d3efbaa80d035f0d">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a0e0e8a65aed8d000e510784029fbdb52">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a652843cf8c7da1baa42da80856cd4774">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#a43d6a0feb06f075eb5920d799baf40ec">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1HDF5DenseMatrix.html#a2fed5423e56c7013675210c05e38ef35">tatami::HDF5DenseMatrix&lt; T, IDX, transpose &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#ade33d2becf6ccc2fee051a9a229fee12">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>.</p>

</div>
</div>
<a id="a2197ca3d05f70127f22de31a645c0ba4" name="a2197ca3d05f70127f22de31a645c0ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2197ca3d05f70127f22de31a645c0ba4">&#9670;&#160;</a></span>row_copy() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::row_copy </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a3e4e7d9c0a3103fe35d6b6b2d5c8167e">DenseRowWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Index of the row. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1Matrix.html#a1049bd5cbe37b618db795787725930e4">ncol()</a></code> values. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to the workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#a675bf1ddd56c6eaf24b1100fdf7122a0">dense_row_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The array at <code>buffer</code> is filled with the values of row <code>r</code>. <code>buffer</code> itself is returned. </dd></dl>

</div>
</div>
<a id="a2682f1537920f6b4db653583ecb38e45" name="a2682f1537920f6b4db653583ecb38e45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2682f1537920f6b4db653583ecb38e45">&#9670;&#160;</a></span>column_copy() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::column_copy </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a0f817935c6e352d908090a67aff91f2a">DenseColumnWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Index of the column. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1Matrix.html#a48e1342556ff97cc8367b25d244195a9">nrow()</a></code> values. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to the workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#a293cc62cc8a39e4ed66ab99e33cbcf27">dense_column_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The array at <code>buffer</code> is filled with the values of column <code>c</code>. <code>buffer</code> itself is returned. </dd></dl>

</div>
</div>
<a id="a7ba093df5c7add38c7a65cd0156d3c45" name="a7ba093df5c7add38c7a65cd0156d3c45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ba093df5c7add38c7a65cd0156d3c45">&#9670;&#160;</a></span>row_copy() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::row_copy </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a77143ea2ebbc50e952b51d640376b008">DenseRowBlockWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Index of the row. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1BlockWorkspace.html#a818b80115792369f2d48407b464c45d2">DenseRowBlockWorkspace::length</a></code> values. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to the workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#a675bf1ddd56c6eaf24b1100fdf7122a0">dense_row_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The array pointed to by <code>buffer</code> is filled with a block of values from row <code>r</code>. <code>buffer</code> itself is returned. </dd></dl>

</div>
</div>
<a id="a0f2a5e069a31348059ac9b2ee51a6378" name="a0f2a5e069a31348059ac9b2ee51a6378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f2a5e069a31348059ac9b2ee51a6378">&#9670;&#160;</a></span>column_copy() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::column_copy </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#aba03c94d01da4c440f052d704e14cdbe">DenseColumnBlockWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Index of the column. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1BlockWorkspace.html#a818b80115792369f2d48407b464c45d2">DenseColumnBlockWorkspace::length</a></code> values. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to the workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#a293cc62cc8a39e4ed66ab99e33cbcf27">dense_column_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The array pointed to by <code>buffer</code> is filled with a block of values from column <code>c</code>. <code>buffer</code> itself is returned. </dd></dl>

</div>
</div>
<a id="abdcac115721408d4b7991d7e60942028" name="abdcac115721408d4b7991d7e60942028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdcac115721408d4b7991d7e60942028">&#9670;&#160;</a></span>row_copy() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::row_copy </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a422993ac842bf906000d6ccebd0c86e6">DenseRowIndexWorkspace</a>&lt; IDX &gt; *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Index of the row. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1IndexWorkspace.html#a01e3f1497ad171dec73398872c4bd2aa">DenseRowIndexWorkspace::length</a></code> values. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to the workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#a675bf1ddd56c6eaf24b1100fdf7122a0">dense_row_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The array pointed to by <code>buffer</code> is filled with a block of values from row <code>r</code>. <code>buffer</code> itself is returned. </dd></dl>

</div>
</div>
<a id="abf8daacc683494db58d2f7ba9f57afd6" name="abf8daacc683494db58d2f7ba9f57afd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf8daacc683494db58d2f7ba9f57afd6">&#9670;&#160;</a></span>column_copy() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::column_copy </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a0029d39a6fa9fe81a5c85cdf744ebd68">DenseColumnIndexWorkspace</a>&lt; IDX &gt; *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Index of the column. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to an array with enough space for at least <code>ColumnIndexWorkspace&lt;IDX&gt;::length</code> values. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to the workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#a293cc62cc8a39e4ed66ab99e33cbcf27">dense_column_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The array pointed to by <code>buffer</code> is filled with a block of values from column <code>c</code>. <code>buffer</code> itself is returned. </dd></dl>

</div>
</div>
<a id="a45374d30647b638e8901e25be6cf84d2" name="a45374d30647b638e8901e25be6cf84d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45374d30647b638e8901e25be6cf84d2">&#9670;&#160;</a></span>row() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::row </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a3e4e7d9c0a3103fe35d6b6b2d5c8167e">DenseRowWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A more convenient but less efficient version of the <code><a class="el" href="classtatami_1_1Matrix.html#a34d3893b5a47b532d30db6780febdeff">row()</a></code> method. Callers do not have to supply <code>buffer</code>; instead a new allocation is performed every time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Index of the row. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to the workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#a675bf1ddd56c6eaf24b1100fdf7122a0">dense_row_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing the values of row <code>r</code>. </dd></dl>

</div>
</div>
<a id="ace200adc8b1c4237f3c734551ef046dc" name="ace200adc8b1c4237f3c734551ef046dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace200adc8b1c4237f3c734551ef046dc">&#9670;&#160;</a></span>column() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::column </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a0f817935c6e352d908090a67aff91f2a">DenseColumnWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A more convenient but (slightly) less efficient version of the <code><a class="el" href="classtatami_1_1Matrix.html#ada2c72ccd1628c96c40c601e6ceda654">column()</a></code> method. Callers do not have to supply <code>buffer</code>; instead a new allocation is performed every time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Index of the column. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to the workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#a293cc62cc8a39e4ed66ab99e33cbcf27">dense_column_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing the values of column <code>c</code>. </dd></dl>

</div>
</div>
<a id="a5d914be30f58811a241e1e5873ca88b8" name="a5d914be30f58811a241e1e5873ca88b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d914be30f58811a241e1e5873ca88b8">&#9670;&#160;</a></span>row() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::row </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a77143ea2ebbc50e952b51d640376b008">DenseRowBlockWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A more convenient but less efficient version of the <code><a class="el" href="classtatami_1_1Matrix.html#a34d3893b5a47b532d30db6780febdeff">row()</a></code> method. Callers do not have to supply <code>buffer</code>; instead a new allocation is performed every time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Index of the row. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to the workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#a675bf1ddd56c6eaf24b1100fdf7122a0">dense_row_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing all values of row <code>r</code>. </dd></dl>

</div>
</div>
<a id="af27b9c0d027c50e52ad3da0c2c23ad2c" name="af27b9c0d027c50e52ad3da0c2c23ad2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af27b9c0d027c50e52ad3da0c2c23ad2c">&#9670;&#160;</a></span>column() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::column </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#aba03c94d01da4c440f052d704e14cdbe">DenseColumnBlockWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A more convenient but less efficient version of the <code><a class="el" href="classtatami_1_1Matrix.html#ada2c72ccd1628c96c40c601e6ceda654">column()</a></code> method. Callers do not have to supply <code>buffer</code>; instead a new allocation is performed every time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Index of the column. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to the workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#a293cc62cc8a39e4ed66ab99e33cbcf27">dense_column_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing all values of column <code>c</code>. </dd></dl>

</div>
</div>
<a id="a21c54c0dd2a96ff1c25fba8665d73c38" name="a21c54c0dd2a96ff1c25fba8665d73c38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21c54c0dd2a96ff1c25fba8665d73c38">&#9670;&#160;</a></span>row() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::row </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a422993ac842bf906000d6ccebd0c86e6">DenseRowIndexWorkspace</a>&lt; IDX &gt; *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A more convenient but less efficient version of the <code><a class="el" href="classtatami_1_1Matrix.html#a34d3893b5a47b532d30db6780febdeff">row()</a></code> method. Callers do not have to supply <code>buffer</code>; instead a new allocation is performed every time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Index of the row. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to the workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#a675bf1ddd56c6eaf24b1100fdf7122a0">dense_row_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing all values of row <code>r</code>. </dd></dl>

</div>
</div>
<a id="a7633048ba93256affc03084e2da6f063" name="a7633048ba93256affc03084e2da6f063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7633048ba93256affc03084e2da6f063">&#9670;&#160;</a></span>column() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::column </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a0029d39a6fa9fe81a5c85cdf744ebd68">DenseColumnIndexWorkspace</a>&lt; IDX &gt; *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A more convenient but less efficient version of the <code><a class="el" href="classtatami_1_1Matrix.html#ada2c72ccd1628c96c40c601e6ceda654">column()</a></code> method. Callers do not have to supply <code>buffer</code>; instead a new allocation is performed every time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Index of the column. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to the workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#a293cc62cc8a39e4ed66ab99e33cbcf27">dense_column_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing all values of column <code>c</code>. </dd></dl>

</div>
</div>
<a id="a7bd5de94d342cf00f520a75e44f1112f" name="a7bd5de94d342cf00f520a75e44f1112f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bd5de94d342cf00f520a75e44f1112f">&#9670;&#160;</a></span>row() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::row </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>vbuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IDX *&#160;</td>
          <td class="paramname"><em>ibuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a94ca69af3e36f805e53326d4f8fc7cba">SparseRowWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><code>vbuffer</code> may not necessarily be filled upon extraction if a pointer can be returned to the underlying data store. This be checked by comparing the returned <code><a class="el" href="structtatami_1_1SparseRange.html#af58b18de602bb4e82e5223b0d7168a08">SparseRange::value</a></code> pointer to <code>vbuffer</code>; if they are the same, <code>vbuffer</code> has been filled. The same applies for <code>ibuffer</code> and the returned <code><a class="el" href="structtatami_1_1SparseRange.html#ac7dd33e84bcc456c04e848bdc51ade73">SparseRange::index</a></code> pointer.</p>
<p>Entries in the output <code>value</code> array are not guaranteed to be non-zero. If zeroes are explicitly initialized in the underlying representation, they will be reported here. However, one can safely assume that all values <em>not</em> in <code>value</code> are zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Index of the row. </td></tr>
    <tr><td class="paramname">vbuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1Matrix.html#a1049bd5cbe37b618db795787725930e4">ncol()</a></code> values. Ignored if <code>WorkspaceOptions::mode</code> was set to <code>SparseExtractMode::INDEX</code> or <code>SparseExtractMode::NONE</code> during construction of <code>work</code>. </td></tr>
    <tr><td class="paramname">ibuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1Matrix.html#a1049bd5cbe37b618db795787725930e4">ncol()</a></code> indices. Ignored if <code>WorkspaceOptions::mode</code> was set <code>SparseExtractMode::VALUE</code> or <code>SparseExtractMode::NONE</code> during construction of <code>work</code>. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to a workspace created with <code>row_workspace()</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structtatami_1_1SparseRange.html" title="A range of a sparse vector.">SparseRange</a></code> object describing the contents of row <code>r</code>. Either or both of <code>value</code> or <code>index</code> is set to <code>NULL</code> if extraction of that field is skipped, based on the setting of <code>WorkspaceOptions::mode</code> used to construct <code>work</code>. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#abbf885747c43013d44089ff5a9c000a5">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a1249547ab89c6cb992b5bcb44ca4800c">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a6b36082c050a8e78693c42a46e17fe49">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a42398ae39483fe45f2efbe87c167adcb">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#ab87651b086c8a44d007a406de59932bd">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a4d91e7b28fe6c2404ae194f38af269a0">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a1a4fec54c349e113b054ca073719b7a3">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a0ee30a28c914e66dcbbf0aca3c388e21">tatami::CompressedSparseMatrix&lt; ROW, T, IDX, U, V, W &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a7d2196b0e853c4a2a06607d2d0e288af">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a7190e3f62e97bcdad131ee55a329e43b">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#a964579588880eda635716494ae0c0009">tatami::VirtualDenseMatrix&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#a964579588880eda635716494ae0c0009">tatami::VirtualDenseMatrix&lt; T, IDX &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#a1df7c8e9ca242ac29714a0e1ace26e6a">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>.</p>

</div>
</div>
<a id="a809134c6013d89008a5cdc0e2f153fe8" name="a809134c6013d89008a5cdc0e2f153fe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a809134c6013d89008a5cdc0e2f153fe8">&#9670;&#160;</a></span>column() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::column </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>vbuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IDX *&#160;</td>
          <td class="paramname"><em>ibuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a4182e7ceb1cab3083cfec53b9dc5d561">SparseColumnWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><code>vbuffer</code> may not necessarily be filled upon extraction if a pointer can be returned to the underlying data store. This be checked by comparing the returned <code><a class="el" href="structtatami_1_1SparseRange.html#af58b18de602bb4e82e5223b0d7168a08">SparseRange::value</a></code> pointer to <code>vbuffer</code>; if they are the same, <code>vbuffer</code> has been filled. The same applies for <code>ibuffer</code> and the returned <code><a class="el" href="structtatami_1_1SparseRange.html#ac7dd33e84bcc456c04e848bdc51ade73">SparseRange::index</a></code> pointer.</p>
<p>Entries in the output <code>value</code> array are not guaranteed to be non-zero. If zeroes are explicitly initialized in the underlying representation, they will be reported here. However, one can safely assume that all values <em>not</em> in <code>value</code> are zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Index of the column. </td></tr>
    <tr><td class="paramname">vbuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1Matrix.html#a48e1342556ff97cc8367b25d244195a9">nrow()</a></code> values. Ignored if <code>WorkspaceOptions::mode</code> was set to <code>SparseExtractMode::INDEX</code> or <code>SparseExtractMode::NONE</code> during construction of <code>work</code>. </td></tr>
    <tr><td class="paramname">ibuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1Matrix.html#a48e1342556ff97cc8367b25d244195a9">nrow()</a></code> indices. Ignored if <code>WorkspaceOptions::mode</code> was set <code>SparseExtractMode::VALUE</code> or <code>SparseExtractMode::NONE</code> during construction of <code>work</code>. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to a workspace.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structtatami_1_1SparseRange.html" title="A range of a sparse vector.">SparseRange</a></code> object describing the contents of column <code>c</code>. Either or both of <code>value</code> or <code>index</code> is set to <code>NULL</code> if extraction of that field is skipped, based on the setting of <code>WorkspaceOptions::mode</code> used to construct <code>work</code>. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#af9d07881a5501e04fd1b9afe61ea3d68">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a25beaecaf08f7ddee634b08fdb38bcf9">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a24c06dd7f5703a24040cc9225ad5399a">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a9fe03690563445942cbb85f1b99acc56">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#ae66b2243065a61730af6adf7923e2747">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#aa5ef71a29574a8d2922c6c61d72e18d1">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a1daa89d1f0d78c738e2835fe38234f53">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a5b9a118beb1862d51ec80bc634a6151d">tatami::CompressedSparseMatrix&lt; ROW, T, IDX, U, V, W &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#aa79b2972e32dc1b5c48b612f358b23c4">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a8716e5ed72a46411c363da54fb2a0093">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#ae4487d2b650b9a1f231e70e7a9ebd3c9">tatami::VirtualDenseMatrix&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#ae4487d2b650b9a1f231e70e7a9ebd3c9">tatami::VirtualDenseMatrix&lt; T, IDX &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#a7854fd944e7e03f4e17d07e6251ab064">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>.</p>

</div>
</div>
<a id="aa17ffa61ac22a28ba583739c32a73a56" name="aa17ffa61ac22a28ba583739c32a73a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa17ffa61ac22a28ba583739c32a73a56">&#9670;&#160;</a></span>row() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::row </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>vbuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IDX *&#160;</td>
          <td class="paramname"><em>ibuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a1798a0b6bf7822a590baee156371c352">SparseRowBlockWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><code>vbuffer</code> may not necessarily be filled upon extraction if a pointer can be returned to the underlying data store. This be checked by comparing the returned <code><a class="el" href="structtatami_1_1SparseRange.html#af58b18de602bb4e82e5223b0d7168a08">SparseRange::value</a></code> pointer to <code>vbuffer</code>; if they are the same, <code>vbuffer</code> has been filled. The same applies for <code>ibuffer</code> and the returned <code><a class="el" href="structtatami_1_1SparseRange.html#ac7dd33e84bcc456c04e848bdc51ade73">SparseRange::index</a></code> pointer.</p>
<p>Entries in the output <code>value</code> array are not guaranteed to be non-zero. If zeroes are explicitly initialized in the underlying representation, they will be reported here. However, one can safely assume that all values <em>not</em> in <code>value</code> are zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Index of the row. </td></tr>
    <tr><td class="paramname">vbuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1BlockWorkspace.html#a818b80115792369f2d48407b464c45d2">SparseRowBlockWorkspace::length</a></code> values. Ignored if <code>WorkspaceOptions::mode</code> was set to <code>SparseExtractMode::INDEX</code> or <code>SparseExtractMode::NONE</code> during construction of <code>work</code>. </td></tr>
    <tr><td class="paramname">ibuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1BlockWorkspace.html#a818b80115792369f2d48407b464c45d2">SparseRowBlockWorkspace::length</a></code> indices. Ignored if <code>WorkspaceOptions::mode</code> was set <code>SparseExtractMode::VALUE</code> or <code>SparseExtractMode::NONE</code> during construction of <code>work</code>. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to a workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#a4a4db842e8742bb6eb9d3456ad9628b2">sparse_row_workspace()</a></code>. </td></tr>
    <tr><td class="paramname">sorted</td><td>Should the non-zero elements be sorted by their indices?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structtatami_1_1SparseRange.html" title="A range of a sparse vector.">SparseRange</a></code> object describing the contents of a block of columns in row <code>r</code>. Either or both of <code>value</code> or <code>index</code> is set to <code>NULL</code> if extraction of that field is skipped, based on the setting of <code>WorkspaceOptions::mode</code> used to construct <code>work</code>. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#a224eeaefb6266949f98b6e9821251256">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#afaa9fde4be775da43fae09941e95a848">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a42ae688904ffaca6b2d1ea508d26c8b8">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a696f001d12d93fbe7d33de3d693d56a8">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#ae663a501d3dc0a3c47637e7d55b538d0">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a7702fb63c712acc52dc3b3f745e3fd0c">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a37a1909accd05bb9c6b694d78b577f5c">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a890984b3ba5431774aed912bdbcf5eff">tatami::CompressedSparseMatrix&lt; ROW, T, IDX, U, V, W &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a8f3cfcc30b9a4d9c2c10875d3e007647">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a5791086e3d1570e5105e8e3d93a1cec7">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#a082c66ed0a35dba70c3aa7d1878a08e0">tatami::VirtualDenseMatrix&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#a082c66ed0a35dba70c3aa7d1878a08e0">tatami::VirtualDenseMatrix&lt; T, IDX &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#a673a1ecd9b93f6e879182fbfc0dc29f2">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>.</p>

</div>
</div>
<a id="a8bd7375e9b578e2369b335b5cd70875e" name="a8bd7375e9b578e2369b335b5cd70875e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bd7375e9b578e2369b335b5cd70875e">&#9670;&#160;</a></span>column() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::column </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>vbuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IDX *&#160;</td>
          <td class="paramname"><em>ibuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#ac85be5029bb03a836b329b566c4d89c2">SparseColumnBlockWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><code>vbuffer</code> may not necessarily be filled upon extraction if a pointer can be returned to the underlying data store. This be checked by comparing the returned <code><a class="el" href="structtatami_1_1SparseRange.html#af58b18de602bb4e82e5223b0d7168a08">SparseRange::value</a></code> pointer to <code>vbuffer</code>; if they are the same, <code>vbuffer</code> has been filled. The same applies for <code>ibuffer</code> and the returned <code><a class="el" href="structtatami_1_1SparseRange.html#ac7dd33e84bcc456c04e848bdc51ade73">SparseRange::index</a></code> pointer.</p>
<p>Entries in the output <code>value</code> array are not guaranteed to be non-zero. If zeroes are explicitly initialized in the underlying representation, they will be reported here. However, one can safely assume that all values <em>not</em> in <code>value</code> are zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Index of the column. </td></tr>
    <tr><td class="paramname">vbuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1BlockWorkspace.html#a818b80115792369f2d48407b464c45d2">SparseColumnBlockWorkspace::length</a></code> values. Ignored if <code>WorkspaceOptions::mode</code> was set to <code>SparseExtractMode::INDEX</code> or <code>SparseExtractMode::NONE</code> during construction of <code>work</code>. </td></tr>
    <tr><td class="paramname">ibuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1BlockWorkspace.html#a818b80115792369f2d48407b464c45d2">SparseColumnBlockWorkspace::length</a></code> indices. Ignored if <code>WorkspaceOptions::mode</code> was set <code>SparseExtractMode::VALUE</code> or <code>SparseExtractMode::NONE</code> during construction of <code>work</code>. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to a workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#ae8a1dd4ef8814f3e748dc6bc9d7c6828">sparse_column_workspace()</a></code>. </td></tr>
    <tr><td class="paramname">sorted</td><td>Should the non-zero elements be sorted by their indices?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structtatami_1_1SparseRange.html" title="A range of a sparse vector.">SparseRange</a></code> object describing the contents of a block of rows in column <code>c</code>. Either or both of <code>value</code> or <code>index</code> is set to <code>NULL</code> if extraction of that field is skipped, based on the setting of <code>WorkspaceOptions::mode</code> used to construct <code>work</code>. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#add854ccb10cbf16eef50a8843a1163ed">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a4fd754ce608c068c7c5d7065f6be89fe">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a1f797393ea2312523c5ab45340715d54">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#acd6379a9c995ebc604d43753e843e896">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a4f9a7982a220187e44954d49d88994cc">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a64a81c8ca42e13fbc6d59bc86f89d3c2">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#aa3a3884b0f0ebf1eedf84aedd7eb373c">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a2821efe775bf7f1f89c98c339c7a5b01">tatami::CompressedSparseMatrix&lt; ROW, T, IDX, U, V, W &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a912aaeb37d4e4b19dee26d63e5db9120">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a62eeeccdf4754a6f34bfa179ed2b5994">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#ad43b83a6c407571a07fdff8a0139bdbb">tatami::VirtualDenseMatrix&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#ad43b83a6c407571a07fdff8a0139bdbb">tatami::VirtualDenseMatrix&lt; T, IDX &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#a4092230410843eb6b75f132cf7103a89">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>.</p>

</div>
</div>
<a id="a6e4f5da8caf94a54cb94e2ff3e602ab6" name="a6e4f5da8caf94a54cb94e2ff3e602ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4f5da8caf94a54cb94e2ff3e602ab6">&#9670;&#160;</a></span>row() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::row </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>vbuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IDX *&#160;</td>
          <td class="paramname"><em>ibuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a1edbb6992ee134f2481b6227300322ce">SparseRowIndexWorkspace</a>&lt; IDX &gt; *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Entries in the output <code>value</code> array are not guaranteed to be non-zero. If zeroes are explicitly initialized in the underlying representation, they will be reported here. However, one can safely assume that all values <em>not</em> in <code>value</code> are zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Index of the row. </td></tr>
    <tr><td class="paramname">vbuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1IndexWorkspace.html#a01e3f1497ad171dec73398872c4bd2aa">SparseRowIndexWorkspace::length</a></code> values. Ignored if <code>WorkspaceOptions::mode</code> was set to <code>SparseExtractMode::INDEX</code> or <code>SparseExtractMode::NONE</code> during construction of <code>work</code>. </td></tr>
    <tr><td class="paramname">ibuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1IndexWorkspace.html#a01e3f1497ad171dec73398872c4bd2aa">SparseRowIndexWorkspace::length</a></code> indices. Ignored if <code>WorkspaceOptions::mode</code> was set <code>SparseExtractMode::VALUE</code> or <code>SparseExtractMode::NONE</code> during construction of <code>work</code>. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to a workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#a4a4db842e8742bb6eb9d3456ad9628b2">sparse_row_workspace()</a></code>. </td></tr>
    <tr><td class="paramname">sorted</td><td>Should the non-zero elements be sorted by their indices?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structtatami_1_1SparseRange.html" title="A range of a sparse vector.">SparseRange</a></code> object describing the contents of a subset of columns in row <code>r</code>. Either or both of <code>value</code> or <code>index</code> is set to <code>NULL</code> if extraction of that field is skipped, based on the setting of <code>WorkspaceOptions::mode</code> used to construct <code>work</code>. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#a77230fc5e84156583150ee3dd1b38f41">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#aef8cdee0565429e5e3b8fd4c34f83083">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a3eb7feed4c034528ac23735f79ea74ae">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a36c16a2532d73f369b71f1cdcca82710">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a76b597ba5d221c6a3a731d95d21bac6f">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a7757c5a70ff0e364198a86429dbf295d">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a35ec5a8e54e904fd80074be733ecbbf2">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a4b1ec30f3192a418bd6ccba1567c2e72">tatami::CompressedSparseMatrix&lt; ROW, T, IDX, U, V, W &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a3c929a6b814e9fcb16f4877ab2f299b6">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#ab64b8189d8d38f9ed2149fe0777de46f">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#ac2b708caa0ec044706c44b5650cfc4cb">tatami::VirtualDenseMatrix&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#ac2b708caa0ec044706c44b5650cfc4cb">tatami::VirtualDenseMatrix&lt; T, IDX &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#a384db02109ecbebe0cc0adecce35cd40">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>.</p>

</div>
</div>
<a id="a57915eab83c7caafac71365c7b56a2a8" name="a57915eab83c7caafac71365c7b56a2a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57915eab83c7caafac71365c7b56a2a8">&#9670;&#160;</a></span>column() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::column </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>vbuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IDX *&#160;</td>
          <td class="paramname"><em>ibuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a54ba456fea7d955f10d55792cbcc7a58">SparseColumnIndexWorkspace</a>&lt; IDX &gt; *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Entries in the output <code>value</code> array are not guaranteed to be non-zero. If zeroes are explicitly initialized in the underlying representation, they will be reported here. However, one can safely assume that all values <em>not</em> in <code>value</code> are zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Index of the column. </td></tr>
    <tr><td class="paramname">vbuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1IndexWorkspace.html#a01e3f1497ad171dec73398872c4bd2aa">SparseColumnIndexWorkspace::length</a></code> values. Ignored if <code>WorkspaceOptions::mode</code> was set to <code>SparseExtractMode::INDEX</code> or <code>SparseExtractMode::NONE</code> during construction of <code>work</code>. </td></tr>
    <tr><td class="paramname">ibuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1IndexWorkspace.html#a01e3f1497ad171dec73398872c4bd2aa">SparseColumnIndexWorkspace::length</a></code> indices. Ignored if <code>WorkspaceOptions::mode</code> was set <code>SparseExtractMode::VALUE</code> or <code>SparseExtractMode::NONE</code> during construction of <code>work</code>. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to a workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#ae8a1dd4ef8814f3e748dc6bc9d7c6828">sparse_column_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structtatami_1_1SparseRange.html" title="A range of a sparse vector.">SparseRange</a></code> object describing the contents of a subset of rows in column <code>c</code>. Either or both of <code>value</code> or <code>index</code> is set to <code>NULL</code> if extraction of that field is skipped, based on the setting of <code>WorkspaceOptions::mode</code> used to construct <code>work</code>. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#aa4d26f0314b00655180e63aab2e45ed9">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a8c3cabb60630b76c007f65426b4404ab">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a5b350ef44e5fb786c4bdb6418a4420e5">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a0a161984a155bd3276abd863b34915fa">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a4ab707b909eca41c0d726c0a0c825a75">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a48dadb6cad7f769f204a6da3af48b06a">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a333f6cc6b0702151095c0ba109d28396">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a47e7e0943d8ee7a2b27259ebb90fa522">tatami::CompressedSparseMatrix&lt; ROW, T, IDX, U, V, W &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#aafa577fe9da3818ef86190b32df044db">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a8a633de0b2e7f61b5b33f6b74072ca8c">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#a87c05f45eb2ed34e837bffc3807194e9">tatami::VirtualDenseMatrix&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#a87c05f45eb2ed34e837bffc3807194e9">tatami::VirtualDenseMatrix&lt; T, IDX &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#a2ea854a2871857fed43dcf433aada655">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>.</p>

</div>
</div>
<a id="a64006bdf017d48760f4b1ac4e31bac87" name="a64006bdf017d48760f4b1ac4e31bac87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64006bdf017d48760f4b1ac4e31bac87">&#9670;&#160;</a></span>row_copy() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::row_copy </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>vbuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IDX *&#160;</td>
          <td class="paramname"><em>ibuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a94ca69af3e36f805e53326d4f8fc7cba">SparseRowWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Index of the row. </td></tr>
    <tr><td class="paramname">vbuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1Matrix.html#a1049bd5cbe37b618db795787725930e4">ncol()</a></code> values. Ignored if <code>WorkspaceOptions::mode</code> was set to <code>SparseExtractMode::INDEX</code> or <code>SparseExtractMode::NONE</code> during construction of <code>work</code>. </td></tr>
    <tr><td class="paramname">ibuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1Matrix.html#a1049bd5cbe37b618db795787725930e4">ncol()</a></code> indices. Ignored if <code>WorkspaceOptions::mode</code> was set to <code>SparseExtractMode::VALUE</code> or <code>SparseExtractMode::NONE</code> during construction of <code>work</code>. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to a workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#a4a4db842e8742bb6eb9d3456ad9628b2">sparse_row_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structtatami_1_1SparseRange.html" title="A range of a sparse vector.">SparseRange</a></code> object describing the contents of row <code>r</code>. Either or both of <code>value</code> or <code>index</code> may be invalid, depending on the setting of <code>WorkspaceOptions::mode</code> used to construct <code>work</code>. If non-<code>NULL</code>, they will be set to <code>vbuffer</code> and <code>ibuffer</code>, which will be filled with values and indices respectively. </dd></dl>

</div>
</div>
<a id="a51995cb3d6c2bbcface88087dd7f2e4a" name="a51995cb3d6c2bbcface88087dd7f2e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51995cb3d6c2bbcface88087dd7f2e4a">&#9670;&#160;</a></span>column_copy() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::column_copy </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>vbuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IDX *&#160;</td>
          <td class="paramname"><em>ibuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a4182e7ceb1cab3083cfec53b9dc5d561">SparseColumnWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Index of the column. </td></tr>
    <tr><td class="paramname">vbuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1Matrix.html#a48e1342556ff97cc8367b25d244195a9">nrow()</a></code> values. Ignored if <code>WorkspaceOptions::mode</code> was set to <code>SparseExtractMode::INDEX</code> or <code>SparseExtractMode::NONE</code> during construction of <code>work</code>. </td></tr>
    <tr><td class="paramname">ibuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1Matrix.html#a48e1342556ff97cc8367b25d244195a9">nrow()</a></code> indices. Ignored if <code>WorkspaceOptions::mode</code> was set to <code>SparseExtractMode::VALUE</code> or <code>SparseExtractMode::NONE</code> during construction of <code>work</code>. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to a workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#ae8a1dd4ef8814f3e748dc6bc9d7c6828">sparse_column_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structtatami_1_1SparseRange.html" title="A range of a sparse vector.">SparseRange</a></code> object describing the contents of column <code>c</code>. Either or both of <code>value</code> or <code>index</code> may be invalid, depending on the setting of <code>WorkspaceOptions::mode</code> used to construct <code>work</code>. If non-<code>NULL</code>, they will be set to <code>vbuffer</code> and <code>ibuffer</code>, which will be filled with values and indices respectively. </dd></dl>

</div>
</div>
<a id="a4202cc7b5662376311c683a799a34a6c" name="a4202cc7b5662376311c683a799a34a6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4202cc7b5662376311c683a799a34a6c">&#9670;&#160;</a></span>row_copy() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::row_copy </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>vbuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IDX *&#160;</td>
          <td class="paramname"><em>ibuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a1798a0b6bf7822a590baee156371c352">SparseRowBlockWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Index of the row. </td></tr>
    <tr><td class="paramname">vbuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1BlockWorkspace.html#a818b80115792369f2d48407b464c45d2">SparseRowBlockWorkspace::length</a></code> values. Ignored if <code>WorkspaceOptions::mode</code> was set to <code>SparseExtractMode::INDEX</code> or <code>SparseExtractMode::NONE</code> during construction of <code>work</code>. </td></tr>
    <tr><td class="paramname">ibuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1BlockWorkspace.html#a818b80115792369f2d48407b464c45d2">SparseRowBlockWorkspace::length</a></code> indices. Ignored if <code>WorkspaceOptions::mode</code> was set to <code>SparseExtractMode::VALUE</code> or <code>SparseExtractMode::NONE</code> during construction of <code>work</code>. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to a workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#a4a4db842e8742bb6eb9d3456ad9628b2">sparse_row_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structtatami_1_1SparseRange.html" title="A range of a sparse vector.">SparseRange</a></code> object describing the contents of a block of columns in row <code>r</code>. Either or both of <code>value</code> or <code>index</code> may be invalid, depending on the setting of <code>WorkspaceOptions::mode</code> used to construct <code>work</code>. If non-<code>NULL</code>, they will be set to <code>vbuffer</code> and <code>ibuffer</code>, which will be filled with values and indices respectively. </dd></dl>

</div>
</div>
<a id="ae7c1c4c8de56f48849cae9aea92df695" name="ae7c1c4c8de56f48849cae9aea92df695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7c1c4c8de56f48849cae9aea92df695">&#9670;&#160;</a></span>column_copy() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::column_copy </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>vbuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IDX *&#160;</td>
          <td class="paramname"><em>ibuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#ac85be5029bb03a836b329b566c4d89c2">SparseColumnBlockWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Index of the column. </td></tr>
    <tr><td class="paramname">vbuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1BlockWorkspace.html#a818b80115792369f2d48407b464c45d2">SparseColumnBlockWorkspace::length</a></code> values. Ignored if <code>WorkspaceOptions::mode</code> was set to <code>SparseExtractMode::INDEX</code> or <code>SparseExtractMode::NONE</code> during construction of <code>work</code>. </td></tr>
    <tr><td class="paramname">ibuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1BlockWorkspace.html#a818b80115792369f2d48407b464c45d2">SparseColumnBlockWorkspace::length</a></code> indices. Ignored if <code>WorkspaceOptions::mode</code> was set to <code>SparseExtractMode::VALUE</code> or <code>SparseExtractMode::NONE</code> during construction of <code>work</code>. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to a workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#a4a4db842e8742bb6eb9d3456ad9628b2">sparse_row_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structtatami_1_1SparseRange.html" title="A range of a sparse vector.">SparseRange</a></code> object describing the contents of a block of rows in column <code>c</code>. Either or both of <code>value</code> or <code>index</code> may be invalid, depending on the setting of <code>WorkspaceOptions::mode</code> used to construct <code>work</code>. If non-<code>NULL</code>, they will be set to <code>vbuffer</code> and <code>ibuffer</code>, which will be filled with values and indices respectively. </dd></dl>

</div>
</div>
<a id="a3c50c971e2e058faff45de7681f82ded" name="a3c50c971e2e058faff45de7681f82ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c50c971e2e058faff45de7681f82ded">&#9670;&#160;</a></span>row_copy() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::row_copy </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>vbuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IDX *&#160;</td>
          <td class="paramname"><em>ibuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a1edbb6992ee134f2481b6227300322ce">SparseRowIndexWorkspace</a>&lt; IDX &gt; *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Index of the row. </td></tr>
    <tr><td class="paramname">vbuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1IndexWorkspace.html#a01e3f1497ad171dec73398872c4bd2aa">SparseRowIndexWorkspace::length</a></code> values. Ignored if <code>WorkspaceOptions::mode</code> was set to <code>SparseExtractMode::INDEX</code> or <code>SparseExtractMode::NONE</code> during construction of <code>work</code>. </td></tr>
    <tr><td class="paramname">ibuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1IndexWorkspace.html#a01e3f1497ad171dec73398872c4bd2aa">SparseRowIndexWorkspace::length</a></code> indices. Ignored if <code>WorkspaceOptions::mode</code> was set to <code>SparseExtractMode::VALUE</code> or <code>SparseExtractMode::NONE</code> during construction of <code>work</code>. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to a workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#a4a4db842e8742bb6eb9d3456ad9628b2">sparse_row_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structtatami_1_1SparseRange.html" title="A range of a sparse vector.">SparseRange</a></code> object describing the contents of a subset of columns in row <code>r</code>. Either or both of <code>value</code> or <code>index</code> may be invalid, depending on the setting of <code>WorkspaceOptions::mode</code> used to construct <code>work</code>. If non-<code>NULL</code>, they will be set to <code>vbuffer</code> and <code>ibuffer</code>, which will be filled with values and indices respectively. </dd></dl>

</div>
</div>
<a id="a41742465767476b745f214080163b3f2" name="a41742465767476b745f214080163b3f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41742465767476b745f214080163b3f2">&#9670;&#160;</a></span>column_copy() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::column_copy </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>vbuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IDX *&#160;</td>
          <td class="paramname"><em>ibuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a54ba456fea7d955f10d55792cbcc7a58">SparseColumnIndexWorkspace</a>&lt; IDX &gt; *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Index of the column. </td></tr>
    <tr><td class="paramname">vbuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1IndexWorkspace.html#a01e3f1497ad171dec73398872c4bd2aa">SparseColumnIndexWorkspace::length</a></code> values. Ignored if <code>WorkspaceOptions::mode</code> was set to <code>SparseExtractMode::INDEX</code> or <code>SparseExtractMode::NONE</code> during construction of <code>work</code>. </td></tr>
    <tr><td class="paramname">ibuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1IndexWorkspace.html#a01e3f1497ad171dec73398872c4bd2aa">SparseColumnIndexWorkspace::length</a></code> indices. Ignored if <code>WorkspaceOptions::mode</code> was set to <code>SparseExtractMode::VALUE</code> or <code>SparseExtractMode::NONE</code> during construction of <code>work</code>. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to a workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#a4a4db842e8742bb6eb9d3456ad9628b2">sparse_row_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structtatami_1_1SparseRange.html" title="A range of a sparse vector.">SparseRange</a></code> object describing the contents of a subset of rows in column <code>c</code>. Either or both of <code>value</code> or <code>index</code> may be invalid, depending on the setting of <code>WorkspaceOptions::mode</code> used to construct <code>work</code>. If non-<code>NULL</code>, they will be set to <code>vbuffer</code> and <code>ibuffer</code>, which will be filled with values and indices respectively. </dd></dl>

</div>
</div>
<a id="a5a548e337fa5829bc8be7fb482992ca7" name="a5a548e337fa5829bc8be7fb482992ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a548e337fa5829bc8be7fb482992ca7">&#9670;&#160;</a></span>row() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1SparseRangeCopy.html">SparseRangeCopy</a>&lt; T, IDX &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::row </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a94ca69af3e36f805e53326d4f8fc7cba">SparseRowWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A more convenient but less efficient version of the <code><a class="el" href="classtatami_1_1Matrix.html#a34d3893b5a47b532d30db6780febdeff">row()</a></code> method. Callers do not have to supply the buffers; instead a new allocation is performed every time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Index of the row. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to a workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#a4a4db842e8742bb6eb9d3456ad9628b2">sparse_row_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structtatami_1_1SparseRangeCopy.html" title="A range of a sparse vector with copying.">SparseRangeCopy</a></code> object containing the contents of row <code>r</code>. </dd></dl>

</div>
</div>
<a id="aaa329d34be396ce9cca9077f47149d2a" name="aaa329d34be396ce9cca9077f47149d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa329d34be396ce9cca9077f47149d2a">&#9670;&#160;</a></span>column() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1SparseRangeCopy.html">SparseRangeCopy</a>&lt; T, IDX &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::column </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a4182e7ceb1cab3083cfec53b9dc5d561">SparseColumnWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A more convenient but less efficient version of the <code><a class="el" href="classtatami_1_1Matrix.html#ada2c72ccd1628c96c40c601e6ceda654">column()</a></code> method. Callers do not have to supply the buffers; instead a new allocation is performed every time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Index of the column. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to a workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#ae8a1dd4ef8814f3e748dc6bc9d7c6828">sparse_column_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structtatami_1_1SparseRangeCopy.html" title="A range of a sparse vector with copying.">SparseRangeCopy</a></code> object containing the contents of column <code>c</code>. </dd></dl>

</div>
</div>
<a id="a68b3b7cd6f455fcdca738c1cc8b4755d" name="a68b3b7cd6f455fcdca738c1cc8b4755d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68b3b7cd6f455fcdca738c1cc8b4755d">&#9670;&#160;</a></span>row() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1SparseRangeCopy.html">SparseRangeCopy</a>&lt; T, IDX &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::row </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a1798a0b6bf7822a590baee156371c352">SparseRowBlockWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A more convenient but less efficient version of the <code><a class="el" href="classtatami_1_1Matrix.html#a34d3893b5a47b532d30db6780febdeff">row()</a></code> method. Callers do not have to supply the buffers; instead a new allocation is performed every time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Index of the row. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to a workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#a4a4db842e8742bb6eb9d3456ad9628b2">sparse_row_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structtatami_1_1SparseRangeCopy.html" title="A range of a sparse vector with copying.">SparseRangeCopy</a></code> object containing the contents of a block of columns in row <code>r</code>. </dd></dl>

</div>
</div>
<a id="a2212303b5cdddfe60e7d5e882af126d8" name="a2212303b5cdddfe60e7d5e882af126d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212303b5cdddfe60e7d5e882af126d8">&#9670;&#160;</a></span>column() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1SparseRangeCopy.html">SparseRangeCopy</a>&lt; T, IDX &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::column </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#ac85be5029bb03a836b329b566c4d89c2">SparseColumnBlockWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A more convenient but less efficient version of the <code><a class="el" href="classtatami_1_1Matrix.html#ada2c72ccd1628c96c40c601e6ceda654">column()</a></code> method. Callers do not have to supply the buffers; instead a new allocation is performed every time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Index of the column. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to a workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#ae8a1dd4ef8814f3e748dc6bc9d7c6828">sparse_column_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structtatami_1_1SparseRangeCopy.html" title="A range of a sparse vector with copying.">SparseRangeCopy</a></code> object containing the contents of a block of rows in column <code>c</code>. </dd></dl>

</div>
</div>
<a id="a2b182cbbed5a6fa81c0873078c6fa693" name="a2b182cbbed5a6fa81c0873078c6fa693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b182cbbed5a6fa81c0873078c6fa693">&#9670;&#160;</a></span>row() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1SparseRangeCopy.html">SparseRangeCopy</a>&lt; T, IDX &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::row </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a1edbb6992ee134f2481b6227300322ce">SparseRowIndexWorkspace</a>&lt; IDX &gt; *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A more convenient but less efficient version of the <code><a class="el" href="classtatami_1_1Matrix.html#a34d3893b5a47b532d30db6780febdeff">row()</a></code> method. Callers do not have to supply the buffers; instead a new allocation is performed every time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Index of the row. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to a workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#a4a4db842e8742bb6eb9d3456ad9628b2">sparse_row_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structtatami_1_1SparseRangeCopy.html" title="A range of a sparse vector with copying.">SparseRangeCopy</a></code> object containing the contents of a subset of columns in row <code>r</code>. </dd></dl>

</div>
</div>
<a id="a06d2cbfca03430d24be093142afd7cf6" name="a06d2cbfca03430d24be093142afd7cf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06d2cbfca03430d24be093142afd7cf6">&#9670;&#160;</a></span>column() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1SparseRangeCopy.html">SparseRangeCopy</a>&lt; T, IDX &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::column </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a54ba456fea7d955f10d55792cbcc7a58">SparseColumnIndexWorkspace</a>&lt; IDX &gt; *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A more convenient but less efficient version of the <code><a class="el" href="classtatami_1_1Matrix.html#ada2c72ccd1628c96c40c601e6ceda654">column()</a></code> method. Callers do not have to supply the buffers; instead a new allocation is performed every time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Index of the column. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to a workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#ae8a1dd4ef8814f3e748dc6bc9d7c6828">sparse_column_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structtatami_1_1SparseRangeCopy.html" title="A range of a sparse vector with copying.">SparseRangeCopy</a></code> object containing the contents of a subset of rows in column <code>c</code>. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>tatami/base/<a class="el" href="Matrix_8hpp_source.html">Matrix.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
