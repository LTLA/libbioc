<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tatami: tatami::Matrix&lt; T, IDX &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tatami
   </div>
   <div id="projectbrief">C++ API for different matrix representations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetatami.html">tatami</a></li><li class="navelem"><a class="el" href="classtatami_1_1Matrix.html">Matrix</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classtatami_1_1Matrix-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">tatami::Matrix&lt; T, IDX &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Virtual class for a matrix with a defined type.  
 <a href="classtatami_1_1Matrix.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Matrix_8hpp_source.html">Matrix.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for tatami::Matrix&lt; T, IDX &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classtatami_1_1Matrix__inherit__graph.png" border="0" usemap="#atatami_1_1Matrix_3_01T_00_01IDX_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="atatami_1_1Matrix_3_01T_00_01IDX_01_4_inherit__map" id="atatami_1_1Matrix_3_01T_00_01IDX_01_4_inherit__map">
<area shape="rect" title="Virtual class for a matrix with a defined type." alt="" coords="5,49,128,89"/>
<area shape="rect" href="classtatami_1_1CompressedSparseMatrix.html" title="Compressed sparse matrix representation." alt="" coords="176,5,355,60"/>
<area shape="rect" href="classtatami_1_1DenseMatrix.html" title="Dense matrix representation." alt="" coords="197,85,333,125"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8f97683e1dbef330caadc258b0c404b5"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a8f97683e1dbef330caadc258b0c404b5">data_type</a></td></tr>
<tr class="separator:a8f97683e1dbef330caadc258b0c404b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b8f1870fe7f6c40fa5426f11ff82f4"><td class="memItemLeft" align="right" valign="top">typedef IDX&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a09b8f1870fe7f6c40fa5426f11ff82f4">index_type</a></td></tr>
<tr class="separator:a09b8f1870fe7f6c40fa5426f11ff82f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6d505c205ae7ff6fb225450fca5f4307"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a6d505c205ae7ff6fb225450fca5f4307">Matrix</a> (<a class="el" href="classtatami_1_1Matrix.html">Matrix</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a6d505c205ae7ff6fb225450fca5f4307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a3bbc3ba8681438f51a48f5f40b42a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1Matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a54a3bbc3ba8681438f51a48f5f40b42a">operator=</a> (<a class="el" href="classtatami_1_1Matrix.html">Matrix</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a54a3bbc3ba8681438f51a48f5f40b42a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d8e8cfd07b96e1a604cdccd3a8efaf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#ac7d8e8cfd07b96e1a604cdccd3a8efaf">Matrix</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a> &amp;)=default</td></tr>
<tr class="separator:ac7d8e8cfd07b96e1a604cdccd3a8efaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9913765cad84cb6d43271ee213a9d019"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1Matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a9913765cad84cb6d43271ee213a9d019">operator=</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a> &amp;)=default</td></tr>
<tr class="separator:a9913765cad84cb6d43271ee213a9d019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e1342556ff97cc8367b25d244195a9"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a48e1342556ff97cc8367b25d244195a9">nrow</a> () const =0</td></tr>
<tr class="separator:a48e1342556ff97cc8367b25d244195a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1049bd5cbe37b618db795787725930e4"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a1049bd5cbe37b618db795787725930e4">ncol</a> () const =0</td></tr>
<tr class="separator:a1049bd5cbe37b618db795787725930e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f69722541e0ed9a8f19aad2d44f1c4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a05f69722541e0ed9a8f19aad2d44f1c4">sparse</a> () const</td></tr>
<tr class="separator:a05f69722541e0ed9a8f19aad2d44f1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac31ddc309419b4b2f6a2d0a01837e7a3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#ac31ddc309419b4b2f6a2d0a01837e7a3">prefer_rows</a> () const</td></tr>
<tr class="separator:ac31ddc309419b4b2f6a2d0a01837e7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0c04c5b051451af78a64e517aae0c1"><td class="memItemLeft" align="right" valign="top">virtual std::pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a8e0c04c5b051451af78a64e517aae0c1">dimension_preference</a> () const</td></tr>
<tr class="separator:a8e0c04c5b051451af78a64e517aae0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa62c3f22f2f82f93b81596caf27ededd"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a4a4650628564a58b961b7df8e2a83ac8">RowWorkspace</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#aa62c3f22f2f82f93b81596caf27ededd">new_row_workspace</a> (bool cache=false) const =0</td></tr>
<tr class="separator:aa62c3f22f2f82f93b81596caf27ededd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0dbb0132e1b132a9164c20729e21d5"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a60a9117c28a1c409e7b7b3836be9531a">ColumnWorkspace</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a8e0dbb0132e1b132a9164c20729e21d5">new_column_workspace</a> (bool cache=false) const =0</td></tr>
<tr class="separator:a8e0dbb0132e1b132a9164c20729e21d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7287719dc760c70e891586dd946f8443"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a100a9dd1056492a6687199cc1b341c08">RowBlockWorkspace</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a7287719dc760c70e891586dd946f8443">new_row_workspace</a> (size_t start, size_t length, bool cache=false) const =0</td></tr>
<tr class="separator:a7287719dc760c70e891586dd946f8443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c16c916c50066e637a83c97b73b627"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a1f0f1615a5c86e37678138caef489563">ColumnBlockWorkspace</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a75c16c916c50066e637a83c97b73b627">new_column_workspace</a> (size_t start, size_t length, bool cache=false) const =0</td></tr>
<tr class="separator:a75c16c916c50066e637a83c97b73b627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee30b94d74c1a1f8d1a197f388d2e71"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a8dacf3f8e448e211c63056656e24d0b8">RowIndexWorkspace</a>&lt; IDX &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#afee30b94d74c1a1f8d1a197f388d2e71">new_row_workspace</a> (std::vector&lt; IDX &gt; indices, bool cache=false) const =0</td></tr>
<tr class="separator:afee30b94d74c1a1f8d1a197f388d2e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11491463b084b7fdbe9c2f969b2c8dee"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a9de74505bea2d3c1139479047b133f3d">ColumnIndexWorkspace</a>&lt; IDX &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a11491463b084b7fdbe9c2f969b2c8dee">new_column_workspace</a> (std::vector&lt; IDX &gt; indices, bool cache=false) const =0</td></tr>
<tr class="separator:a11491463b084b7fdbe9c2f969b2c8dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10be7bad85b57f0681a12dc02455c772"><td class="memItemLeft" align="right" valign="top">virtual const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a10be7bad85b57f0681a12dc02455c772">row</a> (size_t r, T *buffer, <a class="el" href="namespacetatami.html#a4a4650628564a58b961b7df8e2a83ac8">RowWorkspace</a> *work) const =0</td></tr>
<tr class="separator:a10be7bad85b57f0681a12dc02455c772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6336c4e35d9573f9e4633ea7519e2e"><td class="memItemLeft" align="right" valign="top">virtual const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a7d6336c4e35d9573f9e4633ea7519e2e">column</a> (size_t c, T *buffer, <a class="el" href="namespacetatami.html#a60a9117c28a1c409e7b7b3836be9531a">ColumnWorkspace</a> *work) const =0</td></tr>
<tr class="separator:a7d6336c4e35d9573f9e4633ea7519e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a1d326e609a1787e4d62f30c08fb613"><td class="memItemLeft" align="right" valign="top">virtual const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a6a1d326e609a1787e4d62f30c08fb613">row</a> (size_t r, T *buffer, <a class="el" href="namespacetatami.html#a100a9dd1056492a6687199cc1b341c08">RowBlockWorkspace</a> *work) const =0</td></tr>
<tr class="separator:a6a1d326e609a1787e4d62f30c08fb613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749f178cf9da74760d1d5b3cf9887077"><td class="memItemLeft" align="right" valign="top">virtual const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a749f178cf9da74760d1d5b3cf9887077">column</a> (size_t c, T *buffer, <a class="el" href="namespacetatami.html#a1f0f1615a5c86e37678138caef489563">ColumnBlockWorkspace</a> *work) const =0</td></tr>
<tr class="separator:a749f178cf9da74760d1d5b3cf9887077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a342e723374e557545341ef981b61097b"><td class="memItemLeft" align="right" valign="top">virtual const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a342e723374e557545341ef981b61097b">row</a> (size_t r, T *buffer, <a class="el" href="namespacetatami.html#a8dacf3f8e448e211c63056656e24d0b8">RowIndexWorkspace</a>&lt; IDX &gt; *work) const =0</td></tr>
<tr class="separator:a342e723374e557545341ef981b61097b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52782c318fde3026a32a39b7cd5889a3"><td class="memItemLeft" align="right" valign="top">virtual const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a52782c318fde3026a32a39b7cd5889a3">column</a> (size_t c, T *buffer, <a class="el" href="namespacetatami.html#a9de74505bea2d3c1139479047b133f3d">ColumnIndexWorkspace</a>&lt; IDX &gt; *work) const =0</td></tr>
<tr class="separator:a52782c318fde3026a32a39b7cd5889a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af66be1bb53f6ec8eb2efae17c3289d66"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#af66be1bb53f6ec8eb2efae17c3289d66">row_copy</a> (size_t r, T *buffer, <a class="el" href="namespacetatami.html#a4a4650628564a58b961b7df8e2a83ac8">RowWorkspace</a> *work) const</td></tr>
<tr class="separator:af66be1bb53f6ec8eb2efae17c3289d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced34f0c951c2aba0c63b158656ee190"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#aced34f0c951c2aba0c63b158656ee190">column_copy</a> (size_t c, T *buffer, <a class="el" href="namespacetatami.html#a60a9117c28a1c409e7b7b3836be9531a">ColumnWorkspace</a> *work) const</td></tr>
<tr class="separator:aced34f0c951c2aba0c63b158656ee190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e95a6555c53b064d2d468bafbd5a25e"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a2e95a6555c53b064d2d468bafbd5a25e">row_copy</a> (size_t r, T *buffer, <a class="el" href="namespacetatami.html#a100a9dd1056492a6687199cc1b341c08">RowBlockWorkspace</a> *work) const</td></tr>
<tr class="separator:a2e95a6555c53b064d2d468bafbd5a25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f586587bd44cf891062e3e2e054542"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#ab6f586587bd44cf891062e3e2e054542">column_copy</a> (size_t c, T *buffer, <a class="el" href="namespacetatami.html#a1f0f1615a5c86e37678138caef489563">ColumnBlockWorkspace</a> *work) const</td></tr>
<tr class="separator:ab6f586587bd44cf891062e3e2e054542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd3e81c05d4311827bd0a2836bee98f"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#afdd3e81c05d4311827bd0a2836bee98f">row_copy</a> (size_t r, T *buffer, <a class="el" href="namespacetatami.html#a8dacf3f8e448e211c63056656e24d0b8">RowIndexWorkspace</a>&lt; IDX &gt; *work) const</td></tr>
<tr class="separator:afdd3e81c05d4311827bd0a2836bee98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae398a0d02d2bf817dfd0449a6718c92a"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#ae398a0d02d2bf817dfd0449a6718c92a">column_copy</a> (size_t c, T *buffer, <a class="el" href="namespacetatami.html#a9de74505bea2d3c1139479047b133f3d">ColumnIndexWorkspace</a>&lt; IDX &gt; *work) const</td></tr>
<tr class="separator:ae398a0d02d2bf817dfd0449a6718c92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4604ebd84ac00b6cbc30c16f8c5e0082"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a4604ebd84ac00b6cbc30c16f8c5e0082">row</a> (size_t r, <a class="el" href="namespacetatami.html#a4a4650628564a58b961b7df8e2a83ac8">RowWorkspace</a> *work) const</td></tr>
<tr class="separator:a4604ebd84ac00b6cbc30c16f8c5e0082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab86424e298a196537c91aa3e2b1a40cd"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#ab86424e298a196537c91aa3e2b1a40cd">column</a> (size_t c, <a class="el" href="namespacetatami.html#a60a9117c28a1c409e7b7b3836be9531a">ColumnWorkspace</a> *work) const</td></tr>
<tr class="separator:ab86424e298a196537c91aa3e2b1a40cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d396ffeaf59b2accb61e633c597b87f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a1d396ffeaf59b2accb61e633c597b87f">row</a> (size_t r, <a class="el" href="namespacetatami.html#a100a9dd1056492a6687199cc1b341c08">RowBlockWorkspace</a> *work) const</td></tr>
<tr class="separator:a1d396ffeaf59b2accb61e633c597b87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada979dd7f59d997a87e0fa0d83352c20"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#ada979dd7f59d997a87e0fa0d83352c20">column</a> (size_t c, <a class="el" href="namespacetatami.html#a1f0f1615a5c86e37678138caef489563">ColumnBlockWorkspace</a> *work) const</td></tr>
<tr class="separator:ada979dd7f59d997a87e0fa0d83352c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab406aa70fea00208ccdee7b100999ff7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#ab406aa70fea00208ccdee7b100999ff7">row</a> (size_t r, <a class="el" href="namespacetatami.html#a8dacf3f8e448e211c63056656e24d0b8">RowIndexWorkspace</a>&lt; IDX &gt; *work) const</td></tr>
<tr class="separator:ab406aa70fea00208ccdee7b100999ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05aaa7528e1b52b91f978b4149eb4165"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a05aaa7528e1b52b91f978b4149eb4165">column</a> (size_t c, <a class="el" href="namespacetatami.html#a9de74505bea2d3c1139479047b133f3d">ColumnIndexWorkspace</a>&lt; IDX &gt; *work) const</td></tr>
<tr class="separator:a05aaa7528e1b52b91f978b4149eb4165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75bd1d084698e5df87796ecfe3fffb6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#aa75bd1d084698e5df87796ecfe3fffb6">sparse_row</a> (size_t r, T *vbuffer, IDX *ibuffer, <a class="el" href="namespacetatami.html#a4a4650628564a58b961b7df8e2a83ac8">RowWorkspace</a> *work, bool sorted=true) const</td></tr>
<tr class="separator:aa75bd1d084698e5df87796ecfe3fffb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af294706bdf2074efd08b3e1db0456ca1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#af294706bdf2074efd08b3e1db0456ca1">sparse_column</a> (size_t c, T *vbuffer, IDX *ibuffer, <a class="el" href="namespacetatami.html#a60a9117c28a1c409e7b7b3836be9531a">ColumnWorkspace</a> *work, bool sorted=true) const</td></tr>
<tr class="separator:af294706bdf2074efd08b3e1db0456ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b930df00eec917bba0ac6ae1c0f4458"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a4b930df00eec917bba0ac6ae1c0f4458">sparse_row</a> (size_t r, T *vbuffer, IDX *ibuffer, <a class="el" href="namespacetatami.html#a100a9dd1056492a6687199cc1b341c08">RowBlockWorkspace</a> *work, bool sorted=true) const</td></tr>
<tr class="separator:a4b930df00eec917bba0ac6ae1c0f4458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614d5d8a63b7f4ef246ab3ceda3919d1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a614d5d8a63b7f4ef246ab3ceda3919d1">sparse_column</a> (size_t c, T *vbuffer, IDX *ibuffer, <a class="el" href="namespacetatami.html#a1f0f1615a5c86e37678138caef489563">ColumnBlockWorkspace</a> *work, bool sorted=true) const</td></tr>
<tr class="separator:a614d5d8a63b7f4ef246ab3ceda3919d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e29247a01e96b0c13df3b708ecf5a9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#ae5e29247a01e96b0c13df3b708ecf5a9">sparse_row</a> (size_t r, T *vbuffer, IDX *ibuffer, <a class="el" href="namespacetatami.html#a8dacf3f8e448e211c63056656e24d0b8">RowIndexWorkspace</a>&lt; IDX &gt; *work, bool sorted=true) const</td></tr>
<tr class="separator:ae5e29247a01e96b0c13df3b708ecf5a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095783fbfdea3be8b7ad441e9b536338"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a095783fbfdea3be8b7ad441e9b536338">sparse_column</a> (size_t c, T *vbuffer, IDX *ibuffer, <a class="el" href="namespacetatami.html#a9de74505bea2d3c1139479047b133f3d">ColumnIndexWorkspace</a>&lt; IDX &gt; *work, bool sorted=true) const</td></tr>
<tr class="separator:a095783fbfdea3be8b7ad441e9b536338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a2a08f7008bdc1c9848d87f3bf80ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a72a2a08f7008bdc1c9848d87f3bf80ce">sparse_row_copy</a> (size_t r, T *vbuffer, IDX *ibuffer, <a class="el" href="namespacetatami.html#a4a4650628564a58b961b7df8e2a83ac8">RowWorkspace</a> *work, <a class="el" href="namespacetatami.html#ac4dba1039cc39910b0dd3bcccfea0f71">SparseCopyMode</a> copy=SPARSE_COPY_BOTH, bool sorted=true) const</td></tr>
<tr class="separator:a72a2a08f7008bdc1c9848d87f3bf80ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028fa8bf369e540c212f6dcd11c29fb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a028fa8bf369e540c212f6dcd11c29fb1">sparse_column_copy</a> (size_t c, T *vbuffer, IDX *ibuffer, <a class="el" href="namespacetatami.html#a60a9117c28a1c409e7b7b3836be9531a">ColumnWorkspace</a> *work, <a class="el" href="namespacetatami.html#ac4dba1039cc39910b0dd3bcccfea0f71">SparseCopyMode</a> copy=SPARSE_COPY_BOTH, bool sorted=true) const</td></tr>
<tr class="separator:a028fa8bf369e540c212f6dcd11c29fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b45fbaacf1503182b6391ffefa5f9f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a4b45fbaacf1503182b6391ffefa5f9f5">sparse_row_copy</a> (size_t r, T *vbuffer, IDX *ibuffer, <a class="el" href="namespacetatami.html#a100a9dd1056492a6687199cc1b341c08">RowBlockWorkspace</a> *work, <a class="el" href="namespacetatami.html#ac4dba1039cc39910b0dd3bcccfea0f71">SparseCopyMode</a> copy=SPARSE_COPY_BOTH, bool sorted=true) const</td></tr>
<tr class="separator:a4b45fbaacf1503182b6391ffefa5f9f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c68c3c8aab41106934efe98fdfdec88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a3c68c3c8aab41106934efe98fdfdec88">sparse_column_copy</a> (size_t c, T *vbuffer, IDX *ibuffer, <a class="el" href="namespacetatami.html#a1f0f1615a5c86e37678138caef489563">ColumnBlockWorkspace</a> *work, <a class="el" href="namespacetatami.html#ac4dba1039cc39910b0dd3bcccfea0f71">SparseCopyMode</a> copy=SPARSE_COPY_BOTH, bool sorted=true) const</td></tr>
<tr class="separator:a3c68c3c8aab41106934efe98fdfdec88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b78113e3d23ecf47efe20c17e59028"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#ae6b78113e3d23ecf47efe20c17e59028">sparse_row_copy</a> (size_t r, T *vbuffer, IDX *ibuffer, <a class="el" href="namespacetatami.html#a8dacf3f8e448e211c63056656e24d0b8">RowIndexWorkspace</a>&lt; IDX &gt; *work, <a class="el" href="namespacetatami.html#ac4dba1039cc39910b0dd3bcccfea0f71">SparseCopyMode</a> copy=SPARSE_COPY_BOTH, bool sorted=true) const</td></tr>
<tr class="separator:ae6b78113e3d23ecf47efe20c17e59028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32061a22c9773763e8adf8d4decffc63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a32061a22c9773763e8adf8d4decffc63">sparse_column_copy</a> (size_t c, T *vbuffer, IDX *ibuffer, <a class="el" href="namespacetatami.html#a9de74505bea2d3c1139479047b133f3d">ColumnIndexWorkspace</a>&lt; IDX &gt; *work, <a class="el" href="namespacetatami.html#ac4dba1039cc39910b0dd3bcccfea0f71">SparseCopyMode</a> copy=SPARSE_COPY_BOTH, bool sorted=true) const</td></tr>
<tr class="separator:a32061a22c9773763e8adf8d4decffc63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af56641ca2112efc31e1c6ab475726b50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1SparseRangeCopy.html">SparseRangeCopy</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#af56641ca2112efc31e1c6ab475726b50">sparse_row</a> (size_t r, <a class="el" href="namespacetatami.html#a4a4650628564a58b961b7df8e2a83ac8">RowWorkspace</a> *work, bool sorted=true) const</td></tr>
<tr class="separator:af56641ca2112efc31e1c6ab475726b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a418be2669371c8bcc9a7c042001e5449"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1SparseRangeCopy.html">SparseRangeCopy</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a418be2669371c8bcc9a7c042001e5449">sparse_column</a> (size_t c, <a class="el" href="namespacetatami.html#a60a9117c28a1c409e7b7b3836be9531a">ColumnWorkspace</a> *work, bool sorted=true) const</td></tr>
<tr class="separator:a418be2669371c8bcc9a7c042001e5449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2565998990e5f5af2f4d2251bf6181fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1SparseRangeCopy.html">SparseRangeCopy</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a2565998990e5f5af2f4d2251bf6181fc">sparse_row</a> (size_t r, <a class="el" href="namespacetatami.html#a100a9dd1056492a6687199cc1b341c08">RowBlockWorkspace</a> *work, bool sorted=true) const</td></tr>
<tr class="separator:a2565998990e5f5af2f4d2251bf6181fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94face240af1ec765f084b0dce0a7395"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1SparseRangeCopy.html">SparseRangeCopy</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a94face240af1ec765f084b0dce0a7395">sparse_column</a> (size_t c, <a class="el" href="namespacetatami.html#a1f0f1615a5c86e37678138caef489563">ColumnBlockWorkspace</a> *work, bool sorted=true) const</td></tr>
<tr class="separator:a94face240af1ec765f084b0dce0a7395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d19b893748e5026eeec9e87e8d8cf1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1SparseRangeCopy.html">SparseRangeCopy</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a77d19b893748e5026eeec9e87e8d8cf1">sparse_row</a> (size_t r, <a class="el" href="namespacetatami.html#a8dacf3f8e448e211c63056656e24d0b8">RowIndexWorkspace</a>&lt; IDX &gt; *work, bool sorted=true) const</td></tr>
<tr class="separator:a77d19b893748e5026eeec9e87e8d8cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4bf867231d9760eeb2773f1c1e4f2cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1SparseRangeCopy.html">SparseRangeCopy</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#aa4bf867231d9760eeb2773f1c1e4f2cc">sparse_column</a> (size_t c, <a class="el" href="namespacetatami.html#a9de74505bea2d3c1139479047b133f3d">ColumnIndexWorkspace</a>&lt; IDX &gt; *work, bool sorted=true) const</td></tr>
<tr class="separator:aa4bf867231d9760eeb2773f1c1e4f2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T, typename IDX = int&gt;<br />
class tatami::Matrix&lt; T, IDX &gt;</div><p>Virtual class for a matrix with a defined type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the matrix data. </td></tr>
    <tr><td class="paramname">IDX</td><td>Type of the row/column indices. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a8f97683e1dbef330caadc258b0c404b5" name="a8f97683e1dbef330caadc258b0c404b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f97683e1dbef330caadc258b0c404b5">&#9670;&#160;</a></span>data_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::data_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of data to be returned by getters. </p>

</div>
</div>
<a id="a09b8f1870fe7f6c40fa5426f11ff82f4" name="a09b8f1870fe7f6c40fa5426f11ff82f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09b8f1870fe7f6c40fa5426f11ff82f4">&#9670;&#160;</a></span>index_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef IDX <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::index_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of index to be returned by the sparse getters. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6d505c205ae7ff6fb225450fca5f4307" name="a6d505c205ae7ff6fb225450fca5f4307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d505c205ae7ff6fb225450fca5f4307">&#9670;&#160;</a></span>Matrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::Matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default move constructor. </p>

</div>
</div>
<a id="ac7d8e8cfd07b96e1a604cdccd3a8efaf" name="ac7d8e8cfd07b96e1a604cdccd3a8efaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7d8e8cfd07b96e1a604cdccd3a8efaf">&#9670;&#160;</a></span>Matrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::Matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default copy constructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a54a3bbc3ba8681438f51a48f5f40b42a" name="a54a3bbc3ba8681438f51a48f5f40b42a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54a3bbc3ba8681438f51a48f5f40b42a">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1Matrix.html">Matrix</a> &amp; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default move assignment operator. </p>

</div>
</div>
<a id="a9913765cad84cb6d43271ee213a9d019" name="a9913765cad84cb6d43271ee213a9d019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9913765cad84cb6d43271ee213a9d019">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1Matrix.html">Matrix</a> &amp; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default copy assignment operator. </p>

</div>
</div>
<a id="a48e1342556ff97cc8367b25d244195a9" name="a48e1342556ff97cc8367b25d244195a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48e1342556ff97cc8367b25d244195a9">&#9670;&#160;</a></span>nrow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::nrow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Number of rows. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a5c8cbee3334cbc3f860c1b328e254f7d">tatami::CompressedSparseMatrix&lt; ROW, T, IDX, U, V, W &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#aa09ce1f17542ea8b3d7fa52361e2471d">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#a9c1720ac920a7f8ccc32ad9773e15d5a">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#afff7ed215617739acaa9571b43df40db">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#ae29876550cb25afe75a705adf9da1cbf">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a1f3a122828d9dfa4aaea94f738598730">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a18522b601bd6dc191dc1b06ffccb4a54">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a0b1e46c7058a68bf99d22e1abbfae180">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#ac129143b74bc85931ecbc0171e1306e5">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#afb9f6fb4d51c4741d1c7ae60dd068a26">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a8a036df3d67b81cb8b513343da4fd762">tatami::DenseMatrix&lt; ROW, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#aeb402bffe0ca1dcee1921d7dcf3e1a39">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, and <a class="el" href="classtatami_1_1HDF5DenseMatrix.html#a07799029be780dbd14512a44aea27c56">tatami::HDF5DenseMatrix&lt; T, IDX, transpose &gt;</a>.</p>

</div>
</div>
<a id="a1049bd5cbe37b618db795787725930e4" name="a1049bd5cbe37b618db795787725930e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1049bd5cbe37b618db795787725930e4">&#9670;&#160;</a></span>ncol()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::ncol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Number of columns. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a6871fd77991469c12276bd76c01bec59">tatami::CompressedSparseMatrix&lt; ROW, T, IDX, U, V, W &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#aac4be39ad30c0d3f663ae757a0997add">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#a06946f87e0e9f6642d67c7609c569359">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a452bca17a80a3c0813fd17af9a31b954">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#ae8c55ad6177842b2c2a585db1ff7c097">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a815861e36f3ae9ea433411a5570fc3ab">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#ae7791e7dcaba8ef84940c140b3f000ee">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a075542a40a304d609080c1bf6dc76dad">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#abb010d4a45c1a06dfb53003025a1bdca">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a29552de098bd2374ae99ef0e223d8973">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a2aeb481069a05d0fc07da5243b4de981">tatami::DenseMatrix&lt; ROW, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#af389aa35f14aa2bdd1614374456fad87">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, and <a class="el" href="classtatami_1_1HDF5DenseMatrix.html#a8f75d095251002a518febb91a4905b37">tatami::HDF5DenseMatrix&lt; T, IDX, transpose &gt;</a>.</p>

</div>
</div>
<a id="a05f69722541e0ed9a8f19aad2d44f1c4" name="a05f69722541e0ed9a8f19aad2d44f1c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f69722541e0ed9a8f19aad2d44f1c4">&#9670;&#160;</a></span>sparse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::sparse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Is this matrix sparse? Defaults to <code>false</code> if no specialized method is provided in derived classes. </dd></dl>

<p>Reimplemented in <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a6054f2b91d0d98facd1ee30ac314f153">tatami::CompressedSparseMatrix&lt; ROW, T, IDX, U, V, W &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a9bc50acc8abb34153ffb8e6aecca44de">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#a732db9b24219f172bb1a333cd83ca0e4">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a7993cbcf05de154adb696169a7fa4003">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#ad905ca25aac5131b5df260f019e8e7d3">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a6df37645f5d7f68a366155681c7a40aa">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a4e73b2ae53eb319074a1f3819a0f75f6">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#ad1871b601a312da4fe488be870b6b0c8">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a7cccf979a422cfca026faeb2eff55b16">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#ad22bbe789d72c8dcc1b2d6ff7e4881c7">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, and <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#a086f4e4560281aa4300e655985afc9c2">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>.</p>

</div>
</div>
<a id="ac31ddc309419b4b2f6a2d0a01837e7a3" name="ac31ddc309419b4b2f6a2d0a01837e7a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac31ddc309419b4b2f6a2d0a01837e7a3">&#9670;&#160;</a></span>prefer_rows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::prefer_rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The preferred dimension for extracting values. If <code>true</code>, row-wise extraction is preferred; if <code>false</code>, column-wise extraction is preferred. Defaults to <code>false</code> if no specialized method is provided in derived classes. </dd></dl>

<p>Reimplemented in <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a87ffed12dc9ca20382addba5b6bc944b">tatami::CompressedSparseMatrix&lt; ROW, T, IDX, U, V, W &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a1bccf518ae9d0347e3d35dea911f16a2">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#a7419b6dca60886e56c025f131270049e">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#aac7d662db8f3b0da5431b3035a903e1e">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#aca673b5206e9a03554ccb4675f1799ba">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a557c3dc9adeea5bb48759404b1b12038">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#afc768868ef39a227db3d5d0b51f9e696">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#ad6a41e31f7986bcac03d1386f57fed55">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#af3d355b674d02c73923828549714d1d2">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a13a4810d7d36b07df67b4d0e758d200a">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a94ddae4be909726ce775a3dfb1fd0ea5">tatami::DenseMatrix&lt; ROW, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#a4d92ffb3fbf904f58e404925f109bcde">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, and <a class="el" href="classtatami_1_1HDF5DenseMatrix.html#a1e44e966facadb765b89e4f6791cdeb4">tatami::HDF5DenseMatrix&lt; T, IDX, transpose &gt;</a>.</p>

</div>
</div>
<a id="a8e0c04c5b051451af78a64e517aae0c1" name="a8e0c04c5b051451af78a64e517aae0c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e0c04c5b051451af78a64e517aae0c1">&#9670;&#160;</a></span>dimension_preference()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::pair&lt; double, double &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::dimension_preference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A <code>pair</code> containing the number of matrix elements that prefer row-level access (<code>first</code>) or column-level access (<code>second</code>).</dd></dl>
<p>This method is useful for determining the return value of <code><a class="el" href="classtatami_1_1Matrix.html#ac31ddc309419b4b2f6a2d0a01837e7a3">prefer_rows()</a></code> in combined matrices consisting of both row- and column-preferred submatrices. In such cases, the net preference can be determined based on the combined size of the submatrices for each preference.</p>
<p>For simpler matrices, the return value contains the total size of the matrix in one of the <code>double</code>s and zero in the other. </p>

<p>Reimplemented in <a class="el" href="classtatami_1_1DelayedBind.html#ad2e7e7de5d4bfb9805c1ae30d6349a03">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#a1faa2c83092496f4b575a6b4bb443ae5">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#adf14940f5ee2203b21cdc42e2193ba38">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a85d21acf4b1dada0d5bd260588050540">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a8dcadc7645d0ec7799a28b2cec8f8d5a">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#aca10f5c1d320a98115f24ad0af0cc305">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a6e5ad149bb1d004112f56cbd62600223">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>, and <a class="el" href="classtatami_1_1DelayedTranspose.html#af90b17efb1122a8c56bdec9cc94bcee0">tatami::DelayedTranspose&lt; T, IDX &gt;</a>.</p>

</div>
</div>
<a id="aa62c3f22f2f82f93b81596caf27ededd" name="aa62c3f22f2f82f93b81596caf27ededd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa62c3f22f2f82f93b81596caf27ededd">&#9670;&#160;</a></span>new_row_workspace() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a4a4650628564a58b961b7df8e2a83ac8">RowWorkspace</a> &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::new_row_workspace </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cache</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>Whether to cache information from each call to <code><a class="el" href="classtatami_1_1Matrix.html#a10be7bad85b57f0681a12dc02455c772">row()</a></code> with this workspace, for faster iterations if the same row is extracted during multiple passes over the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a <code>RowWorkspace</code> for row-wise data extraction, or a null pointer if no workspace is required. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1DelayedBind.html#a1610dde25a7617677bc6ad5b8c000244">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#ae5b3dd6bfd38fa7b0a1e98b8af22d2d9">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a0aaf10e1d3f731dbbbbe307a38ba6b9a">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a0628274203a1b626b1ac96d86ad1ba3a">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a7957f0933feed86e0dadbbd4ec7e74ef">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#adb1ee6923b5ad8b46ca05cffded58ea8">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a821eac25f5742d2b1e9492dd9011a351">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#add8c99583716bbff60c024c79b7f4db3">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a75972ccca6660503b25c01ebbb8ead41">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a238153e585398da37e42cc8a6c2fd552">tatami::CompressedSparseMatrix&lt; ROW, T, IDX, U, V, W &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#af908a293d301e753e646d338d0dbef5d">tatami::DenseMatrix&lt; ROW, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#a36b3ce2b6ded19488e46672540227e45">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, and <a class="el" href="classtatami_1_1HDF5DenseMatrix.html#ad277ab6c312d2fa131c7648933af1dc7">tatami::HDF5DenseMatrix&lt; T, IDX, transpose &gt;</a>.</p>

</div>
</div>
<a id="a8e0dbb0132e1b132a9164c20729e21d5" name="a8e0dbb0132e1b132a9164c20729e21d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e0dbb0132e1b132a9164c20729e21d5">&#9670;&#160;</a></span>new_column_workspace() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a60a9117c28a1c409e7b7b3836be9531a">ColumnWorkspace</a> &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::new_column_workspace </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cache</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>Whether to cache information from each call to <code><a class="el" href="classtatami_1_1Matrix.html#a7d6336c4e35d9573f9e4633ea7519e2e">column()</a></code> with this workspace, for faster iterations if the same column is extracted during multiple passes over the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a <code>ColumnWorkspace</code> for column-wise data extraction, or a null pointer if no workspace is required. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1DelayedBind.html#ab8045303d855f585c84f7028d83eda85">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#a2f3160da705edf766897b912fc384718">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a7fa357c8a520332a2dfdcb9d3cae4c87">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a953437b0959dad30f46ed34a34593918">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a5562a1a3a45c0e7441fdad4c54975a9a">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a77a97709dd095538e7fb22a396d77c8d">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a1abb23e256e3277f0eee8f7244e43c73">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#abf58fc43f04f1752188339ba190b7d3d">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a71081ce98a5a66ea8d30b137a3bb802c">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#abcef74f47744f89c1a619ef4e5bd8a01">tatami::CompressedSparseMatrix&lt; ROW, T, IDX, U, V, W &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a3e5aa80af7efd98f39eac39e3431989b">tatami::DenseMatrix&lt; ROW, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#adc0e94a4ad3580cfc14015a2f1a328f7">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, and <a class="el" href="classtatami_1_1HDF5DenseMatrix.html#a5b3e93b7b2c51815c32c72e533fd6f56">tatami::HDF5DenseMatrix&lt; T, IDX, transpose &gt;</a>.</p>

</div>
</div>
<a id="a7287719dc760c70e891586dd946f8443" name="a7287719dc760c70e891586dd946f8443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7287719dc760c70e891586dd946f8443">&#9670;&#160;</a></span>new_row_workspace() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a100a9dd1056492a6687199cc1b341c08">RowBlockWorkspace</a> &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::new_row_workspace </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cache</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Index of the first column in the block. </td></tr>
    <tr><td class="paramname">length</td><td>Number of columns in the block. </td></tr>
    <tr><td class="paramname">cache</td><td>Whether to cache information from each call to <code><a class="el" href="classtatami_1_1Matrix.html#a10be7bad85b57f0681a12dc02455c772">row()</a></code> with this workspace, for faster iterations if the same row is extracted during multiple passes over the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a <code>RowBlockWorkspace</code> for row-wise extraction of data from a contiguous block of columns from <code>[start, start + length)</code>. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#a75f24264a6dbe4b29e4ac0f06a586a49">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1HDF5DenseMatrix.html#a491ebc573f1b8f13d26e71c16b872a39">tatami::HDF5DenseMatrix&lt; T, IDX, transpose &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a9680916e07ec693a754913e285e8a9cf">tatami::DenseMatrix&lt; ROW, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#ae91a39f0031c84fc206327e0981981ca">tatami::CompressedSparseMatrix&lt; ROW, T, IDX, U, V, W &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a5b417ac07e711a6d23aaa21a09726680">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#a2ada1980045692e880de0d8d6013ed3a">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a8b9a73c946cae37005e069be5395221b">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a2db8a6593abd04e1d4336943538c8d57">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#ac36e9baf0e583d0dbe1ac12a5864ba91">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#aa8fa715c15bc08aa8a862d11f35a6180">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a56174f98b83e99807fb9ca248c94a7d2">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a393c528324866bffb96d62bf53f2d419">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, and <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a43792475e8fe46d9f2d6d9504e4e2d96">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>.</p>

</div>
</div>
<a id="a75c16c916c50066e637a83c97b73b627" name="a75c16c916c50066e637a83c97b73b627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75c16c916c50066e637a83c97b73b627">&#9670;&#160;</a></span>new_column_workspace() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a1f0f1615a5c86e37678138caef489563">ColumnBlockWorkspace</a> &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::new_column_workspace </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cache</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Index of the first row in the block. </td></tr>
    <tr><td class="paramname">length</td><td>Number of rows in the block. </td></tr>
    <tr><td class="paramname">cache</td><td>Whether to cache information from each call to <code><a class="el" href="classtatami_1_1Matrix.html#a7d6336c4e35d9573f9e4633ea7519e2e">column()</a></code> with this workspace, for faster iterations if the same column is extracted during multiple passes over the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a <code>RowBlockWorkspace</code> for column-wise extraction of data from a contiguous block of rows from <code>[start, start + length)</code>. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#acad1c1422b7cd72c9bf3c3bf26699e5c">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1HDF5DenseMatrix.html#ab0aed1b8d246fd7d581cbd28299bbae2">tatami::HDF5DenseMatrix&lt; T, IDX, transpose &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a60dfedbc8f2755c198f069619908e48b">tatami::DenseMatrix&lt; ROW, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#afa824ede0fc4dff062f2869ceef51230">tatami::CompressedSparseMatrix&lt; ROW, T, IDX, U, V, W &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a92f6b148061ed5a45c00b34041699f06">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#ae98c8dcc19a617f527988a5ee9863903">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#aee7768d5ae5181f434d952aa4dc81923">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a9a055561855356a61e1378d39fe34135">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#abcb6bf64cb75b52bb5770e3fddbca674">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#aa5e159010b1e767638b1672f8e8cea23">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a6fc58a7c3943fc0431874dab58b0fe8b">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a2299381a983bc39f4049ca8aea0fcc18">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, and <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#adabb5cf00b759125187c65a5aa873a9a">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>.</p>

</div>
</div>
<a id="afee30b94d74c1a1f8d1a197f388d2e71" name="afee30b94d74c1a1f8d1a197f388d2e71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afee30b94d74c1a1f8d1a197f388d2e71">&#9670;&#160;</a></span>new_row_workspace() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a8dacf3f8e448e211c63056656e24d0b8">RowIndexWorkspace</a>&lt; IDX &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::new_row_workspace </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; IDX &gt;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cache</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Vector containing sorted and unique column indices. </td></tr>
    <tr><td class="paramname">cache</td><td>Whether to cache information from each call to <code><a class="el" href="classtatami_1_1Matrix.html#a10be7bad85b57f0681a12dc02455c772">row()</a></code> with this workspace, for faster iterations if the same row is extracted during multiple passes over the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a <code>RowIndexWorkspace</code> for row-wise extraction of data from a subset of columns defined by <code>indices</code>, or a null pointer if no workspace is required. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#a036a306a0c927fe3784fd0a7fa573631">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a88d8d8b18b0a18230192a091133c295b">tatami::DenseMatrix&lt; ROW, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1HDF5DenseMatrix.html#af29846b100fb90ae6317a53dd5be194d">tatami::HDF5DenseMatrix&lt; T, IDX, transpose &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a81e66bc20cae9e4ace9b15eae4791589">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#aeef63c89f044a8cbc37366d6ffc777a1">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a6d81ef87ecceedb2a6a6adf675d9e57c">tatami::CompressedSparseMatrix&lt; ROW, T, IDX, U, V, W &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a57afdd76eddf889457b8a6459db21f25">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a503975b90c37d870f38becb0ae3db41f">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a67838b12ed18a680590caa79c0a6b79d">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#afe32bb1021ccc1db98592db466a11129">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a971f853b55bad7f3ed4a35b5674ae6ad">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a21e4571856e13c9a14dfb89422cc67da">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#a9d6c62e5930c35aefe575081b77d555e">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>.</p>

</div>
</div>
<a id="a11491463b084b7fdbe9c2f969b2c8dee" name="a11491463b084b7fdbe9c2f969b2c8dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11491463b084b7fdbe9c2f969b2c8dee">&#9670;&#160;</a></span>new_column_workspace() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="namespacetatami.html#a9de74505bea2d3c1139479047b133f3d">ColumnIndexWorkspace</a>&lt; IDX &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::new_column_workspace </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; IDX &gt;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cache</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Vector containing sorted and unique row indices. </td></tr>
    <tr><td class="paramname">cache</td><td>Whether to cache information from each call to <code><a class="el" href="classtatami_1_1Matrix.html#a7d6336c4e35d9573f9e4633ea7519e2e">column()</a></code> with this workspace, for faster iterations if the same column is extracted during multiple passes over the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a <code>ColumnIndexWorkspace</code> for column-wise extraction of data from a subset of rows defined by <code>indices</code>, or a null pointer if no workspace is required. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#aca1f95ea09354a655721c4c2a293bc4d">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#aa822b7cb0967ce71f3d2b416a8847f12">tatami::DenseMatrix&lt; ROW, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1HDF5DenseMatrix.html#a57c8e16022d25b5bf642bc44e7ebd808">tatami::HDF5DenseMatrix&lt; T, IDX, transpose &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#aa3ec1c0f76c33713eba63061552bace5">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a72a4bdeeadda89e0442bd1e4c7d5aa7b">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a953f5f06ebf13ef1a67928d2bf198153">tatami::CompressedSparseMatrix&lt; ROW, T, IDX, U, V, W &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#aa3aacaaa06ba4d1f64a40f2c35ba863d">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a17d9cc4d8b3ad469c6cd54903e4a77ad">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a9e1f1024961673552ec67d1405ffd744">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a2ef18c817983ac61d481ab98eb2ea671">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a69084b2562451b31d2fb835d1b304b24">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#aa690681615c4fc7e80f6eba94fe08533">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#a5d7c3afa8d0b01f9f8b840f95887d35c">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>.</p>

</div>
</div>
<a id="a10be7bad85b57f0681a12dc02455c772" name="a10be7bad85b57f0681a12dc02455c772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10be7bad85b57f0681a12dc02455c772">&#9670;&#160;</a></span>row() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const T * <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::row </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a4a4650628564a58b961b7df8e2a83ac8">RowWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><code>buffer</code> may not necessarily be filled upon extraction if a pointer can be returned to the underlying data store. This can be checked by comparing the returned pointer to <code>buffer</code>; if they are the same, <code>buffer</code> has been filled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Index of the row. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1Matrix.html#a1049bd5cbe37b618db795787725930e4">ncol()</a></code> values. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to the workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#aa62c3f22f2f82f93b81596caf27ededd">new_row_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the values of row <code>r</code>, containing <code><a class="el" href="classtatami_1_1Matrix.html#a1049bd5cbe37b618db795787725930e4">ncol()</a></code> valid entries. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#af63b953c861d4be664386abe9ffe05d0">tatami::CompressedSparseMatrix&lt; ROW, T, IDX, U, V, W &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a6d160049305ee793a99d2b76a163bd07">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#aa8b41db81254de9fdcb3315968d4f7a3">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a4c5f71b128ec176cd1c1632b2d2d6490">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#aeec3012b1ec57efb6c1eed512a04fb4c">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a28112ca0c3e1a652a697cac9f4844285">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#af0a4fc948a316c0b74771811fc4cadda">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a94de890869ca606b477bcafd9b2b591c">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a063c3c47b1ecd20015c87bdc25977bcf">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a8a958569d01ac135ed18a8018ee65010">tatami::DenseMatrix&lt; ROW, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#aad3a02469ece8abc65976d8a9f78b739">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1HDF5DenseMatrix.html#a3775433f310fc693f7fb14a61ec31ea2">tatami::HDF5DenseMatrix&lt; T, IDX, transpose &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#a89761a27104e788bb24cc37cd0de067a">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>.</p>

</div>
</div>
<a id="a7d6336c4e35d9573f9e4633ea7519e2e" name="a7d6336c4e35d9573f9e4633ea7519e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d6336c4e35d9573f9e4633ea7519e2e">&#9670;&#160;</a></span>column() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const T * <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::column </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a60a9117c28a1c409e7b7b3836be9531a">ColumnWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><code>buffer</code> may not necessarily be filled upon extraction if a pointer can be returned to the underlying data store. This can be checked by comparing the returned pointer to <code>buffer</code>; if they are the same, <code>buffer</code> has been filled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Index of the column. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to an array with enough space for at least <code>last - first</code> values. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to the workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#a8e0dbb0132e1b132a9164c20729e21d5">new_column_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the values of column <code>c</code>, containing <code><a class="el" href="classtatami_1_1Matrix.html#a1049bd5cbe37b618db795787725930e4">ncol()</a></code> valid entries. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#af0d79c37c5412779815fa58ac9faed9e">tatami::CompressedSparseMatrix&lt; ROW, T, IDX, U, V, W &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#afd20c51abb0914225ec5555e2fa38c98">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#acb298c82d7da2a11a1b3b3c1247fbdd0">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a6927d8b72a46cc8117b4c8f52bd87001">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#ab7d5d51b02f4bb37be318bad2fffc26f">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a77aa2fc70b60a51b4fc2b1afd0bcbb83">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#afc95d029362d35b5171ce7ec38f0c528">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a0242b58b105f5db0d67dcfee7ca2efff">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a69a33dd4fc764bcb9f604b6ed5715265">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#a95c7cef847a70faa6c592da09488394f">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1HDF5DenseMatrix.html#a4012257ae03f5072e7086453d6d2b4f9">tatami::HDF5DenseMatrix&lt; T, IDX, transpose &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a2a8f1a1efed0c69d39667639d3ceff95">tatami::DenseMatrix&lt; ROW, T, IDX, V &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#ae2b03480929cb22ad5a48eb8c6411848">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>.</p>

</div>
</div>
<a id="a6a1d326e609a1787e4d62f30c08fb613" name="a6a1d326e609a1787e4d62f30c08fb613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a1d326e609a1787e4d62f30c08fb613">&#9670;&#160;</a></span>row() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const T * <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::row </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a100a9dd1056492a6687199cc1b341c08">RowBlockWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><code>buffer</code> may not necessarily be filled upon extraction if a pointer can be returned to the underlying data store. This can be checked by comparing the returned pointer to <code>buffer</code>; if they are the same, <code>buffer</code> has been filled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Index of the row. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1BlockWorkspace.html#a7dbf988dde45119d189517b2d435edf6">RowBlockWorkspace::length</a></code> values. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to the workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#aa62c3f22f2f82f93b81596caf27ededd">new_row_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to an array containing a block of values from row <code>r</code>, where the array is of length <code><a class="el" href="classtatami_1_1BlockWorkspace.html#a7dbf988dde45119d189517b2d435edf6">RowBlockWorkspace::length</a></code>. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a722b125716681ccbbe1b7fa197c66032">tatami::CompressedSparseMatrix&lt; ROW, T, IDX, U, V, W &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#ac3d029887fde5c143583b4502bd05e49">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a623b83aa1ab60fb3a4c953f2b324887e">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a87101654b7bea9437adf498063834282">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a1980abd9c094d2f1bad21ba3eccc2890">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#abef034aac9a348e93d7a75467949d5de">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a23c9a7eeed2a59631681e55c6503c08d">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#af1646ee0ab7110d9af570a0ebeda75b5">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a48c5ffae1a272bf779dd9d298c1ff7ea">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a63bb27791b283574b27380764c2e94d5">tatami::DenseMatrix&lt; ROW, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#a6c4d64cb338a0e931f5219b0020b32b3">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1HDF5DenseMatrix.html#a2c3c172dee637094337205e3a70930dd">tatami::HDF5DenseMatrix&lt; T, IDX, transpose &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#abe490699380463b439ec8603e8b3b662">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>.</p>

</div>
</div>
<a id="a749f178cf9da74760d1d5b3cf9887077" name="a749f178cf9da74760d1d5b3cf9887077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a749f178cf9da74760d1d5b3cf9887077">&#9670;&#160;</a></span>column() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const T * <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::column </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a1f0f1615a5c86e37678138caef489563">ColumnBlockWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><code>buffer</code> may not necessarily be filled upon extraction if a pointer can be returned to the underlying data store. This can be checked by comparing the returned pointer to <code>buffer</code>; if they are the same, <code>buffer</code> has been filled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Index of the column. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1BlockWorkspace.html#a7dbf988dde45119d189517b2d435edf6">ColumnBlockWorkspace::length</a></code> values. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to the workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#a8e0dbb0132e1b132a9164c20729e21d5">new_column_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to an array containing a block of values from column <code>c</code>, where the array is of length <code><a class="el" href="classtatami_1_1BlockWorkspace.html#a7dbf988dde45119d189517b2d435edf6">ColumnBlockWorkspace::length</a></code>. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#af15f1110a93a3d4190d0194de4afa40e">tatami::CompressedSparseMatrix&lt; ROW, T, IDX, U, V, W &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a4b9c0d3f0e2c68b4d941f5a7d983d381">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a94eb08601cbfbd37a5118b59efcf7d42">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a56f1af8a072aa1b2291a92a82ed70771">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a27591f1a670daac5435ca07680411677">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#ad42479f3e7bf5fc8af0a4950beabc1ef">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a70ced59c6239735d6816aab1085f6715">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a79e28aa443560017a894f48b6794da8e">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a7a275caf8bd696a4a5a7955aa73477c2">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a7712977d6822b361ec20c414c6fcda3a">tatami::DenseMatrix&lt; ROW, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#aef5d6f906b66f876b4ba2ea60376f270">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1HDF5DenseMatrix.html#adae5beac0f3c85afe4adf0669c041a5b">tatami::HDF5DenseMatrix&lt; T, IDX, transpose &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#aac36667ea969cdc9469e2f473a344e8c">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>.</p>

</div>
</div>
<a id="a342e723374e557545341ef981b61097b" name="a342e723374e557545341ef981b61097b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a342e723374e557545341ef981b61097b">&#9670;&#160;</a></span>row() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const T * <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::row </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a8dacf3f8e448e211c63056656e24d0b8">RowIndexWorkspace</a>&lt; IDX &gt; *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Index of the row. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1IndexWorkspace.html#aa48b3242c66017689d36d6570e04cb49">RowIndexWorkspace::length</a></code> values. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to the workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#aa62c3f22f2f82f93b81596caf27ededd">new_row_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The array pointed to by <code>buffer</code> is filled with a subset of values from column <code>r</code>. <code>buffer</code> itself is returned. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a561c6db6c20bef377ae1b35904e1bace">tatami::CompressedSparseMatrix&lt; ROW, T, IDX, U, V, W &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a753c75609ae184e141e5ffaf30bfccca">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a71be968b7cc41a408a225b5cf810abc3">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a7fafe3ab69da2e961929235e5e166f50">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#ab9dd4f028a7371a740ebe1f1a991f72a">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#ade2816526cdd97f94b0975a5f6c87ccb">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#aeb0b68aced2e6b7269e2f00b0c549c2a">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#ac35d8bde239f48218cb87fdd5c46f4b8">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a0c3b6e19dcb9434b1214009c62dcc9a3">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#acb5b12f876170b698511e24fd5ecb2ff">tatami::DenseMatrix&lt; ROW, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#a6cc1e62572ef9ae2220752c9022970f3">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1HDF5DenseMatrix.html#a704c5257c959ae4eaf7ed4254d4b587e">tatami::HDF5DenseMatrix&lt; T, IDX, transpose &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#a7a92c6d8dd8e2e62bb21ef2769a2f76d">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>.</p>

</div>
</div>
<a id="a52782c318fde3026a32a39b7cd5889a3" name="a52782c318fde3026a32a39b7cd5889a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52782c318fde3026a32a39b7cd5889a3">&#9670;&#160;</a></span>column() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const T * <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::column </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a9de74505bea2d3c1139479047b133f3d">ColumnIndexWorkspace</a>&lt; IDX &gt; *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Index of the column. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1IndexWorkspace.html#aa48b3242c66017689d36d6570e04cb49">ColumnIndexWorkspace::length</a></code> values. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to the workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#a8e0dbb0132e1b132a9164c20729e21d5">new_column_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The array pointed to by <code>buffer</code> is filled with a subset of values from column <code>c</code>. <code>buffer</code> itself is returned. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#adfcc9f4486e05fbe5b3ccb1e29b76fe5">tatami::CompressedSparseMatrix&lt; ROW, T, IDX, U, V, W &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#aad006f7040a05c518f69381d64964475">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a4c51364cca3ce38e57e599a53fdda22a">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a54e9065a86c663a1cf008d8245716a78">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a384a1ec1065bc72bae99c67646f230b5">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a0f5e2caca415c5fb6c1d8f7d1f6b8a62">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a98355392c8db9c38b09d650ebe37ef34">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a1c0d70ae78810a70249ae54cd0782dde">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a1039aea298fa7a9bbcfad10c17010686">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a7c5ba2f22c8393a267e4e8a56bea65b4">tatami::DenseMatrix&lt; ROW, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#a1a5df5ac9e9f400ae730d96d2742da1e">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1HDF5DenseMatrix.html#a1e5acfb8a517a621630b4e6ca4e82bfb">tatami::HDF5DenseMatrix&lt; T, IDX, transpose &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#a0c318ec936b75bbef758818d8aef28b4">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>.</p>

</div>
</div>
<a id="af66be1bb53f6ec8eb2efae17c3289d66" name="af66be1bb53f6ec8eb2efae17c3289d66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af66be1bb53f6ec8eb2efae17c3289d66">&#9670;&#160;</a></span>row_copy() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::row_copy </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a4a4650628564a58b961b7df8e2a83ac8">RowWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Index of the row. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1Matrix.html#a1049bd5cbe37b618db795787725930e4">ncol()</a></code> values. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to the workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#aa62c3f22f2f82f93b81596caf27ededd">new_row_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The array at <code>buffer</code> is filled with the values of row <code>r</code>. <code>buffer</code> itself is returned. </dd></dl>

</div>
</div>
<a id="aced34f0c951c2aba0c63b158656ee190" name="aced34f0c951c2aba0c63b158656ee190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced34f0c951c2aba0c63b158656ee190">&#9670;&#160;</a></span>column_copy() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::column_copy </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a60a9117c28a1c409e7b7b3836be9531a">ColumnWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Index of the column. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1Matrix.html#a48e1342556ff97cc8367b25d244195a9">nrow()</a></code> values. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to the workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#a8e0dbb0132e1b132a9164c20729e21d5">new_column_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The array at <code>buffer</code> is filled with the values of column <code>c</code>. <code>buffer</code> itself is returned. </dd></dl>

</div>
</div>
<a id="a2e95a6555c53b064d2d468bafbd5a25e" name="a2e95a6555c53b064d2d468bafbd5a25e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e95a6555c53b064d2d468bafbd5a25e">&#9670;&#160;</a></span>row_copy() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::row_copy </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a100a9dd1056492a6687199cc1b341c08">RowBlockWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Index of the row. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1BlockWorkspace.html#a7dbf988dde45119d189517b2d435edf6">RowBlockWorkspace::length</a></code> values. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to the workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#aa62c3f22f2f82f93b81596caf27ededd">new_row_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The array pointed to by <code>buffer</code> is filled with a block of values from row <code>r</code>. <code>buffer</code> itself is returned. </dd></dl>

</div>
</div>
<a id="ab6f586587bd44cf891062e3e2e054542" name="ab6f586587bd44cf891062e3e2e054542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6f586587bd44cf891062e3e2e054542">&#9670;&#160;</a></span>column_copy() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::column_copy </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a1f0f1615a5c86e37678138caef489563">ColumnBlockWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Index of the column. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1BlockWorkspace.html#a7dbf988dde45119d189517b2d435edf6">ColumnBlockWorkspace::length</a></code> values. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to the workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#a8e0dbb0132e1b132a9164c20729e21d5">new_column_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The array pointed to by <code>buffer</code> is filled with a block of values from column <code>c</code>. <code>buffer</code> itself is returned. </dd></dl>

</div>
</div>
<a id="afdd3e81c05d4311827bd0a2836bee98f" name="afdd3e81c05d4311827bd0a2836bee98f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdd3e81c05d4311827bd0a2836bee98f">&#9670;&#160;</a></span>row_copy() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::row_copy </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a8dacf3f8e448e211c63056656e24d0b8">RowIndexWorkspace</a>&lt; IDX &gt; *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Index of the row. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to an array with enough space for at least <code>RowIndexWorkspace&lt;IDX&gt;::length</code> values. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to the workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#aa62c3f22f2f82f93b81596caf27ededd">new_row_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The array pointed to by <code>buffer</code> is filled with a block of values from row <code>r</code>. <code>buffer</code> itself is returned. </dd></dl>

</div>
</div>
<a id="ae398a0d02d2bf817dfd0449a6718c92a" name="ae398a0d02d2bf817dfd0449a6718c92a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae398a0d02d2bf817dfd0449a6718c92a">&#9670;&#160;</a></span>column_copy() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::column_copy </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a9de74505bea2d3c1139479047b133f3d">ColumnIndexWorkspace</a>&lt; IDX &gt; *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Index of the column. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to an array with enough space for at least <code>ColumnIndexWorkspace&lt;IDX&gt;::length</code> values. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to the workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#a8e0dbb0132e1b132a9164c20729e21d5">new_column_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The array pointed to by <code>buffer</code> is filled with a block of values from column <code>c</code>. <code>buffer</code> itself is returned. </dd></dl>

</div>
</div>
<a id="a4604ebd84ac00b6cbc30c16f8c5e0082" name="a4604ebd84ac00b6cbc30c16f8c5e0082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4604ebd84ac00b6cbc30c16f8c5e0082">&#9670;&#160;</a></span>row() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::row </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a4a4650628564a58b961b7df8e2a83ac8">RowWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A more convenient but less efficient version of the <code><a class="el" href="classtatami_1_1Matrix.html#a10be7bad85b57f0681a12dc02455c772">row()</a></code> method. Callers do not have to supply <code>buffer</code>; instead a new allocation is performed every time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Index of the row. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to the workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#aa62c3f22f2f82f93b81596caf27ededd">new_row_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing the values of row <code>r</code>. </dd></dl>

</div>
</div>
<a id="ab86424e298a196537c91aa3e2b1a40cd" name="ab86424e298a196537c91aa3e2b1a40cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab86424e298a196537c91aa3e2b1a40cd">&#9670;&#160;</a></span>column() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::column </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a60a9117c28a1c409e7b7b3836be9531a">ColumnWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A more convenient but (slightly) less efficient version of the <code><a class="el" href="classtatami_1_1Matrix.html#a7d6336c4e35d9573f9e4633ea7519e2e">column()</a></code> method. Callers do not have to supply <code>buffer</code>; instead a new allocation is performed every time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Index of the column. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to the workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#a8e0dbb0132e1b132a9164c20729e21d5">new_column_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing the values of column <code>c</code>. </dd></dl>

</div>
</div>
<a id="a1d396ffeaf59b2accb61e633c597b87f" name="a1d396ffeaf59b2accb61e633c597b87f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d396ffeaf59b2accb61e633c597b87f">&#9670;&#160;</a></span>row() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::row </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a100a9dd1056492a6687199cc1b341c08">RowBlockWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A more convenient but less efficient version of the <code><a class="el" href="classtatami_1_1Matrix.html#a10be7bad85b57f0681a12dc02455c772">row()</a></code> method. Callers do not have to supply <code>buffer</code>; instead a new allocation is performed every time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Index of the row. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to the workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#aa62c3f22f2f82f93b81596caf27ededd">new_row_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing all values of row <code>r</code>. </dd></dl>

</div>
</div>
<a id="ada979dd7f59d997a87e0fa0d83352c20" name="ada979dd7f59d997a87e0fa0d83352c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada979dd7f59d997a87e0fa0d83352c20">&#9670;&#160;</a></span>column() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::column </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a1f0f1615a5c86e37678138caef489563">ColumnBlockWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A more convenient but less efficient version of the <code><a class="el" href="classtatami_1_1Matrix.html#a7d6336c4e35d9573f9e4633ea7519e2e">column()</a></code> method. Callers do not have to supply <code>buffer</code>; instead a new allocation is performed every time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Index of the column. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to the workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#a8e0dbb0132e1b132a9164c20729e21d5">new_column_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing all values of column <code>c</code>. </dd></dl>

</div>
</div>
<a id="ab406aa70fea00208ccdee7b100999ff7" name="ab406aa70fea00208ccdee7b100999ff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab406aa70fea00208ccdee7b100999ff7">&#9670;&#160;</a></span>row() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::row </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a8dacf3f8e448e211c63056656e24d0b8">RowIndexWorkspace</a>&lt; IDX &gt; *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A more convenient but less efficient version of the <code><a class="el" href="classtatami_1_1Matrix.html#a10be7bad85b57f0681a12dc02455c772">row()</a></code> method. Callers do not have to supply <code>buffer</code>; instead a new allocation is performed every time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Index of the row. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to the workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#aa62c3f22f2f82f93b81596caf27ededd">new_row_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing all values of row <code>r</code>. </dd></dl>

</div>
</div>
<a id="a05aaa7528e1b52b91f978b4149eb4165" name="a05aaa7528e1b52b91f978b4149eb4165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05aaa7528e1b52b91f978b4149eb4165">&#9670;&#160;</a></span>column() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::column </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a9de74505bea2d3c1139479047b133f3d">ColumnIndexWorkspace</a>&lt; IDX &gt; *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A more convenient but less efficient version of the <code><a class="el" href="classtatami_1_1Matrix.html#a7d6336c4e35d9573f9e4633ea7519e2e">column()</a></code> method. Callers do not have to supply <code>buffer</code>; instead a new allocation is performed every time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Index of the column. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to the workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#a8e0dbb0132e1b132a9164c20729e21d5">new_column_workspace()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing all values of column <code>c</code>. </dd></dl>

</div>
</div>
<a id="aa75bd1d084698e5df87796ecfe3fffb6" name="aa75bd1d084698e5df87796ecfe3fffb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa75bd1d084698e5df87796ecfe3fffb6">&#9670;&#160;</a></span>sparse_row() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::sparse_row </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>vbuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IDX *&#160;</td>
          <td class="paramname"><em>ibuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a4a4650628564a58b961b7df8e2a83ac8">RowWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sorted</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><code>vbuffer</code> may not necessarily be filled upon extraction if a pointer can be returned to the underlying data store. This be checked by comparing the returned <code><a class="el" href="structtatami_1_1SparseRange.html#af58b18de602bb4e82e5223b0d7168a08">SparseRange::value</a></code> pointer to <code>vbuffer</code>; if they are the same, <code>vbuffer</code> has been filled. The same applies for <code>ibuffer</code> and the returned <code><a class="el" href="structtatami_1_1SparseRange.html#ac7dd33e84bcc456c04e848bdc51ade73">SparseRange::index</a></code> pointer.</p>
<p>Values in <code>vbuffer</code> are not guaranteed to be non-zero. If zeroes are explicitly initialized in the underlying representation, they will be reported here. However, one can safely assume that all values <em>not</em> in <code>vbuffer</code> are zero.</p>
<p>Setting <code>sorted = false</code> can reduce computational work in situations where the order of non-zero elements does not matter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Index of the row. </td></tr>
    <tr><td class="paramname">vbuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1Matrix.html#a1049bd5cbe37b618db795787725930e4">ncol()</a></code> values. </td></tr>
    <tr><td class="paramname">ibuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1Matrix.html#a1049bd5cbe37b618db795787725930e4">ncol()</a></code> indices. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to a workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#aa62c3f22f2f82f93b81596caf27ededd">new_row_workspace()</a></code>. </td></tr>
    <tr><td class="paramname">sorted</td><td>Should the non-zero elements be sorted by their indices?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structtatami_1_1SparseRange.html" title="A range of a sparse vector.">SparseRange</a></code> object describing the contents of row <code>r</code>. </dd></dl>

<p>Reimplemented in <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#a2ef9cbfbf1d03dbe0b7526aa36d0a829">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#ac96074612b3aa4276604ad2ed84a4f29">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a40f5e1ae34dd6122f0fb0522890b94c9">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a22c99fb55de7656a9674f3095226e220">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a42ad0b943e94060963a27326b3c721f8">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a83cefa3a3faa9d144bf52a95b04b0ac0">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#abb3e5a6fad548bb11547340e5ad92d30">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a0a0fd057f0684ae722954603d58e879f">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#afb662d59fccfea47eac1c7a900e13653">tatami::CompressedSparseMatrix&lt; ROW, T, IDX, U, V, W &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#ad3b97d04430c3237d54365407250a3a1">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#a4591963104706b20d7472963195b49de">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>.</p>

</div>
</div>
<a id="af294706bdf2074efd08b3e1db0456ca1" name="af294706bdf2074efd08b3e1db0456ca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af294706bdf2074efd08b3e1db0456ca1">&#9670;&#160;</a></span>sparse_column() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::sparse_column </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>vbuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IDX *&#160;</td>
          <td class="paramname"><em>ibuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a60a9117c28a1c409e7b7b3836be9531a">ColumnWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sorted</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><code>vbuffer</code> may not necessarily be filled upon extraction if a pointer can be returned to the underlying data store. This be checked by comparing the returned <code><a class="el" href="structtatami_1_1SparseRange.html#af58b18de602bb4e82e5223b0d7168a08">SparseRange::value</a></code> pointer to <code>vbuffer</code>; if they are the same, <code>vbuffer</code> has been filled. The same applies for <code>ibuffer</code> and the returned <code><a class="el" href="structtatami_1_1SparseRange.html#ac7dd33e84bcc456c04e848bdc51ade73">SparseRange::index</a></code> pointer.</p>
<p>Values in <code>vbuffer</code> are not guaranteed to be non-zero. If zeroes are explicitly initialized in the underlying representation, they will be reported here. However, one can safely assume that all values <em>not</em> in <code>vbuffer</code> are zero.</p>
<p>Setting <code>sorted = false</code> can reduce computational work in situations where the order of non-zero elements does not matter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Index of the column. </td></tr>
    <tr><td class="paramname">vbuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1Matrix.html#a48e1342556ff97cc8367b25d244195a9">nrow()</a></code> values. </td></tr>
    <tr><td class="paramname">ibuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1Matrix.html#a48e1342556ff97cc8367b25d244195a9">nrow()</a></code> indices. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to a workspace. </td></tr>
    <tr><td class="paramname">sorted</td><td>Should the non-zero elements be sorted by their indices?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structtatami_1_1SparseRange.html" title="A range of a sparse vector.">SparseRange</a></code> object describing the contents of column <code>c</code>. </dd></dl>

<p>Reimplemented in <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#a987b9077b9559cb891fa11aa687ba9ee">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a4daffba3d59f5321b0690e7199445b6f">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#ad790e9320d322cf30d68fa59d1080c35">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#abf3b7ecd1ffa6b01ddf8a292b0f0340a">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a119cb2aa6a7690a0ea1fe570be4235a7">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a96a973234c1a67769877b9599aec6d42">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a35ddabad19936f9944e2ddaaf44a9926">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a4e48491a7db186fb562dab98a2cd0f98">tatami::CompressedSparseMatrix&lt; ROW, T, IDX, U, V, W &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a37c09e511f37f31aaf1624ba8de5f03f">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#a736b7b2683a7ca5529f927c93f0cda26">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>.</p>

</div>
</div>
<a id="a4b930df00eec917bba0ac6ae1c0f4458" name="a4b930df00eec917bba0ac6ae1c0f4458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b930df00eec917bba0ac6ae1c0f4458">&#9670;&#160;</a></span>sparse_row() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::sparse_row </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>vbuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IDX *&#160;</td>
          <td class="paramname"><em>ibuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a100a9dd1056492a6687199cc1b341c08">RowBlockWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sorted</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><code>vbuffer</code> may not necessarily be filled upon extraction if a pointer can be returned to the underlying data store. This be checked by comparing the returned <code><a class="el" href="structtatami_1_1SparseRange.html#af58b18de602bb4e82e5223b0d7168a08">SparseRange::value</a></code> pointer to <code>vbuffer</code>; if they are the same, <code>vbuffer</code> has been filled. The same applies for <code>ibuffer</code> and the returned <code><a class="el" href="structtatami_1_1SparseRange.html#ac7dd33e84bcc456c04e848bdc51ade73">SparseRange::index</a></code> pointer.</p>
<p>Values in <code>vbuffer</code> are not guaranteed to be non-zero. If zeroes are explicitly initialized in the underlying representation, they will be reported here. However, one can safely assume that all values <em>not</em> in <code>vbuffer</code> are zero.</p>
<p>Setting <code>sorted = false</code> can reduce computational work in situations where the order of non-zero elements does not matter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Index of the row. </td></tr>
    <tr><td class="paramname">vbuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1BlockWorkspace.html#a7dbf988dde45119d189517b2d435edf6">RowBlockWorkspace::length</a></code> values. </td></tr>
    <tr><td class="paramname">ibuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1BlockWorkspace.html#a7dbf988dde45119d189517b2d435edf6">RowBlockWorkspace::length</a></code> indices. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to a workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#aa62c3f22f2f82f93b81596caf27ededd">new_row_workspace()</a></code>. </td></tr>
    <tr><td class="paramname">sorted</td><td>Should the non-zero elements be sorted by their indices?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structtatami_1_1SparseRange.html" title="A range of a sparse vector.">SparseRange</a></code> object describing the contents of a block of columns in row <code>r</code>. </dd></dl>

<p>Reimplemented in <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#a3b6b70c2efdf3d9c891ff7298f81722d">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#aa19b4ab7e127526b8b094d5bd8d764df">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#abc12bf6a93e68d4e4d6d13e878018ea0">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a53906bfafc227fc6e717a6450c7c4d97">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a6cabcade74b5a578ea820e3b7464dbb4">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#af3de4f539ab984ba2ee3aafe998d352d">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#ab71d1cba8350cf07bb610e3165574c40">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#ad6d2502a3c9c538a835e272a05979352">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a5495791990645b95d096108be4a229a8">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#a98c69f8dc67b6cf37975645b35c7176d">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>.</p>

</div>
</div>
<a id="a614d5d8a63b7f4ef246ab3ceda3919d1" name="a614d5d8a63b7f4ef246ab3ceda3919d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614d5d8a63b7f4ef246ab3ceda3919d1">&#9670;&#160;</a></span>sparse_column() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::sparse_column </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>vbuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IDX *&#160;</td>
          <td class="paramname"><em>ibuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a1f0f1615a5c86e37678138caef489563">ColumnBlockWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sorted</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><code>vbuffer</code> may not necessarily be filled upon extraction if a pointer can be returned to the underlying data store. This be checked by comparing the returned <code><a class="el" href="structtatami_1_1SparseRange.html#af58b18de602bb4e82e5223b0d7168a08">SparseRange::value</a></code> pointer to <code>vbuffer</code>; if they are the same, <code>vbuffer</code> has been filled. The same applies for <code>ibuffer</code> and the returned <code><a class="el" href="structtatami_1_1SparseRange.html#ac7dd33e84bcc456c04e848bdc51ade73">SparseRange::index</a></code> pointer.</p>
<p>Values in <code>vbuffer</code> are not guaranteed to be non-zero. If zeroes are explicitly initialized in the underlying representation, they will be reported here. However, one can safely assume that all values <em>not</em> in <code>vbuffer</code> are zero.</p>
<p>Setting <code>sorted = false</code> can reduce computational work in situations where the order of non-zero elements does not matter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Index of the column. </td></tr>
    <tr><td class="paramname">vbuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1BlockWorkspace.html#a7dbf988dde45119d189517b2d435edf6">ColumnBlockWorkspace::length</a></code> values. </td></tr>
    <tr><td class="paramname">ibuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1BlockWorkspace.html#a7dbf988dde45119d189517b2d435edf6">ColumnBlockWorkspace::length</a></code> indices. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to a workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#a8e0dbb0132e1b132a9164c20729e21d5">new_column_workspace()</a></code>. </td></tr>
    <tr><td class="paramname">sorted</td><td>Should the non-zero elements be sorted by their indices?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structtatami_1_1SparseRange.html" title="A range of a sparse vector.">SparseRange</a></code> object describing the contents of a block of rows in column <code>c</code>. </dd></dl>

<p>Reimplemented in <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#a6e25a641fbcdf2b66973a507cf689230">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#aa454bc6135f5a2dd1e9f7de70c6ed541">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a14cf19714ccf34d18fda7f3a775d2889">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a353b0d1fd52d3cc2ef765992bee966b3">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a61273f62a87077e7a153f8bfd6627c82">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a7217c04da1c525f995e0a0be2ea09880">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a078101267026ab9cee3cb2ae10cc1b42">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a99254b129b6b50b3f16e4d2fb4fcaf80">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a020bc0b975d2138a2d4bf3f71effb82c">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#a55dac4ad09703e5b6a7e3a3e677e390d">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>.</p>

</div>
</div>
<a id="ae5e29247a01e96b0c13df3b708ecf5a9" name="ae5e29247a01e96b0c13df3b708ecf5a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5e29247a01e96b0c13df3b708ecf5a9">&#9670;&#160;</a></span>sparse_row() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::sparse_row </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>vbuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IDX *&#160;</td>
          <td class="paramname"><em>ibuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a8dacf3f8e448e211c63056656e24d0b8">RowIndexWorkspace</a>&lt; IDX &gt; *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sorted</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Values in <code>vbuffer</code> are not guaranteed to be non-zero. If zeroes are explicitly initialized in the underlying representation, they will be reported here. However, one can safely assume that all values <em>not</em> in <code>vbuffer</code> are zero.</p>
<p>Setting <code>sorted = false</code> can reduce computational work in situations where the order of non-zero elements does not matter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Index of the row. </td></tr>
    <tr><td class="paramname">vbuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1IndexWorkspace.html#aa48b3242c66017689d36d6570e04cb49">RowIndexWorkspace::length</a></code> values. </td></tr>
    <tr><td class="paramname">ibuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1IndexWorkspace.html#aa48b3242c66017689d36d6570e04cb49">RowIndexWorkspace::length</a></code> indices. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to a workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#aa62c3f22f2f82f93b81596caf27ededd">new_row_workspace()</a></code>. </td></tr>
    <tr><td class="paramname">sorted</td><td>Should the non-zero elements be sorted by their indices?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structtatami_1_1SparseRange.html" title="A range of a sparse vector.">SparseRange</a></code> object describing the contents of a subset of columns in row <code>r</code>. <code>vbuffer</code> is set as <code><a class="el" href="structtatami_1_1SparseRange.html#af58b18de602bb4e82e5223b0d7168a08">SparseRange::value</a></code>, while <code>ibuffer</code> is set as <code><a class="el" href="structtatami_1_1SparseRange.html#ac7dd33e84bcc456c04e848bdc51ade73">SparseRange::index</a></code>. </dd></dl>

<p>Reimplemented in <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#a0286f3970eb56e4070bcb720fe270d73">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a726e4adfc43a256815bf3bc5dfd26c98">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a96132104a4ffac4e840cdfa122871bf6">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a1789af3233a54454e65d345aba180d86">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#adb156756e68e1db83b8ecb9d0ae0a987">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a2ec88dc9d0fd0ec22dadf8677d4a2e84">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a9ec7373cfd09c45931bc4ef847c7a752">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a2cc394430c05ca3d806001ebf63e5d58">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#aa6146a824212286b196900044fa1f076">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#ad57e90f9b874174773469318c384dafc">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>.</p>

</div>
</div>
<a id="a095783fbfdea3be8b7ad441e9b536338" name="a095783fbfdea3be8b7ad441e9b536338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a095783fbfdea3be8b7ad441e9b536338">&#9670;&#160;</a></span>sparse_column() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::sparse_column </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>vbuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IDX *&#160;</td>
          <td class="paramname"><em>ibuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a9de74505bea2d3c1139479047b133f3d">ColumnIndexWorkspace</a>&lt; IDX &gt; *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sorted</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Values in <code>vbuffer</code> are not guaranteed to be non-zero. If zeroes are explicitly initialized in the underlying representation, they will be reported here. However, one can safely assume that all values <em>not</em> in <code>vbuffer</code> are zero.</p>
<p>Setting <code>sorted = false</code> can reduce computational work in situations where the order of non-zero elements does not matter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Index of the column. </td></tr>
    <tr><td class="paramname">vbuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1IndexWorkspace.html#aa48b3242c66017689d36d6570e04cb49">ColumnIndexWorkspace::length</a></code> values. </td></tr>
    <tr><td class="paramname">ibuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1IndexWorkspace.html#aa48b3242c66017689d36d6570e04cb49">ColumnIndexWorkspace::length</a></code> indices. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to a workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#a8e0dbb0132e1b132a9164c20729e21d5">new_column_workspace()</a></code>. </td></tr>
    <tr><td class="paramname">sorted</td><td>Should the non-zero elements be sorted by their indices?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structtatami_1_1SparseRange.html" title="A range of a sparse vector.">SparseRange</a></code> object describing the contents of a subset of rows in column <code>c</code>. <code>vbuffer</code> is set as <code><a class="el" href="structtatami_1_1SparseRange.html#af58b18de602bb4e82e5223b0d7168a08">SparseRange::value</a></code>, while <code>ibuffer</code> is set as <code><a class="el" href="structtatami_1_1SparseRange.html#ac7dd33e84bcc456c04e848bdc51ade73">SparseRange::index</a></code>. </dd></dl>

<p>Reimplemented in <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#a803b283a008e522c30cdf058706990ee">tatami::HDF5CompressedSparseMatrix&lt; ROW, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a08e072855164ac3b759b7984156d49d6">tatami::DelayedBind&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#acbc7e4f3f9b6a05eddd7e01eb320dba2">tatami::DelayedSubsetSortedUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a884a9bcb7581140b7c377551b37a9b38">tatami::DelayedSubsetSorted&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a23f20cedb940bdf837b994925d6800c6">tatami::DelayedSubsetUnique&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#aab0ab8e7a9412985efb509e99e9aec01">tatami::DelayedSubset&lt; MARGIN, T, IDX, V &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#ad45f2466f2ef80298e97048a40ab03cd">tatami::DelayedSubsetBlock&lt; MARGIN, T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#aef82ad17796b98ef85173c46c49ce024">tatami::DelayedTranspose&lt; T, IDX &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a7ad03f9f03534b5055090ca62aa42404">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#a4e4bf911e0a9b1fef42a325e79f8a447">tatami::DelayedCast&lt; T_out, IDX_out, T_in, IDX_in &gt;</a>.</p>

</div>
</div>
<a id="a72a2a08f7008bdc1c9848d87f3bf80ce" name="a72a2a08f7008bdc1c9848d87f3bf80ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72a2a08f7008bdc1c9848d87f3bf80ce">&#9670;&#160;</a></span>sparse_row_copy() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::sparse_row_copy </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>vbuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IDX *&#160;</td>
          <td class="paramname"><em>ibuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a4a4650628564a58b961b7df8e2a83ac8">RowWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#ac4dba1039cc39910b0dd3bcccfea0f71">SparseCopyMode</a>&#160;</td>
          <td class="paramname"><em>copy</em> = <code>SPARSE_COPY_BOTH</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sorted</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Index of the row. </td></tr>
    <tr><td class="paramname">vbuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1Matrix.html#a1049bd5cbe37b618db795787725930e4">ncol()</a></code> values. </td></tr>
    <tr><td class="paramname">ibuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1Matrix.html#a1049bd5cbe37b618db795787725930e4">ncol()</a></code> indices. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to a workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#aa62c3f22f2f82f93b81596caf27ededd">new_row_workspace()</a></code>. </td></tr>
    <tr><td class="paramname">copy</td><td>Whether the non-zero values and/or indices should be copied into <code>vbuffer</code> and <code>ibuffer</code>, respectively. </td></tr>
    <tr><td class="paramname">sorted</td><td>Should the non-zero elements be sorted by their indices? See <code><a class="el" href="classtatami_1_1Matrix.html#aa75bd1d084698e5df87796ecfe3fffb6">sparse_row()</a></code> for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structtatami_1_1SparseRange.html" title="A range of a sparse vector.">SparseRange</a></code> object describing the contents of row <code>r</code>. Depending on <code>copy</code>, values and indices will be copied into <code>vbuffer</code> and/or <code>ibuffer</code>. </dd></dl>

</div>
</div>
<a id="a028fa8bf369e540c212f6dcd11c29fb1" name="a028fa8bf369e540c212f6dcd11c29fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a028fa8bf369e540c212f6dcd11c29fb1">&#9670;&#160;</a></span>sparse_column_copy() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::sparse_column_copy </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>vbuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IDX *&#160;</td>
          <td class="paramname"><em>ibuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a60a9117c28a1c409e7b7b3836be9531a">ColumnWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#ac4dba1039cc39910b0dd3bcccfea0f71">SparseCopyMode</a>&#160;</td>
          <td class="paramname"><em>copy</em> = <code>SPARSE_COPY_BOTH</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sorted</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Index of the column. </td></tr>
    <tr><td class="paramname">vbuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1Matrix.html#a48e1342556ff97cc8367b25d244195a9">nrow()</a></code> values. </td></tr>
    <tr><td class="paramname">ibuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1Matrix.html#a48e1342556ff97cc8367b25d244195a9">nrow()</a></code> indices. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to a workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#a8e0dbb0132e1b132a9164c20729e21d5">new_column_workspace()</a></code>. </td></tr>
    <tr><td class="paramname">copy</td><td>Whether the non-zero values and/or indices should be copied into <code>vbuffer</code> and <code>ibuffer</code>, respectively. </td></tr>
    <tr><td class="paramname">sorted</td><td>Should the non-zero elements be sorted by their indices? See <code><a class="el" href="classtatami_1_1Matrix.html#af294706bdf2074efd08b3e1db0456ca1">sparse_column()</a></code> for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structtatami_1_1SparseRange.html" title="A range of a sparse vector.">SparseRange</a></code> object describing the contents of column <code>c</code>. Depending on <code>copy</code>, values and indices will be copied into <code>vbuffer</code> and/or <code>ibuffer</code>. </dd></dl>

</div>
</div>
<a id="a4b45fbaacf1503182b6391ffefa5f9f5" name="a4b45fbaacf1503182b6391ffefa5f9f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b45fbaacf1503182b6391ffefa5f9f5">&#9670;&#160;</a></span>sparse_row_copy() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::sparse_row_copy </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>vbuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IDX *&#160;</td>
          <td class="paramname"><em>ibuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a100a9dd1056492a6687199cc1b341c08">RowBlockWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#ac4dba1039cc39910b0dd3bcccfea0f71">SparseCopyMode</a>&#160;</td>
          <td class="paramname"><em>copy</em> = <code>SPARSE_COPY_BOTH</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sorted</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Index of the row. </td></tr>
    <tr><td class="paramname">vbuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1BlockWorkspace.html#a7dbf988dde45119d189517b2d435edf6">RowBlockWorkspace::length</a></code> values. </td></tr>
    <tr><td class="paramname">ibuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1BlockWorkspace.html#a7dbf988dde45119d189517b2d435edf6">RowBlockWorkspace::length</a></code> indices. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to a workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#aa62c3f22f2f82f93b81596caf27ededd">new_row_workspace()</a></code>. </td></tr>
    <tr><td class="paramname">copy</td><td>Whether the non-zero values and/or indices should be copied into <code>vbuffer</code> and <code>ibuffer</code>, respectively. </td></tr>
    <tr><td class="paramname">sorted</td><td>Should the non-zero elements be sorted by their indices? See <code><a class="el" href="classtatami_1_1Matrix.html#aa75bd1d084698e5df87796ecfe3fffb6">sparse_row()</a></code> for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structtatami_1_1SparseRange.html" title="A range of a sparse vector.">SparseRange</a></code> object describing the contents of a block of columns in row <code>r</code>. Depending on <code>copy</code>, values and indices will be copied into <code>vbuffer</code> and/or <code>ibuffer</code>. </dd></dl>

</div>
</div>
<a id="a3c68c3c8aab41106934efe98fdfdec88" name="a3c68c3c8aab41106934efe98fdfdec88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c68c3c8aab41106934efe98fdfdec88">&#9670;&#160;</a></span>sparse_column_copy() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::sparse_column_copy </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>vbuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IDX *&#160;</td>
          <td class="paramname"><em>ibuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a1f0f1615a5c86e37678138caef489563">ColumnBlockWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#ac4dba1039cc39910b0dd3bcccfea0f71">SparseCopyMode</a>&#160;</td>
          <td class="paramname"><em>copy</em> = <code>SPARSE_COPY_BOTH</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sorted</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Index of the column. </td></tr>
    <tr><td class="paramname">vbuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1BlockWorkspace.html#a7dbf988dde45119d189517b2d435edf6">ColumnBlockWorkspace::length</a></code> values. </td></tr>
    <tr><td class="paramname">ibuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1BlockWorkspace.html#a7dbf988dde45119d189517b2d435edf6">ColumnBlockWorkspace::length</a></code> indices. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to a workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#aa62c3f22f2f82f93b81596caf27ededd">new_row_workspace()</a></code>. </td></tr>
    <tr><td class="paramname">copy</td><td>Whether the non-zero values and/or indices should be copied into <code>vbuffer</code> and <code>ibuffer</code>, respectively. </td></tr>
    <tr><td class="paramname">sorted</td><td>Should the non-zero elements be sorted by their indices? See <code><a class="el" href="classtatami_1_1Matrix.html#af294706bdf2074efd08b3e1db0456ca1">sparse_column()</a></code> for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structtatami_1_1SparseRange.html" title="A range of a sparse vector.">SparseRange</a></code> object describing the contents of a block of rows in column <code>c</code>. Depending on <code>copy</code>, values and indices will be copied into <code>vbuffer</code> and/or <code>ibuffer</code>. </dd></dl>

</div>
</div>
<a id="ae6b78113e3d23ecf47efe20c17e59028" name="ae6b78113e3d23ecf47efe20c17e59028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b78113e3d23ecf47efe20c17e59028">&#9670;&#160;</a></span>sparse_row_copy() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::sparse_row_copy </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>vbuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IDX *&#160;</td>
          <td class="paramname"><em>ibuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a8dacf3f8e448e211c63056656e24d0b8">RowIndexWorkspace</a>&lt; IDX &gt; *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#ac4dba1039cc39910b0dd3bcccfea0f71">SparseCopyMode</a>&#160;</td>
          <td class="paramname"><em>copy</em> = <code>SPARSE_COPY_BOTH</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sorted</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Index of the row. </td></tr>
    <tr><td class="paramname">vbuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1IndexWorkspace.html#aa48b3242c66017689d36d6570e04cb49">RowIndexWorkspace::length</a></code> values. </td></tr>
    <tr><td class="paramname">ibuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1IndexWorkspace.html#aa48b3242c66017689d36d6570e04cb49">RowIndexWorkspace::length</a></code> indices. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to a workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#aa62c3f22f2f82f93b81596caf27ededd">new_row_workspace()</a></code>. </td></tr>
    <tr><td class="paramname">copy</td><td>Whether the non-zero values and/or indices should be copied into <code>vbuffer</code> and <code>ibuffer</code>, respectively. </td></tr>
    <tr><td class="paramname">sorted</td><td>Should the non-zero elements be sorted by their indices? See <code><a class="el" href="classtatami_1_1Matrix.html#aa75bd1d084698e5df87796ecfe3fffb6">sparse_row()</a></code> for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structtatami_1_1SparseRange.html" title="A range of a sparse vector.">SparseRange</a></code> object describing the contents of a subset of columns in row <code>r</code>. Depending on <code>copy</code>, values and indices will be copied into <code>vbuffer</code> and/or <code>ibuffer</code>. </dd></dl>

</div>
</div>
<a id="a32061a22c9773763e8adf8d4decffc63" name="a32061a22c9773763e8adf8d4decffc63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32061a22c9773763e8adf8d4decffc63">&#9670;&#160;</a></span>sparse_column_copy() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::sparse_column_copy </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>vbuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IDX *&#160;</td>
          <td class="paramname"><em>ibuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a9de74505bea2d3c1139479047b133f3d">ColumnIndexWorkspace</a>&lt; IDX &gt; *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#ac4dba1039cc39910b0dd3bcccfea0f71">SparseCopyMode</a>&#160;</td>
          <td class="paramname"><em>copy</em> = <code>SPARSE_COPY_BOTH</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sorted</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Index of the column. </td></tr>
    <tr><td class="paramname">vbuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1IndexWorkspace.html#aa48b3242c66017689d36d6570e04cb49">ColumnIndexWorkspace::length</a></code> values. </td></tr>
    <tr><td class="paramname">ibuffer</td><td>Pointer to an array with enough space for at least <code><a class="el" href="classtatami_1_1IndexWorkspace.html#aa48b3242c66017689d36d6570e04cb49">ColumnIndexWorkspace::length</a></code> indices. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to a workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#aa62c3f22f2f82f93b81596caf27ededd">new_row_workspace()</a></code>. </td></tr>
    <tr><td class="paramname">copy</td><td>Whether the non-zero values and/or indices should be copied into <code>vbuffer</code> and <code>ibuffer</code>, respectively. </td></tr>
    <tr><td class="paramname">sorted</td><td>Should the non-zero elements be sorted by their indices? See <code><a class="el" href="classtatami_1_1Matrix.html#af294706bdf2074efd08b3e1db0456ca1">sparse_column()</a></code> for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structtatami_1_1SparseRange.html" title="A range of a sparse vector.">SparseRange</a></code> object describing the contents of a subset of rows in column <code>c</code>. Depending on <code>copy</code>, values and indices will be copied into <code>vbuffer</code> and/or <code>ibuffer</code>. </dd></dl>

</div>
</div>
<a id="af56641ca2112efc31e1c6ab475726b50" name="af56641ca2112efc31e1c6ab475726b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af56641ca2112efc31e1c6ab475726b50">&#9670;&#160;</a></span>sparse_row() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1SparseRangeCopy.html">SparseRangeCopy</a>&lt; T, IDX &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::sparse_row </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a4a4650628564a58b961b7df8e2a83ac8">RowWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sorted</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A more convenient but less efficient version of the <code><a class="el" href="classtatami_1_1Matrix.html#aa75bd1d084698e5df87796ecfe3fffb6">sparse_row()</a></code> method. Callers do not have to supply the buffers; instead a new allocation is performed every time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Index of the row. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to a workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#aa62c3f22f2f82f93b81596caf27ededd">new_row_workspace()</a></code>. </td></tr>
    <tr><td class="paramname">sorted</td><td>Should the non-zero elements be sorted by their indices? See <code><a class="el" href="classtatami_1_1Matrix.html#aa75bd1d084698e5df87796ecfe3fffb6">sparse_row()</a></code> for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structtatami_1_1SparseRangeCopy.html" title="A range of a sparse vector with copying.">SparseRangeCopy</a></code> object containing the contents of row <code>r</code>. </dd></dl>

</div>
</div>
<a id="a418be2669371c8bcc9a7c042001e5449" name="a418be2669371c8bcc9a7c042001e5449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a418be2669371c8bcc9a7c042001e5449">&#9670;&#160;</a></span>sparse_column() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1SparseRangeCopy.html">SparseRangeCopy</a>&lt; T, IDX &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::sparse_column </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a60a9117c28a1c409e7b7b3836be9531a">ColumnWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sorted</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A more convenient but less efficient version of the <code><a class="el" href="classtatami_1_1Matrix.html#af294706bdf2074efd08b3e1db0456ca1">sparse_column()</a></code> method. Callers do not have to supply the buffers; instead a new allocation is performed every time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Index of the column. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to a workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#a8e0dbb0132e1b132a9164c20729e21d5">new_column_workspace()</a></code>. </td></tr>
    <tr><td class="paramname">sorted</td><td>Should the non-zero elements be sorted by their indices? See <code><a class="el" href="classtatami_1_1Matrix.html#af294706bdf2074efd08b3e1db0456ca1">sparse_column()</a></code> for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structtatami_1_1SparseRangeCopy.html" title="A range of a sparse vector with copying.">SparseRangeCopy</a></code> object containing the contents of column <code>c</code>. </dd></dl>

</div>
</div>
<a id="a2565998990e5f5af2f4d2251bf6181fc" name="a2565998990e5f5af2f4d2251bf6181fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2565998990e5f5af2f4d2251bf6181fc">&#9670;&#160;</a></span>sparse_row() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1SparseRangeCopy.html">SparseRangeCopy</a>&lt; T, IDX &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::sparse_row </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a100a9dd1056492a6687199cc1b341c08">RowBlockWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sorted</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A more convenient but less efficient version of the <code><a class="el" href="classtatami_1_1Matrix.html#aa75bd1d084698e5df87796ecfe3fffb6">sparse_row()</a></code> method. Callers do not have to supply the buffers; instead a new allocation is performed every time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Index of the row. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to a workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#aa62c3f22f2f82f93b81596caf27ededd">new_row_workspace()</a></code>. </td></tr>
    <tr><td class="paramname">sorted</td><td>Should the non-zero elements be sorted by their indices? See <code><a class="el" href="classtatami_1_1Matrix.html#aa75bd1d084698e5df87796ecfe3fffb6">sparse_row()</a></code> for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structtatami_1_1SparseRangeCopy.html" title="A range of a sparse vector with copying.">SparseRangeCopy</a></code> object containing the contents of a block of columns in row <code>r</code>. </dd></dl>

</div>
</div>
<a id="a94face240af1ec765f084b0dce0a7395" name="a94face240af1ec765f084b0dce0a7395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94face240af1ec765f084b0dce0a7395">&#9670;&#160;</a></span>sparse_column() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1SparseRangeCopy.html">SparseRangeCopy</a>&lt; T, IDX &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::sparse_column </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a1f0f1615a5c86e37678138caef489563">ColumnBlockWorkspace</a> *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sorted</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A more convenient but less efficient version of the <code><a class="el" href="classtatami_1_1Matrix.html#af294706bdf2074efd08b3e1db0456ca1">sparse_column()</a></code> method. Callers do not have to supply the buffers; instead a new allocation is performed every time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Index of the column. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to a workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#a8e0dbb0132e1b132a9164c20729e21d5">new_column_workspace()</a></code>. </td></tr>
    <tr><td class="paramname">sorted</td><td>Should the non-zero elements be sorted by their indices? See <code><a class="el" href="classtatami_1_1Matrix.html#af294706bdf2074efd08b3e1db0456ca1">sparse_column()</a></code> for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structtatami_1_1SparseRangeCopy.html" title="A range of a sparse vector with copying.">SparseRangeCopy</a></code> object containing the contents of a block of rows in column <code>c</code>. </dd></dl>

</div>
</div>
<a id="a77d19b893748e5026eeec9e87e8d8cf1" name="a77d19b893748e5026eeec9e87e8d8cf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d19b893748e5026eeec9e87e8d8cf1">&#9670;&#160;</a></span>sparse_row() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1SparseRangeCopy.html">SparseRangeCopy</a>&lt; T, IDX &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::sparse_row </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a8dacf3f8e448e211c63056656e24d0b8">RowIndexWorkspace</a>&lt; IDX &gt; *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sorted</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A more convenient but less efficient version of the <code><a class="el" href="classtatami_1_1Matrix.html#aa75bd1d084698e5df87796ecfe3fffb6">sparse_row()</a></code> method. Callers do not have to supply the buffers; instead a new allocation is performed every time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Index of the row. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to a workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#aa62c3f22f2f82f93b81596caf27ededd">new_row_workspace()</a></code>. </td></tr>
    <tr><td class="paramname">sorted</td><td>Should the non-zero elements be sorted by their indices? See <code><a class="el" href="classtatami_1_1Matrix.html#aa75bd1d084698e5df87796ecfe3fffb6">sparse_row()</a></code> for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structtatami_1_1SparseRangeCopy.html" title="A range of a sparse vector with copying.">SparseRangeCopy</a></code> object containing the contents of a subset of columns in row <code>r</code>. </dd></dl>

</div>
</div>
<a id="aa4bf867231d9760eeb2773f1c1e4f2cc" name="aa4bf867231d9760eeb2773f1c1e4f2cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4bf867231d9760eeb2773f1c1e4f2cc">&#9670;&#160;</a></span>sparse_column() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1SparseRangeCopy.html">SparseRangeCopy</a>&lt; T, IDX &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; T, IDX &gt;::sparse_column </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a9de74505bea2d3c1139479047b133f3d">ColumnIndexWorkspace</a>&lt; IDX &gt; *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sorted</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A more convenient but less efficient version of the <code><a class="el" href="classtatami_1_1Matrix.html#af294706bdf2074efd08b3e1db0456ca1">sparse_column()</a></code> method. Callers do not have to supply the buffers; instead a new allocation is performed every time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Index of the column. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to a workspace created with <code><a class="el" href="classtatami_1_1Matrix.html#a8e0dbb0132e1b132a9164c20729e21d5">new_column_workspace()</a></code>. </td></tr>
    <tr><td class="paramname">sorted</td><td>Should the non-zero elements be sorted by their indices? See <code><a class="el" href="classtatami_1_1Matrix.html#af294706bdf2074efd08b3e1db0456ca1">sparse_column()</a></code> for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structtatami_1_1SparseRangeCopy.html" title="A range of a sparse vector with copying.">SparseRangeCopy</a></code> object containing the contents of a subset of rows in column <code>c</code>. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>tatami/base/<a class="el" href="Matrix_8hpp_source.html">Matrix.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
