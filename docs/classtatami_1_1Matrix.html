<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tatami: tatami::Matrix&lt; Value_, Index_ &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tatami
   </div>
   <div id="projectbrief">C++ API for different matrix representations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetatami.html">tatami</a></li><li class="navelem"><a class="el" href="classtatami_1_1Matrix.html">Matrix</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classtatami_1_1Matrix-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">tatami::Matrix&lt; Value_, Index_ &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Virtual class for a matrix.  
 <a href="classtatami_1_1Matrix.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Matrix_8hpp_source.html">Matrix.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5b783d3ab440b7696c635a4b16516ba8" id="r_a5b783d3ab440b7696c635a4b16516ba8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typedef</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a5b783d3ab440b7696c635a4b16516ba8">value_type</a></td></tr>
<tr class="separator:a5b783d3ab440b7696c635a4b16516ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adebf536caf3a3c1751eefc6e10f0b16e" id="r_adebf536caf3a3c1751eefc6e10f0b16e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typedef</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#adebf536caf3a3c1751eefc6e10f0b16e">index_type</a></td></tr>
<tr class="separator:adebf536caf3a3c1751eefc6e10f0b16e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a54fe7b4baf78069d35ff00357a1b6cc6" id="r_a54fe7b4baf78069d35ff00357a1b6cc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">virtual</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a54fe7b4baf78069d35ff00357a1b6cc6">nrow</a> () <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> =0</td></tr>
<tr class="separator:a54fe7b4baf78069d35ff00357a1b6cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6fec43d5bae3f831841646bc02377b" id="r_a1f6fec43d5bae3f831841646bc02377b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">virtual</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a1f6fec43d5bae3f831841646bc02377b">ncol</a> () <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> =0</td></tr>
<tr class="separator:a1f6fec43d5bae3f831841646bc02377b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57d65707ce22d8c175e43a82b8c6b90" id="r_ac57d65707ce22d8c175e43a82b8c6b90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">virtual</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#ac57d65707ce22d8c175e43a82b8c6b90">is_sparse</a> () <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> =0</td></tr>
<tr class="separator:ac57d65707ce22d8c175e43a82b8c6b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa72c81add2701b7e484a7855b0e62b12" id="r_aa72c81add2701b7e484a7855b0e62b12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">virtual</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#aa72c81add2701b7e484a7855b0e62b12">is_sparse_proportion</a> () <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> =0</td></tr>
<tr class="separator:aa72c81add2701b7e484a7855b0e62b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69382d2a4e66cda1a9eb48dc25ab113a" id="r_a69382d2a4e66cda1a9eb48dc25ab113a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">virtual</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a69382d2a4e66cda1a9eb48dc25ab113a">prefer_rows</a> () <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> =0</td></tr>
<tr class="separator:a69382d2a4e66cda1a9eb48dc25ab113a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ddcc730155ca894df1c58b0a963d5e7" id="r_a2ddcc730155ca894df1c58b0a963d5e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">virtual</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a2ddcc730155ca894df1c58b0a963d5e7">prefer_rows_proportion</a> () <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> =0</td></tr>
<tr class="separator:a2ddcc730155ca894df1c58b0a963d5e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68da21245203cf9349648c5452cdb2ca" id="r_a68da21245203cf9349648c5452cdb2ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">virtual</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a68da21245203cf9349648c5452cdb2ca">uses_oracle</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">row</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> =0</td></tr>
<tr class="separator:a68da21245203cf9349648c5452cdb2ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6b1ae7819fad55cf7bf5587b7e5a4b" id="r_a0b6b1ae7819fad55cf7bf5587b7e5a4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">virtual</a> std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a0b6b1ae7819fad55cf7bf5587b7e5a4b">dense</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">row</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">opt</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> =0</td></tr>
<tr class="separator:a0b6b1ae7819fad55cf7bf5587b7e5a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51bb7a480d2fd0cc0337577ca98840dc" id="r_a51bb7a480d2fd0cc0337577ca98840dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">virtual</a> std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a51bb7a480d2fd0cc0337577ca98840dc">dense</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">row</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> block_start, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> block_length, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">opt</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> =0</td></tr>
<tr class="separator:a51bb7a480d2fd0cc0337577ca98840dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06803687627cc35e5ef41a887f5e5fad" id="r_a06803687627cc35e5ef41a887f5e5fad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">virtual</a> std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a06803687627cc35e5ef41a887f5e5fad">dense</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">row</a>, <a class="el" href="namespacetatami.html#abbb0bdf0b79fe19e504b49b43984f634">VectorPtr</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; indices_ptr, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">opt</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> =0</td></tr>
<tr class="separator:a06803687627cc35e5ef41a887f5e5fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168f0e932b5503c9bfc5dbd42754a7a5" id="r_a168f0e932b5503c9bfc5dbd42754a7a5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a168f0e932b5503c9bfc5dbd42754a7a5">dense_row</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">opt</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a168f0e932b5503c9bfc5dbd42754a7a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6505ab08f36ab2e2487f7598a8df4e" id="r_a3d6505ab08f36ab2e2487f7598a8df4e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a3d6505ab08f36ab2e2487f7598a8df4e">dense_row</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> block_start, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> block_length, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">opt</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a3d6505ab08f36ab2e2487f7598a8df4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b6f4909657d2e44196a56c99ffafb5c" id="r_a4b6f4909657d2e44196a56c99ffafb5c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a4b6f4909657d2e44196a56c99ffafb5c">dense_row</a> (<a class="el" href="namespacetatami.html#abbb0bdf0b79fe19e504b49b43984f634">VectorPtr</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; indices_ptr, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">opt</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a4b6f4909657d2e44196a56c99ffafb5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563d877fa76c04d1faa039ebab88038c" id="r_a563d877fa76c04d1faa039ebab88038c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a563d877fa76c04d1faa039ebab88038c">dense_row</a> (std::vector&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; indices, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">opt</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a563d877fa76c04d1faa039ebab88038c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48300b3739f26bb10732c572ea9e5c57" id="r_a48300b3739f26bb10732c572ea9e5c57"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a48300b3739f26bb10732c572ea9e5c57">dense_column</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">opt</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a48300b3739f26bb10732c572ea9e5c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9daf387535987b84f7b44c68fb664d33" id="r_a9daf387535987b84f7b44c68fb664d33"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a9daf387535987b84f7b44c68fb664d33">dense_column</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> block_start, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> block_length, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">opt</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a9daf387535987b84f7b44c68fb664d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce124d5abc915f47e0abdec500b84f3" id="r_a8ce124d5abc915f47e0abdec500b84f3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a8ce124d5abc915f47e0abdec500b84f3">dense_column</a> (<a class="el" href="namespacetatami.html#abbb0bdf0b79fe19e504b49b43984f634">VectorPtr</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; indices_ptr, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">opt</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a8ce124d5abc915f47e0abdec500b84f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace58cae1956cbf7474aa7120e0d89cc9" id="r_ace58cae1956cbf7474aa7120e0d89cc9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#ace58cae1956cbf7474aa7120e0d89cc9">dense_column</a> (std::vector&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; indices, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">opt</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:ace58cae1956cbf7474aa7120e0d89cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d572f319b614a7e74d426cac94194de" id="r_a4d572f319b614a7e74d426cac94194de"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a4d572f319b614a7e74d426cac94194de">dense_row</a> () <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a4d572f319b614a7e74d426cac94194de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb45e8a21e1792a316fa95064edb9c2" id="r_aacb45e8a21e1792a316fa95064edb9c2"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#aacb45e8a21e1792a316fa95064edb9c2">dense_row</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> block_start, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> block_length) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:aacb45e8a21e1792a316fa95064edb9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a371fa940bc33a019b1f6938c2b06201f" id="r_a371fa940bc33a019b1f6938c2b06201f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a371fa940bc33a019b1f6938c2b06201f">dense_row</a> (<a class="el" href="namespacetatami.html#abbb0bdf0b79fe19e504b49b43984f634">VectorPtr</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; indices_ptr) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a371fa940bc33a019b1f6938c2b06201f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3692e08db0886e4e866e28942d46b0" id="r_a3f3692e08db0886e4e866e28942d46b0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a3f3692e08db0886e4e866e28942d46b0">dense_row</a> (std::vector&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; indices) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a3f3692e08db0886e4e866e28942d46b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2dad77430f29f277f73028c7c2636e2" id="r_aa2dad77430f29f277f73028c7c2636e2"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#aa2dad77430f29f277f73028c7c2636e2">dense_column</a> () <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:aa2dad77430f29f277f73028c7c2636e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a478f96c3a39b40a950dda3d115365c89" id="r_a478f96c3a39b40a950dda3d115365c89"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a478f96c3a39b40a950dda3d115365c89">dense_column</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> block_start, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> block_length) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a478f96c3a39b40a950dda3d115365c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9058c33bd860936d0a6fe4f03397f6b9" id="r_a9058c33bd860936d0a6fe4f03397f6b9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a9058c33bd860936d0a6fe4f03397f6b9">dense_column</a> (<a class="el" href="namespacetatami.html#abbb0bdf0b79fe19e504b49b43984f634">VectorPtr</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; indices_ptr) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a9058c33bd860936d0a6fe4f03397f6b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b82bffd2c71c4301867e8a0ffcf37f3" id="r_a7b82bffd2c71c4301867e8a0ffcf37f3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a7b82bffd2c71c4301867e8a0ffcf37f3">dense_column</a> (std::vector&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; indices) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a7b82bffd2c71c4301867e8a0ffcf37f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84772cc4e911a87948d45a1edcabbd0" id="r_af84772cc4e911a87948d45a1edcabbd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">virtual</a> std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#af84772cc4e911a87948d45a1edcabbd0">sparse</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">row</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">opt</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> =0</td></tr>
<tr class="separator:af84772cc4e911a87948d45a1edcabbd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af802c74c510eff3316ce0eea99c08810" id="r_af802c74c510eff3316ce0eea99c08810"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">virtual</a> std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#af802c74c510eff3316ce0eea99c08810">sparse</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">row</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> block_start, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> block_length, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">opt</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> =0</td></tr>
<tr class="separator:af802c74c510eff3316ce0eea99c08810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d055aed809a2036c10c1fce92bd036" id="r_a59d055aed809a2036c10c1fce92bd036"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">virtual</a> std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a59d055aed809a2036c10c1fce92bd036">sparse</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">row</a>, <a class="el" href="namespacetatami.html#abbb0bdf0b79fe19e504b49b43984f634">VectorPtr</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; indices_ptr, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">opt</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> =0</td></tr>
<tr class="separator:a59d055aed809a2036c10c1fce92bd036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb3651992dff44cdf8d560a527707f6" id="r_afcb3651992dff44cdf8d560a527707f6"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#afcb3651992dff44cdf8d560a527707f6">sparse_row</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">opt</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:afcb3651992dff44cdf8d560a527707f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada39dd5987e82eb0aa50c302ee3ed564" id="r_ada39dd5987e82eb0aa50c302ee3ed564"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#ada39dd5987e82eb0aa50c302ee3ed564">sparse_row</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> block_start, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> block_length, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">opt</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:ada39dd5987e82eb0aa50c302ee3ed564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64a711a19ebc55da7b5fdc193db839c" id="r_ac64a711a19ebc55da7b5fdc193db839c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#ac64a711a19ebc55da7b5fdc193db839c">sparse_row</a> (<a class="el" href="namespacetatami.html#abbb0bdf0b79fe19e504b49b43984f634">VectorPtr</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; indices_ptr, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">opt</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:ac64a711a19ebc55da7b5fdc193db839c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb26d2551fec7753001e8c274c9661de" id="r_afb26d2551fec7753001e8c274c9661de"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#afb26d2551fec7753001e8c274c9661de">sparse_row</a> (std::vector&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; indices, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">opt</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:afb26d2551fec7753001e8c274c9661de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed47eef4ab4a6563db02acc77e22e5eb" id="r_aed47eef4ab4a6563db02acc77e22e5eb"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#aed47eef4ab4a6563db02acc77e22e5eb">sparse_column</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">opt</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:aed47eef4ab4a6563db02acc77e22e5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45028c0259b57630cdc23e4f3d08835" id="r_ad45028c0259b57630cdc23e4f3d08835"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#ad45028c0259b57630cdc23e4f3d08835">sparse_column</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> block_start, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> block_length, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">opt</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:ad45028c0259b57630cdc23e4f3d08835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f340c985ed28a230745d87c9cd6ac44" id="r_a9f340c985ed28a230745d87c9cd6ac44"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a9f340c985ed28a230745d87c9cd6ac44">sparse_column</a> (<a class="el" href="namespacetatami.html#abbb0bdf0b79fe19e504b49b43984f634">VectorPtr</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; indices_ptr, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">opt</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a9f340c985ed28a230745d87c9cd6ac44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a518b8f184afb562e8ef722c2feef0875" id="r_a518b8f184afb562e8ef722c2feef0875"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a518b8f184afb562e8ef722c2feef0875">sparse_column</a> (std::vector&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; indices, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">opt</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a518b8f184afb562e8ef722c2feef0875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedecd4c23762ff43f49cfb0d2c687056" id="r_aedecd4c23762ff43f49cfb0d2c687056"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#aedecd4c23762ff43f49cfb0d2c687056">sparse_row</a> () <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:aedecd4c23762ff43f49cfb0d2c687056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2aecb2560e570ec8f6e3efb0eddf55d" id="r_ad2aecb2560e570ec8f6e3efb0eddf55d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#ad2aecb2560e570ec8f6e3efb0eddf55d">sparse_row</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> block_start, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> block_length) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:ad2aecb2560e570ec8f6e3efb0eddf55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe0fed52aae518a420114727e1c98a1" id="r_acbe0fed52aae518a420114727e1c98a1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#acbe0fed52aae518a420114727e1c98a1">sparse_row</a> (<a class="el" href="namespacetatami.html#abbb0bdf0b79fe19e504b49b43984f634">VectorPtr</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; indices_ptr) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:acbe0fed52aae518a420114727e1c98a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3011f5e2ee8103fcc4c6488bfd228997" id="r_a3011f5e2ee8103fcc4c6488bfd228997"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a3011f5e2ee8103fcc4c6488bfd228997">sparse_row</a> (std::vector&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; indices) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a3011f5e2ee8103fcc4c6488bfd228997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0efad968be5f4b9a36bb50beb8460f8" id="r_ab0efad968be5f4b9a36bb50beb8460f8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#ab0efad968be5f4b9a36bb50beb8460f8">sparse_column</a> () <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:ab0efad968be5f4b9a36bb50beb8460f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f592922949fc50786de3eb6f58d0be" id="r_a51f592922949fc50786de3eb6f58d0be"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a51f592922949fc50786de3eb6f58d0be">sparse_column</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> block_start, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> block_length) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a51f592922949fc50786de3eb6f58d0be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb6b4e90e3ab5cf0112e7cbd31f18f4" id="r_adfb6b4e90e3ab5cf0112e7cbd31f18f4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#adfb6b4e90e3ab5cf0112e7cbd31f18f4">sparse_column</a> (<a class="el" href="namespacetatami.html#abbb0bdf0b79fe19e504b49b43984f634">VectorPtr</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; indices_ptr) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:adfb6b4e90e3ab5cf0112e7cbd31f18f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebbd197a7d1530397cff04660e78f28f" id="r_aebbd197a7d1530397cff04660e78f28f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#aebbd197a7d1530397cff04660e78f28f">sparse_column</a> (std::vector&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; indices) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:aebbd197a7d1530397cff04660e78f28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6502fdebcaeea40490c1780ab6e92b19" id="r_a6502fdebcaeea40490c1780ab6e92b19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">virtual</a> std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a6502fdebcaeea40490c1780ab6e92b19">dense</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">row</a>, std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; oracle, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">opt</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> =0</td></tr>
<tr class="separator:a6502fdebcaeea40490c1780ab6e92b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b24fe319289ca76f2b366a2ffe798d" id="r_a48b24fe319289ca76f2b366a2ffe798d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">virtual</a> std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a48b24fe319289ca76f2b366a2ffe798d">dense</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">row</a>, std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; oracle, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> block_start, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> block_length, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">opt</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> =0</td></tr>
<tr class="separator:a48b24fe319289ca76f2b366a2ffe798d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aecaa5038554d2c92c2ab7083497cb6" id="r_a4aecaa5038554d2c92c2ab7083497cb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">virtual</a> std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a4aecaa5038554d2c92c2ab7083497cb6">dense</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">row</a>, std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; oracle, <a class="el" href="namespacetatami.html#abbb0bdf0b79fe19e504b49b43984f634">VectorPtr</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; indices_ptr, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">opt</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> =0</td></tr>
<tr class="separator:a4aecaa5038554d2c92c2ab7083497cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60952db300c69580a9eba01b5f787d6" id="r_aa60952db300c69580a9eba01b5f787d6"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#aa60952db300c69580a9eba01b5f787d6">dense_row</a> (std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; oracle, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">opt</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:aa60952db300c69580a9eba01b5f787d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc57cd1f625bdc44af4946a0124f7464" id="r_acc57cd1f625bdc44af4946a0124f7464"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#acc57cd1f625bdc44af4946a0124f7464">dense_row</a> (std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; oracle, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> block_start, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> block_length, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">opt</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:acc57cd1f625bdc44af4946a0124f7464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab247d39db776da3e2143f4599f76920e" id="r_ab247d39db776da3e2143f4599f76920e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#ab247d39db776da3e2143f4599f76920e">dense_row</a> (std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; oracle, <a class="el" href="namespacetatami.html#abbb0bdf0b79fe19e504b49b43984f634">VectorPtr</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; indices_ptr, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">opt</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:ab247d39db776da3e2143f4599f76920e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f53f2f7b2a2e5972a91a56065ba28b" id="r_ad8f53f2f7b2a2e5972a91a56065ba28b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#ad8f53f2f7b2a2e5972a91a56065ba28b">dense_row</a> (std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; oracle, std::vector&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; indices, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">opt</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:ad8f53f2f7b2a2e5972a91a56065ba28b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca1e41bc821f551d76175687fd2e6b5" id="r_a8ca1e41bc821f551d76175687fd2e6b5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a8ca1e41bc821f551d76175687fd2e6b5">dense_column</a> (std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; oracle, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">opt</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a8ca1e41bc821f551d76175687fd2e6b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2323a04228d638ec0340036acafa420f" id="r_a2323a04228d638ec0340036acafa420f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a2323a04228d638ec0340036acafa420f">dense_column</a> (std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; oracle, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> block_start, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> block_length, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">opt</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a2323a04228d638ec0340036acafa420f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d717304d7cf4806c182ecd446de144d" id="r_a8d717304d7cf4806c182ecd446de144d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a8d717304d7cf4806c182ecd446de144d">dense_column</a> (std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; oracle, <a class="el" href="namespacetatami.html#abbb0bdf0b79fe19e504b49b43984f634">VectorPtr</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; indices_ptr, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">opt</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a8d717304d7cf4806c182ecd446de144d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585337cdd3a90c5cf6cf2fdca2b43e84" id="r_a585337cdd3a90c5cf6cf2fdca2b43e84"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a585337cdd3a90c5cf6cf2fdca2b43e84">dense_column</a> (std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; oracle, std::vector&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; indices, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">opt</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a585337cdd3a90c5cf6cf2fdca2b43e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb2b21aad79130762a8cb0c7069d3a3" id="r_a9fb2b21aad79130762a8cb0c7069d3a3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a9fb2b21aad79130762a8cb0c7069d3a3">dense_row</a> (std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; oracle) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a9fb2b21aad79130762a8cb0c7069d3a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cecc240982c961455ede8d329cda207" id="r_a2cecc240982c961455ede8d329cda207"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a2cecc240982c961455ede8d329cda207">dense_row</a> (std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; oracle, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> block_start, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> block_length) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a2cecc240982c961455ede8d329cda207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32275c6bf6553d6b1833abdce9165b5d" id="r_a32275c6bf6553d6b1833abdce9165b5d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a32275c6bf6553d6b1833abdce9165b5d">dense_row</a> (std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; oracle, <a class="el" href="namespacetatami.html#abbb0bdf0b79fe19e504b49b43984f634">VectorPtr</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; indices_ptr) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a32275c6bf6553d6b1833abdce9165b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce58d2a5e7b244b49a97cabff56c94b" id="r_a6ce58d2a5e7b244b49a97cabff56c94b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a6ce58d2a5e7b244b49a97cabff56c94b">dense_row</a> (std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; oracle, std::vector&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; indices) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a6ce58d2a5e7b244b49a97cabff56c94b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068863a2b525300afb446aa249f67f6b" id="r_a068863a2b525300afb446aa249f67f6b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a068863a2b525300afb446aa249f67f6b">dense_column</a> (std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; oracle) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a068863a2b525300afb446aa249f67f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9d3994a74ebdf26894d92ad3625d8c" id="r_a3a9d3994a74ebdf26894d92ad3625d8c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a3a9d3994a74ebdf26894d92ad3625d8c">dense_column</a> (std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; oracle, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> block_start, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> block_length) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a3a9d3994a74ebdf26894d92ad3625d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d214b599712ab2f265b06d45d9e7047" id="r_a3d214b599712ab2f265b06d45d9e7047"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a3d214b599712ab2f265b06d45d9e7047">dense_column</a> (std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; oracle, <a class="el" href="namespacetatami.html#abbb0bdf0b79fe19e504b49b43984f634">VectorPtr</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; indices_ptr) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a3d214b599712ab2f265b06d45d9e7047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6421e936b7d10b2dee56c41c6591322e" id="r_a6421e936b7d10b2dee56c41c6591322e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a6421e936b7d10b2dee56c41c6591322e">dense_column</a> (std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; oracle, std::vector&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; indices) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a6421e936b7d10b2dee56c41c6591322e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5605c18620abdab0f82015b959e9813a" id="r_a5605c18620abdab0f82015b959e9813a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">virtual</a> std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a5605c18620abdab0f82015b959e9813a">sparse</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">row</a>, std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; oracle, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">opt</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> =0</td></tr>
<tr class="separator:a5605c18620abdab0f82015b959e9813a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacfcf54358970874051e5cc700730707" id="r_aacfcf54358970874051e5cc700730707"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">virtual</a> std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#aacfcf54358970874051e5cc700730707">sparse</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">row</a>, std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; oracle, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> block_start, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> block_length, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">opt</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> =0</td></tr>
<tr class="separator:aacfcf54358970874051e5cc700730707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7557a27bbb09f8453a3e6848ad910e" id="r_abe7557a27bbb09f8453a3e6848ad910e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">virtual</a> std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#abe7557a27bbb09f8453a3e6848ad910e">sparse</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">row</a>, std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; oracle, <a class="el" href="namespacetatami.html#abbb0bdf0b79fe19e504b49b43984f634">VectorPtr</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; indices_ptr, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">opt</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> =0</td></tr>
<tr class="separator:abe7557a27bbb09f8453a3e6848ad910e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9914398b94a1a9f3082478d9646fc21d" id="r_a9914398b94a1a9f3082478d9646fc21d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a9914398b94a1a9f3082478d9646fc21d">sparse_row</a> (std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; oracle, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">opt</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a9914398b94a1a9f3082478d9646fc21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67262da7611609ba28f9ac1d9ed20e9" id="r_af67262da7611609ba28f9ac1d9ed20e9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#af67262da7611609ba28f9ac1d9ed20e9">sparse_row</a> (std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; oracle, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> block_start, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> block_length, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">opt</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:af67262da7611609ba28f9ac1d9ed20e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af86c164710f168484a0037169bf51622" id="r_af86c164710f168484a0037169bf51622"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#af86c164710f168484a0037169bf51622">sparse_row</a> (std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; oracle, <a class="el" href="namespacetatami.html#abbb0bdf0b79fe19e504b49b43984f634">VectorPtr</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; indices_ptr, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">opt</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:af86c164710f168484a0037169bf51622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47155bacf33f5c269c8da4ce96d1adb8" id="r_a47155bacf33f5c269c8da4ce96d1adb8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a47155bacf33f5c269c8da4ce96d1adb8">sparse_row</a> (std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; oracle, std::vector&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; indices, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">opt</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a47155bacf33f5c269c8da4ce96d1adb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ce6f1c8ad4f4d2e8d62c8e005c7df8" id="r_a25ce6f1c8ad4f4d2e8d62c8e005c7df8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a25ce6f1c8ad4f4d2e8d62c8e005c7df8">sparse_column</a> (std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; oracle, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">opt</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a25ce6f1c8ad4f4d2e8d62c8e005c7df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576f3bd09c075d59101e561c715c82e2" id="r_a576f3bd09c075d59101e561c715c82e2"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a576f3bd09c075d59101e561c715c82e2">sparse_column</a> (std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; oracle, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> block_start, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> block_length, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">opt</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a576f3bd09c075d59101e561c715c82e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413c72fd73b8e156f3b2fb3f8ebd2497" id="r_a413c72fd73b8e156f3b2fb3f8ebd2497"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a413c72fd73b8e156f3b2fb3f8ebd2497">sparse_column</a> (std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; oracle, <a class="el" href="namespacetatami.html#abbb0bdf0b79fe19e504b49b43984f634">VectorPtr</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; indices_ptr, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">opt</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a413c72fd73b8e156f3b2fb3f8ebd2497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfbdd5c72c285b22942ce2714874b810" id="r_acfbdd5c72c285b22942ce2714874b810"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#acfbdd5c72c285b22942ce2714874b810">sparse_column</a> (std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; oracle, std::vector&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; indices, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">opt</a>) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:acfbdd5c72c285b22942ce2714874b810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69c3729445a087b33bfa9717b8e0bd1" id="r_ac69c3729445a087b33bfa9717b8e0bd1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#ac69c3729445a087b33bfa9717b8e0bd1">sparse_row</a> (std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; oracle) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:ac69c3729445a087b33bfa9717b8e0bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae052d20e59e1cd0c58915f1165c42b44" id="r_ae052d20e59e1cd0c58915f1165c42b44"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#ae052d20e59e1cd0c58915f1165c42b44">sparse_row</a> (std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; oracle, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> block_start, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> block_length) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:ae052d20e59e1cd0c58915f1165c42b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fc1dfadd943138f21cf3e9dd1f89147" id="r_a3fc1dfadd943138f21cf3e9dd1f89147"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a3fc1dfadd943138f21cf3e9dd1f89147">sparse_row</a> (std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; oracle, <a class="el" href="namespacetatami.html#abbb0bdf0b79fe19e504b49b43984f634">VectorPtr</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; indices_ptr) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a3fc1dfadd943138f21cf3e9dd1f89147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f8dbf2064d74038813b5c0191a6542" id="r_a59f8dbf2064d74038813b5c0191a6542"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a59f8dbf2064d74038813b5c0191a6542">sparse_row</a> (std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; oracle, std::vector&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; indices) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a59f8dbf2064d74038813b5c0191a6542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8274ac6fb2345fcece74e6fdb35e05d4" id="r_a8274ac6fb2345fcece74e6fdb35e05d4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a8274ac6fb2345fcece74e6fdb35e05d4">sparse_column</a> (std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; oracle) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a8274ac6fb2345fcece74e6fdb35e05d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9538dcc44c008dd203e719a855ac7fca" id="r_a9538dcc44c008dd203e719a855ac7fca"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a9538dcc44c008dd203e719a855ac7fca">sparse_column</a> (std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; oracle, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> block_start, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> block_length) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a9538dcc44c008dd203e719a855ac7fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917f575b5430e14e2ccda56a5b6903be" id="r_a917f575b5430e14e2ccda56a5b6903be"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a917f575b5430e14e2ccda56a5b6903be">sparse_column</a> (std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; oracle, <a class="el" href="namespacetatami.html#abbb0bdf0b79fe19e504b49b43984f634">VectorPtr</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; indices_ptr) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:a917f575b5430e14e2ccda56a5b6903be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c6514d93279e77fb8505d29c334217" id="r_ad3c6514d93279e77fb8505d29c334217"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#ad3c6514d93279e77fb8505d29c334217">sparse_column</a> (std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; oracle, std::vector&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; indices) <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a></td></tr>
<tr class="separator:ad3c6514d93279e77fb8505d29c334217"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> = int&gt;<br />
class tatami::Matrix&lt; Value_, Index_ &gt;</div><p>Virtual class for a matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value</td><td>Data value type, should be numeric. </td></tr>
    <tr><td class="paramname">Index</td><td>Row/column index type, should be integer.</td></tr>
  </table>
  </dd>
</dl>
<p>Interface for a matrix in the <b>tatami</b> library. This declares methods to iterate through the matrix by row or column, extracting data in either dense or sparse form. Check out <code><a class="el" href="classtatami_1_1DenseMatrix.html" title="Dense matrix representation.">DenseMatrix</a></code> and <code><a class="el" href="classtatami_1_1CompressedSparseMatrix.html" title="Compressed sparse matrix representation.">CompressedSparseMatrix</a></code> for examples of concrete subclasses.</p>
<p>To access the matrix data, the <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> methods first return an instance of an extractor class like <code><a class="el" href="structtatami_1_1MyopicDenseExtractor.html" title="Extract an element of the target dimension in dense form without an oracle.">MyopicDenseExtractor</a></code>, which can then be used to retrieve the matrix contents. Creation of the extractor depends on a few parameters:</p>
<ul>
<li>Choice of the "target" dimension. The "target" dimension is defined as the one that is iterated over/indexed into, while the "non-target" dimension is the other dimension. For example, if we were iterating row-wise through a matrix, the rows would constitute the target dimension, while the columns would be the non-target dimension. An element of the target dimension is obtained by indexing into that dimension, e.g., if the rows are the target dimension, then any particular row is an element of the target dimension.</li>
<li>Whether to restrict the non-target dimension (see <code><a class="el" href="namespacetatami.html#a0a2ecaf58e2b69bb4a808e814aeb16a1">tatami::DimensionSelectionType</a></code>). We can choose to extract the full extent of the non-target dimension, a contiguous block, or an indexed subset. For example, if we were iterating row-wise through a matrix, we might only be interested in a subset of columns.</li>
<li>Whether the order of accesses on the target dimension are known. If so, we can potentially improve efficiency by supplying an <code><a class="el" href="structtatami_1_1Oracle.html" title="Predict future access requests on the target dimension.">Oracle</a></code> during extractor construction. For example, if we know we will iterate through the matrix by consecutive rows, we could supply a <code><a class="el" href="structtatami_1_1ConsecutiveOracle.html" title="Predict future accesses along a consecutive sequence.">ConsecutiveOracle</a></code> to allow <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> implementations to optimize for this access pattern.</li>
<li>Whether to obtain the contents for a target dimension element in dense or sparse form. The dense form is simply a contiguous 1-dimensional array of matrix <code>Value_</code>s. The sparse form is a <code><a class="el" href="structtatami_1_1SparseRange.html" title="A range of a sparse vector.">SparseRange</a></code> describing the structural non-zeros for that dimension element.</li>
</ul>
<p><code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> subclasses should describe whether they are dense/sparse and if they prefer row or column access. This allows users to choose the best method of extracting data from the matrix. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a5b783d3ab440b7696c635a4b16516ba8" name="a5b783d3ab440b7696c635a4b16516ba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b783d3ab440b7696c635a4b16516ba8">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typedef</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::value_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of data to be returned by getters. </p>

</div>
</div>
<a id="adebf536caf3a3c1751eefc6e10f0b16e" name="adebf536caf3a3c1751eefc6e10f0b16e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adebf536caf3a3c1751eefc6e10f0b16e">&#9670;&#160;</a></span>index_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typedef</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::index_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of index to be returned by the sparse getters. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a54fe7b4baf78069d35ff00357a1b6cc6" name="a54fe7b4baf78069d35ff00357a1b6cc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54fe7b4baf78069d35ff00357a1b6cc6">&#9670;&#160;</a></span>nrow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">virtual</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::nrow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Number of rows. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1DenseMatrix.html#ab18c5c9611a0d989391b511d2430a1a4">tatami::DenseMatrix&lt; Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#ab18c5c9611a0d989391b511d2430a1a4">tatami::DenseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt; &gt;</a>, <a class="el" href="classtatami_1_1DelayedBinaryIsometricOp.html#ae948f15be02f19e00dd61056ea958a83">tatami::DelayedBinaryIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedUnaryIsometricOp.html#a27526af79dcb3b5a3b9460733355137e">tatami::DelayedUnaryIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a64f90b7152def0f1a53aadbac1901687">tatami::DelayedBind&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#a6669aa5ef922006a2c36b2a7d6770b80">tatami::DelayedCast&lt; ValueOut_, IndexOut_, ValueIn_, IndexIn_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#ae861c999ade80dfaab4e00ea0a3c9f89">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a3365d94d7ad16f89d780ba27deffa45a">tatami::CompressedSparseMatrix&lt; Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a3365d94d7ad16f89d780ba27deffa45a">tatami::CompressedSparseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt;, std::vector&lt; Index_ &gt;, std::vector&lt; size_t &gt; &gt;</a>, <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#a9632369fd9488210695dbd05b13a8ab5">tatami::FragmentedSparseMatrix&lt; Value_, Index_, ValueVectorStorage_, IndexVectorStorage_ &gt;</a>, <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#a9632369fd9488210695dbd05b13a8ab5">tatami::FragmentedSparseMatrix&lt; Value_, Index_, std::vector&lt; std::vector&lt; Value_ &gt; &gt;, std::vector&lt; std::vector&lt; Index_ &gt; &gt; &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#abc3051f952d1f8ca79b2558183477c00">tatami::DelayedSubset&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a1f09481f1564fe050f515ab893ab3cb7">tatami::DelayedSubsetBlock&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a0990b0042c6e09b843e7c73b46f63124">tatami::DelayedSubsetSorted&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#ab5dc1edede193463699fdc466e1c8838">tatami::DelayedSubsetSortedUnique&lt; Value_, Index_, IndexStorage_ &gt;</a>, and <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a3c73e20b55828b68de1e396da713dcab">tatami::DelayedSubsetUnique&lt; Value_, Index_, IndexStorage_ &gt;</a>.</p>

</div>
</div>
<a id="a1f6fec43d5bae3f831841646bc02377b" name="a1f6fec43d5bae3f831841646bc02377b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f6fec43d5bae3f831841646bc02377b">&#9670;&#160;</a></span>ncol()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">virtual</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::ncol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Number of columns. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1DenseMatrix.html#ae43ef7c94906bc7eb73f39dc720171f6">tatami::DenseMatrix&lt; Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#ae43ef7c94906bc7eb73f39dc720171f6">tatami::DenseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt; &gt;</a>, <a class="el" href="classtatami_1_1DelayedBinaryIsometricOp.html#a28043844566505282c396dfa00b15881">tatami::DelayedBinaryIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedUnaryIsometricOp.html#a57d5be64d07b2ca81dc232cbac702ea2">tatami::DelayedUnaryIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#acb743be5663d4fb13624ba0502448bd8">tatami::DelayedBind&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#aa83b0cdd9395331151d8292e786deeb7">tatami::DelayedCast&lt; ValueOut_, IndexOut_, ValueIn_, IndexIn_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a495080ac6d15551d6816adf85ab2d481">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#ae7a25c967b851a667885a2052ad6a45f">tatami::CompressedSparseMatrix&lt; Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#ae7a25c967b851a667885a2052ad6a45f">tatami::CompressedSparseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt;, std::vector&lt; Index_ &gt;, std::vector&lt; size_t &gt; &gt;</a>, <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#a427e1a6ab4a1eded1374b30c3d6f05ae">tatami::FragmentedSparseMatrix&lt; Value_, Index_, ValueVectorStorage_, IndexVectorStorage_ &gt;</a>, <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#a427e1a6ab4a1eded1374b30c3d6f05ae">tatami::FragmentedSparseMatrix&lt; Value_, Index_, std::vector&lt; std::vector&lt; Value_ &gt; &gt;, std::vector&lt; std::vector&lt; Index_ &gt; &gt; &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a74fcc25c68621f55b0779ed62db3cec8">tatami::DelayedSubset&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a397f04132c63c97c39afa68e2bc2f600">tatami::DelayedSubsetBlock&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#ad93ab7786a1384949ba18874b75992b4">tatami::DelayedSubsetSorted&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a391fa3e61a8070e388eee35364570817">tatami::DelayedSubsetSortedUnique&lt; Value_, Index_, IndexStorage_ &gt;</a>, and <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a0107c824547d26ee65af06f984127785">tatami::DelayedSubsetUnique&lt; Value_, Index_, IndexStorage_ &gt;</a>.</p>

</div>
</div>
<a id="ac57d65707ce22d8c175e43a82b8c6b90" name="ac57d65707ce22d8c175e43a82b8c6b90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac57d65707ce22d8c175e43a82b8c6b90">&#9670;&#160;</a></span>is_sparse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">virtual</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::is_sparse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Boolean indicating whether this matrix is sparse.</dd></dl>
<p>This can be used to choose between dense and sparse outputs. </p>

<p>Implemented in <a class="el" href="classtatami_1_1DenseMatrix.html#a4a362f61248baa1f4c13aaeafcd96dbb">tatami::DenseMatrix&lt; Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a4a362f61248baa1f4c13aaeafcd96dbb">tatami::DenseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt; &gt;</a>, <a class="el" href="classtatami_1_1DelayedBinaryIsometricOp.html#a2148fd4eb5371cc25c5dbc2c5ff873bf">tatami::DelayedBinaryIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedUnaryIsometricOp.html#a4b6a9444eeff37ceb1ee9953e0b87a1a">tatami::DelayedUnaryIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a79b7ed57367550ed4c2ddbc4798464f8">tatami::DelayedBind&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#aa2e8ede032453d49cbfbc98771a3fd6d">tatami::DelayedCast&lt; ValueOut_, IndexOut_, ValueIn_, IndexIn_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a64df8253602c0e2ad716b154b079c8aa">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#ada14aaaeb96bafe8d483ed2d3f91bb59">tatami::CompressedSparseMatrix&lt; Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#ada14aaaeb96bafe8d483ed2d3f91bb59">tatami::CompressedSparseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt;, std::vector&lt; Index_ &gt;, std::vector&lt; size_t &gt; &gt;</a>, <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#a9c14f99e0ef86e41742aec9d5c086996">tatami::FragmentedSparseMatrix&lt; Value_, Index_, ValueVectorStorage_, IndexVectorStorage_ &gt;</a>, <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#a9c14f99e0ef86e41742aec9d5c086996">tatami::FragmentedSparseMatrix&lt; Value_, Index_, std::vector&lt; std::vector&lt; Value_ &gt; &gt;, std::vector&lt; std::vector&lt; Index_ &gt; &gt; &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#ad7fb9953b1158dbf3f498fce7ca3aa35">tatami::DelayedSubset&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a77b5f60160bd1437e5ce142d8cdafab5">tatami::DelayedSubsetBlock&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a217ef766f41560aa0a51b6d3c57cdd72">tatami::DelayedSubsetSorted&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a622fd4d858aece682f9fb2e2f84a06e8">tatami::DelayedSubsetSortedUnique&lt; Value_, Index_, IndexStorage_ &gt;</a>, and <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a6debe7174c870f271aef94a4eb88e17c">tatami::DelayedSubsetUnique&lt; Value_, Index_, IndexStorage_ &gt;</a>.</p>

</div>
</div>
<a id="aa72c81add2701b7e484a7855b0e62b12" name="aa72c81add2701b7e484a7855b0e62b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa72c81add2701b7e484a7855b0e62b12">&#9670;&#160;</a></span>is_sparse_proportion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">virtual</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">double</a> <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::is_sparse_proportion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Approximate proportion of the matrix that is sparse.</dd></dl>
<p>This is defined as the proportion of matrix elements that lie within sparse submatrices. It is intended for use in <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> representations that consist of combinations of multiple submatrices (e.g., <code><a class="el" href="classtatami_1_1DelayedBind.html" title="Delayed combining of a matrix.">DelayedBind</a></code>), allowing them to derive a suitable value for <code><a class="el" href="classtatami_1_1Matrix.html#ac57d65707ce22d8c175e43a82b8c6b90">is_sparse()</a></code> based on whether most of its submatrices are sparse. (A more granular approach would be to report the density of structural non-zero elements, but this may not be known by all representations at construction time.) </p>

<p>Implemented in <a class="el" href="classtatami_1_1DenseMatrix.html#a884c8899818f7a8ea6a150c3684048ef">tatami::DenseMatrix&lt; Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a884c8899818f7a8ea6a150c3684048ef">tatami::DenseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt; &gt;</a>, <a class="el" href="classtatami_1_1DelayedBinaryIsometricOp.html#a3def1d40315715b6c8ad179735d70d9f">tatami::DelayedBinaryIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedUnaryIsometricOp.html#aa0ec7f06e69532658bdca9e47c8e8b34">tatami::DelayedUnaryIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a53a04770fdc42a2a906f677b325d7998">tatami::DelayedBind&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#ab5b7952a43d2c1255032b2b671b3b040">tatami::DelayedCast&lt; ValueOut_, IndexOut_, ValueIn_, IndexIn_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#ae879d7274b0196f18f82ccba86a178ad">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a8cc56caec424be36706baaa824631e9c">tatami::CompressedSparseMatrix&lt; Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a8cc56caec424be36706baaa824631e9c">tatami::CompressedSparseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt;, std::vector&lt; Index_ &gt;, std::vector&lt; size_t &gt; &gt;</a>, <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#a9190434e706cbb52a9765ff827735f6f">tatami::FragmentedSparseMatrix&lt; Value_, Index_, ValueVectorStorage_, IndexVectorStorage_ &gt;</a>, <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#a9190434e706cbb52a9765ff827735f6f">tatami::FragmentedSparseMatrix&lt; Value_, Index_, std::vector&lt; std::vector&lt; Value_ &gt; &gt;, std::vector&lt; std::vector&lt; Index_ &gt; &gt; &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#abc68a783b742b9c02fb5d411a4d0109f">tatami::DelayedSubset&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a4df587f4add88fd84abd461495b78f06">tatami::DelayedSubsetBlock&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#af55b74218794d8247fa85259a01851f4">tatami::DelayedSubsetSorted&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a065cd17412f11b8c9c7323fea513ffb1">tatami::DelayedSubsetSortedUnique&lt; Value_, Index_, IndexStorage_ &gt;</a>, and <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a58798108d22d24b2c86f9da156749256">tatami::DelayedSubsetUnique&lt; Value_, Index_, IndexStorage_ &gt;</a>.</p>

</div>
</div>
<a id="a69382d2a4e66cda1a9eb48dc25ab113a" name="a69382d2a4e66cda1a9eb48dc25ab113a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69382d2a4e66cda1a9eb48dc25ab113a">&#9670;&#160;</a></span>prefer_rows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">virtual</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::prefer_rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The preferred dimension for extracting values. If <code>true</code>, row-wise extraction is preferred; if <code>false</code>, column-wise extraction is preferred. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1DenseMatrix.html#a47eade967a5c180ff4a8c8644e57947b">tatami::DenseMatrix&lt; Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a47eade967a5c180ff4a8c8644e57947b">tatami::DenseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt; &gt;</a>, <a class="el" href="classtatami_1_1DelayedBinaryIsometricOp.html#a98ef4a94d64a2055688b9c736823a7d0">tatami::DelayedBinaryIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedUnaryIsometricOp.html#af5b5d90d807777c8ee966416b2fe44b8">tatami::DelayedUnaryIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#adeedfaa0423b0e7c6f12c3d524e0319d">tatami::DelayedBind&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#acd15dc4d42f79dcf6e8f100f59b17a9b">tatami::DelayedCast&lt; ValueOut_, IndexOut_, ValueIn_, IndexIn_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a8d386b8a0d05d6bcdbc1dd80c7d8118e">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a45a108841635187e7428cbc6f1969a28">tatami::CompressedSparseMatrix&lt; Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a45a108841635187e7428cbc6f1969a28">tatami::CompressedSparseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt;, std::vector&lt; Index_ &gt;, std::vector&lt; size_t &gt; &gt;</a>, <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#ab8415def9c366ffa6ec1713210b518b6">tatami::FragmentedSparseMatrix&lt; Value_, Index_, ValueVectorStorage_, IndexVectorStorage_ &gt;</a>, <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#ab8415def9c366ffa6ec1713210b518b6">tatami::FragmentedSparseMatrix&lt; Value_, Index_, std::vector&lt; std::vector&lt; Value_ &gt; &gt;, std::vector&lt; std::vector&lt; Index_ &gt; &gt; &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a199c086a09a7bf2cac401e5f881cc9de">tatami::DelayedSubset&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#aeb7911f1048e29196a24fa0da8093b1a">tatami::DelayedSubsetBlock&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#af3f83f7e5c38e66e2dc8de780743adff">tatami::DelayedSubsetSorted&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#afa8367d6e5074796799a72d5bca665cb">tatami::DelayedSubsetSortedUnique&lt; Value_, Index_, IndexStorage_ &gt;</a>, and <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#afb98aaad90e62e62bfc50d1888b01298">tatami::DelayedSubsetUnique&lt; Value_, Index_, IndexStorage_ &gt;</a>.</p>

</div>
</div>
<a id="a2ddcc730155ca894df1c58b0a963d5e7" name="a2ddcc730155ca894df1c58b0a963d5e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ddcc730155ca894df1c58b0a963d5e7">&#9670;&#160;</a></span>prefer_rows_proportion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">virtual</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">double</a> <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::prefer_rows_proportion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Approximate proportion of the matrix that prefers row-level access.</dd></dl>
<p>This is defined as the proportion of matrix elements that lie within submatrices that prefer row-level access. It is useful for determining the return value of <code><a class="el" href="classtatami_1_1Matrix.html#a69382d2a4e66cda1a9eb48dc25ab113a">prefer_rows()</a></code> in combined matrices consisting of both row- and column-preferred submatrices. In such cases, the net preference can be determined based on the combined size of the submatrices for each preference. (A more granular approach would be to report the iteration cost on each dimension, but this is difficult to estimate.) </p>

<p>Implemented in <a class="el" href="classtatami_1_1DenseMatrix.html#a44486a7d66661eada08c22a64547e937">tatami::DenseMatrix&lt; Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a44486a7d66661eada08c22a64547e937">tatami::DenseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt; &gt;</a>, <a class="el" href="classtatami_1_1DelayedBinaryIsometricOp.html#a5963ab48765408c1ac25dd56d038ba41">tatami::DelayedBinaryIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedUnaryIsometricOp.html#a228ccbff3b0bd609ada680f2ed419224">tatami::DelayedUnaryIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#af6fe54f29461d429362f0b8fec0da84e">tatami::DelayedBind&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#a5bbd6fe49cfca5995289950abcf18856">tatami::DelayedCast&lt; ValueOut_, IndexOut_, ValueIn_, IndexIn_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#af218bfcac74f403cc9d5bd6be84cc7a5">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a51bc0d7358afec17953fca1d37eab439">tatami::CompressedSparseMatrix&lt; Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a51bc0d7358afec17953fca1d37eab439">tatami::CompressedSparseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt;, std::vector&lt; Index_ &gt;, std::vector&lt; size_t &gt; &gt;</a>, <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#a5bc5cb7ee33045f37312445007f487f0">tatami::FragmentedSparseMatrix&lt; Value_, Index_, ValueVectorStorage_, IndexVectorStorage_ &gt;</a>, <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#a5bc5cb7ee33045f37312445007f487f0">tatami::FragmentedSparseMatrix&lt; Value_, Index_, std::vector&lt; std::vector&lt; Value_ &gt; &gt;, std::vector&lt; std::vector&lt; Index_ &gt; &gt; &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a56e60cdb956ba41eaeabfb79eed5faee">tatami::DelayedSubset&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a33461de6d39962ab1dd23dfd3d574d72">tatami::DelayedSubsetBlock&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a44da3045e809379eda8af80981c1d284">tatami::DelayedSubsetSorted&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a31e1454717272c017b49d8367d16ca75">tatami::DelayedSubsetSortedUnique&lt; Value_, Index_, IndexStorage_ &gt;</a>, and <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a6ec54d13c3da7bc80859855fc25c95b7">tatami::DelayedSubsetUnique&lt; Value_, Index_, IndexStorage_ &gt;</a>.</p>

</div>
</div>
<a id="a68da21245203cf9349648c5452cdb2ca" name="a68da21245203cf9349648c5452cdb2ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68da21245203cf9349648c5452cdb2ca">&#9670;&#160;</a></span>uses_oracle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">virtual</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::uses_oracle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Row access if <code>true</code>, column access otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether this matrix's <code><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">tatami::Extractor</a></code> classes make use of oracle predictions for row (if <code>row = true</code>) or column access (otherwise).</dd></dl>
<p>The output of this method indicates whether callers should construct an oracle for use in <code>ExtractorBase::set_oracle()</code>. If <code>false</code>, callers should not bother to pass an oracle as it will be ignored. </p>

<p>Implemented in <a class="el" href="classtatami_1_1DelayedBinaryIsometricOp.html#a7b09379690fd41d786df93427ffc816d">tatami::DelayedBinaryIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedUnaryIsometricOp.html#a9cbdbefdafe60b00f400fac148339566">tatami::DelayedUnaryIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#afb08188ae6e0e681f948ce39c74807ee">tatami::DelayedBind&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#aa6cbd8349c561942b5989590354c35ad">tatami::DelayedCast&lt; ValueOut_, IndexOut_, ValueIn_, IndexIn_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a6e814addfd1b93d7999a5383d0e69104">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#aa3ca05a0e63cddc02dbf0c5e61040c94">tatami::DelayedSubset&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#ac30ebebd3c8293ca6c4bc86c05a47a71">tatami::DelayedSubsetBlock&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a88097141121ba1c8bc4fbb48d024fcf5">tatami::DelayedSubsetSorted&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a25b30de526e585a4819b9359ec6507eb">tatami::DelayedSubsetSortedUnique&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a50e1037cb7d9dd1f49ebe72175ea28a0">tatami::DelayedSubsetUnique&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a829360901235a4f1a0c954c7bba15a36">tatami::DenseMatrix&lt; Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a829360901235a4f1a0c954c7bba15a36">tatami::DenseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt; &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a7fc491a14be516c9321f90c71c877cb7">tatami::CompressedSparseMatrix&lt; Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a7fc491a14be516c9321f90c71c877cb7">tatami::CompressedSparseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt;, std::vector&lt; Index_ &gt;, std::vector&lt; size_t &gt; &gt;</a>, <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#a880db70dfb5c2827045fb6ef3c34e680">tatami::FragmentedSparseMatrix&lt; Value_, Index_, ValueVectorStorage_, IndexVectorStorage_ &gt;</a>, and <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#a880db70dfb5c2827045fb6ef3c34e680">tatami::FragmentedSparseMatrix&lt; Value_, Index_, std::vector&lt; std::vector&lt; Value_ &gt; &gt;, std::vector&lt; std::vector&lt; Index_ &gt; &gt; &gt;</a>.</p>

</div>
</div>
<a id="a0b6b1ae7819fad55cf7bf5587b7e5a4b" name="a0b6b1ae7819fad55cf7bf5587b7e5a4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b6b1ae7819fad55cf7bf5587b7e5a4b">&#9670;&#160;</a></span>dense() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">virtual</a> std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::dense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an extractor that retrieves the full extent of the non-target dimension in dense form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Whether to create a row-wise extractor, i.e., the rows are the target dimension. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting each row (if <code>row = true</code>) or column (otherwise) in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1DenseMatrix.html#a00cf78c7ac6f8632fa8c6dfc4c348b6c">tatami::DenseMatrix&lt; Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a00cf78c7ac6f8632fa8c6dfc4c348b6c">tatami::DenseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt; &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#afee13e537eed87d5608c841b124544fa">tatami::CompressedSparseMatrix&lt; Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#afee13e537eed87d5608c841b124544fa">tatami::CompressedSparseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt;, std::vector&lt; Index_ &gt;, std::vector&lt; size_t &gt; &gt;</a>, <a class="el" href="classtatami_1_1DelayedBinaryIsometricOp.html#a0eabf41275ca51996147207a77209969">tatami::DelayedBinaryIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedUnaryIsometricOp.html#a6db129773e655cc9149d77fe917fb3d2">tatami::DelayedUnaryIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a2501986079d0301b8a8ceec0a9353549">tatami::DelayedBind&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#ac4b9a0bafe2014027e9068a3a076ef01">tatami::DelayedCast&lt; ValueOut_, IndexOut_, ValueIn_, IndexIn_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a46086fee8ed3a7c1bc3bd52a22a63c45">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a609088739b6ea5d2ee34e1e44ed69a71">tatami::DelayedSubset&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a3b18c892e717c1a1167a5b2028e1110f">tatami::DelayedSubsetBlock&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a1125206f4db72a068c1aed9e48fbdf98">tatami::DelayedSubsetSorted&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a62078d76745cbc171f3385f421df1273">tatami::DelayedSubsetSortedUnique&lt; Value_, Index_, IndexStorage_ &gt;</a>, and <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a84317ee8e94f5cba6e586f20dcb28c65">tatami::DelayedSubsetUnique&lt; Value_, Index_, IndexStorage_ &gt;</a>.</p>

</div>
</div>
<a id="a51bb7a480d2fd0cc0337577ca98840dc" name="a51bb7a480d2fd0cc0337577ca98840dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51bb7a480d2fd0cc0337577ca98840dc">&#9670;&#160;</a></span>dense() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">virtual</a> std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::dense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>block_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>block_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an extractor that retrieves a contiguous block of the non-target dimension in dense form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Whether to create a row-wise extractor, i.e., the rows are the target dimension. </td></tr>
    <tr><td class="paramname">block_start</td><td>Index of the column (if <code>row = true</code>) or row (otherwise) at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of columns (if <code>row = true</code>) or rows (otherwise) in the block. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting a contiguous block from each row (if <code>row = true</code>) or column (otherwise) in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a8f4f83eb19ba3d9d69ec31552935923e">tatami::CompressedSparseMatrix&lt; Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a8f4f83eb19ba3d9d69ec31552935923e">tatami::CompressedSparseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt;, std::vector&lt; Index_ &gt;, std::vector&lt; size_t &gt; &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#ab756a390f2edb4ac4e33b4dace0ddee4">tatami::DenseMatrix&lt; Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#ab756a390f2edb4ac4e33b4dace0ddee4">tatami::DenseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt; &gt;</a>, <a class="el" href="classtatami_1_1DelayedBinaryIsometricOp.html#a934ed81b355856d2fde461fa2ad247cd">tatami::DelayedBinaryIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedUnaryIsometricOp.html#a1eb9956e6f905dd4bf004f2657542215">tatami::DelayedUnaryIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#ae83495a67dea2dc2d9a9c58112f09fa0">tatami::DelayedBind&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a3b44b07b7bbfcd6e0d1f9129c1e04fe5">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#ad2825d1b864c1e1d2b6af641f750f2f9">tatami::DelayedSubset&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a2d186a597674c603ce5b899a6ebcc8e3">tatami::DelayedSubsetBlock&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#aaab8c221bf08536e79505919a0aa777f">tatami::DelayedSubsetSorted&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a6ff862a22099799d2a3eb87fdf593515">tatami::DelayedSubsetSortedUnique&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a289a9d3a53778f003aba572a93a3a34c">tatami::DelayedSubsetUnique&lt; Value_, Index_, IndexStorage_ &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#a0af1b7a669b244fd0af79ecdbb51e234">tatami::DelayedCast&lt; ValueOut_, IndexOut_, ValueIn_, IndexIn_ &gt;</a>.</p>

</div>
</div>
<a id="a06803687627cc35e5ef41a887f5e5fad" name="a06803687627cc35e5ef41a887f5e5fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06803687627cc35e5ef41a887f5e5fad">&#9670;&#160;</a></span>dense() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">virtual</a> std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::dense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#abbb0bdf0b79fe19e504b49b43984f634">VectorPtr</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;&#160;</td>
          <td class="paramname"><em>indices_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an extractor that retrieves an indexed subset of the non-target dimension in dense form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Whether to create a row-wise extractor, i.e., the rows are the target dimension. </td></tr>
    <tr><td class="paramname">indices_ptr</td><td>Pointer to a vector of sorted and unique column indices (if <code>row = true</code>) or row indices (otherwise). This should be non-NULL. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each row (if <code>row = true</code>) or column (otherwise) in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1DenseMatrix.html#a26bd48cae35fb51e760b097ae6446aa1">tatami::DenseMatrix&lt; Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a26bd48cae35fb51e760b097ae6446aa1">tatami::DenseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt; &gt;</a>, <a class="el" href="classtatami_1_1DelayedBinaryIsometricOp.html#ae4b196346e32016937eaf314024a3cc7">tatami::DelayedBinaryIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedUnaryIsometricOp.html#a144aab0d3ee6101b16f0d8bfddb9e782">tatami::DelayedUnaryIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a53fff70bf26c7308145a03b06d006e89">tatami::DelayedBind&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a215e5aec143bf866b34e1ac91a40c16c">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#aad15970b7f0f88abcf4ed312f1e44a8e">tatami::DelayedSubset&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a842a5dece24524235cc408212ff356af">tatami::DelayedSubsetBlock&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a6e5269575b9a5e18109031148b058571">tatami::DelayedSubsetSorted&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#af30b9dc2c8dc6ea6ad3355f2e8f62ef5">tatami::DelayedSubsetSortedUnique&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#ac23fab1a8317410ba8d1aac18d9a118f">tatami::DelayedSubsetUnique&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a09d04e0c9ffcb6ab5b3b8bfd4f18df96">tatami::CompressedSparseMatrix&lt; Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a09d04e0c9ffcb6ab5b3b8bfd4f18df96">tatami::CompressedSparseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt;, std::vector&lt; Index_ &gt;, std::vector&lt; size_t &gt; &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#a596b4b85d2931230f0591703dc6872db">tatami::DelayedCast&lt; ValueOut_, IndexOut_, ValueIn_, IndexIn_ &gt;</a>.</p>

</div>
</div>
<a id="a168f0e932b5503c9bfc5dbd42754a7a5" name="a168f0e932b5503c9bfc5dbd42754a7a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a168f0e932b5503c9bfc5dbd42754a7a5">&#9670;&#160;</a></span>dense_row() <span class="overload">[1/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::dense_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a row-wise extractor that retrieves all columns in dense form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting each row in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a3d6505ab08f36ab2e2487f7598a8df4e" name="a3d6505ab08f36ab2e2487f7598a8df4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d6505ab08f36ab2e2487f7598a8df4e">&#9670;&#160;</a></span>dense_row() <span class="overload">[2/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::dense_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>block_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>block_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a row-wise extractor that retrieves a contiguous block of columns in dense form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_start</td><td>Index of the column at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of columns in the block. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting a contiguous block from each row in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a4b6f4909657d2e44196a56c99ffafb5c" name="a4b6f4909657d2e44196a56c99ffafb5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b6f4909657d2e44196a56c99ffafb5c">&#9670;&#160;</a></span>dense_row() <span class="overload">[3/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::dense_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#abbb0bdf0b79fe19e504b49b43984f634">VectorPtr</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;&#160;</td>
          <td class="paramname"><em>indices_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a row-wise extractor that retrieves an indexed subset of columns in dense form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices_ptr</td><td>Pointer to a vector of sorted and unique column indices. This should not be NULL. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each row in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a563d877fa76c04d1faa039ebab88038c" name="a563d877fa76c04d1faa039ebab88038c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a563d877fa76c04d1faa039ebab88038c">&#9670;&#160;</a></span>dense_row() <span class="overload">[4/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::dense_row </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a row-wise extractor that retrieves an indexed subset of columns in dense form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Vector of sorted and unique column indices. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each row. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a48300b3739f26bb10732c572ea9e5c57" name="a48300b3739f26bb10732c572ea9e5c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48300b3739f26bb10732c572ea9e5c57">&#9670;&#160;</a></span>dense_column() <span class="overload">[1/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::dense_column </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a column-wise extractor that retrieves all rows in dense form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting each column in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a9daf387535987b84f7b44c68fb664d33" name="a9daf387535987b84f7b44c68fb664d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9daf387535987b84f7b44c68fb664d33">&#9670;&#160;</a></span>dense_column() <span class="overload">[2/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::dense_column </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>block_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>block_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a column-wise extractor that retrieves a contiguous block of rows in dense form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_start</td><td>Index of the row at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of rows in the block. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting a contiguous block from each column in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a8ce124d5abc915f47e0abdec500b84f3" name="a8ce124d5abc915f47e0abdec500b84f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ce124d5abc915f47e0abdec500b84f3">&#9670;&#160;</a></span>dense_column() <span class="overload">[3/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::dense_column </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#abbb0bdf0b79fe19e504b49b43984f634">VectorPtr</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;&#160;</td>
          <td class="paramname"><em>indices_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a column-wise extractor that retrieves an indexed subset of rows in dense form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices_ptr</td><td>Pointer to a vector of sorted and unique row indices. This should not be NULL. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each column in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="ace58cae1956cbf7474aa7120e0d89cc9" name="ace58cae1956cbf7474aa7120e0d89cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace58cae1956cbf7474aa7120e0d89cc9">&#9670;&#160;</a></span>dense_column() <span class="overload">[4/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::dense_column </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a column-wise extractor that retrieves an indexed subset of rows in dense form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Vector of sorted and unique row indices. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each column in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a4d572f319b614a7e74d426cac94194de" name="a4d572f319b614a7e74d426cac94194de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d572f319b614a7e74d426cac94194de">&#9670;&#160;</a></span>dense_row() <span class="overload">[5/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::dense_row </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="classtatami_1_1Matrix.html#a4d572f319b614a7e74d426cac94194de">dense_row()</a></code> that uses the default options. </p><dl class="section return"><dt>Returns</dt><dd>Object for extracting each row in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="aacb45e8a21e1792a316fa95064edb9c2" name="aacb45e8a21e1792a316fa95064edb9c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacb45e8a21e1792a316fa95064edb9c2">&#9670;&#160;</a></span>dense_row() <span class="overload">[6/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::dense_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>block_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>block_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="classtatami_1_1Matrix.html#a4d572f319b614a7e74d426cac94194de">dense_row()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_start</td><td>Index of the column at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of columns in the block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting a contiguous block from each row in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a371fa940bc33a019b1f6938c2b06201f" name="a371fa940bc33a019b1f6938c2b06201f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a371fa940bc33a019b1f6938c2b06201f">&#9670;&#160;</a></span>dense_row() <span class="overload">[7/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::dense_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#abbb0bdf0b79fe19e504b49b43984f634">VectorPtr</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;&#160;</td>
          <td class="paramname"><em>indices_ptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="classtatami_1_1Matrix.html#a4d572f319b614a7e74d426cac94194de">dense_row()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices_ptr</td><td>Pointer to a vector of sorted and unique column indices. This should be non-NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each row in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a3f3692e08db0886e4e866e28942d46b0" name="a3f3692e08db0886e4e866e28942d46b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f3692e08db0886e4e866e28942d46b0">&#9670;&#160;</a></span>dense_row() <span class="overload">[8/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::dense_row </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="classtatami_1_1Matrix.html#a4d572f319b614a7e74d426cac94194de">dense_row()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Vector of sorted and unique column indices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each row in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="aa2dad77430f29f277f73028c7c2636e2" name="aa2dad77430f29f277f73028c7c2636e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2dad77430f29f277f73028c7c2636e2">&#9670;&#160;</a></span>dense_column() <span class="overload">[5/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::dense_column </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="classtatami_1_1Matrix.html#aa2dad77430f29f277f73028c7c2636e2">dense_column()</a></code> that uses the default options. </p><dl class="section return"><dt>Returns</dt><dd>Object for extracting each column in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a478f96c3a39b40a950dda3d115365c89" name="a478f96c3a39b40a950dda3d115365c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a478f96c3a39b40a950dda3d115365c89">&#9670;&#160;</a></span>dense_column() <span class="overload">[6/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::dense_column </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>block_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>block_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="classtatami_1_1Matrix.html#aa2dad77430f29f277f73028c7c2636e2">dense_column()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_start</td><td>Index of the row at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of rows in the block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting a contiguous block from each column in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a9058c33bd860936d0a6fe4f03397f6b9" name="a9058c33bd860936d0a6fe4f03397f6b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9058c33bd860936d0a6fe4f03397f6b9">&#9670;&#160;</a></span>dense_column() <span class="overload">[7/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::dense_column </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#abbb0bdf0b79fe19e504b49b43984f634">VectorPtr</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;&#160;</td>
          <td class="paramname"><em>indices_ptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="classtatami_1_1Matrix.html#aa2dad77430f29f277f73028c7c2636e2">dense_column()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices_ptr</td><td>Pointer to a vector of sorted and unique row indices. This should be non-NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Obejct for extracting an indexed subset from each column in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a7b82bffd2c71c4301867e8a0ffcf37f3" name="a7b82bffd2c71c4301867e8a0ffcf37f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b82bffd2c71c4301867e8a0ffcf37f3">&#9670;&#160;</a></span>dense_column() <span class="overload">[8/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::dense_column </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="classtatami_1_1Matrix.html#aa2dad77430f29f277f73028c7c2636e2">dense_column()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Vector of sorted and unique row indices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Obejct for extracting an indexed subset from each column in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="af84772cc4e911a87948d45a1edcabbd0" name="af84772cc4e911a87948d45a1edcabbd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af84772cc4e911a87948d45a1edcabbd0">&#9670;&#160;</a></span>sparse() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">virtual</a> std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::sparse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an extractor that retrieves the full extent of the non-target dimension in sparse form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Whether to create a row-wise extractor, i.e., the rows are the target dimension. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting each row (if <code>row = true</code>) or columns (otherwise) in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1DenseMatrix.html#a14731efb8e8dd41e23211510ba64fab5">tatami::DenseMatrix&lt; Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a14731efb8e8dd41e23211510ba64fab5">tatami::DenseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt; &gt;</a>, <a class="el" href="classtatami_1_1DelayedBinaryIsometricOp.html#a1c0760c17a483e8ee9d1609905c7942f">tatami::DelayedBinaryIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedUnaryIsometricOp.html#a21b851d7e50075b8d29cbf572c24c003">tatami::DelayedUnaryIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#a1dea29fac0c463402c7ec8793cb351a6">tatami::DelayedCast&lt; ValueOut_, IndexOut_, ValueIn_, IndexIn_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a75b9d1b19e9d97da9e6303c4c76d9238">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a1a380cb8f55f8c5ae9334b1bfaaa6876">tatami::CompressedSparseMatrix&lt; Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a1a380cb8f55f8c5ae9334b1bfaaa6876">tatami::CompressedSparseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt;, std::vector&lt; Index_ &gt;, std::vector&lt; size_t &gt; &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a3aa160a2135a253c77d41fe34ef84b64">tatami::DelayedSubset&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a97908a89a4b76a92c25b8b041794e643">tatami::DelayedSubsetBlock&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a07e5f4e07aa4c7be22564a2350c1f178">tatami::DelayedSubsetSorted&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a72a56b7b6b2d779182d714d4ed4b69c6">tatami::DelayedSubsetSortedUnique&lt; Value_, Index_, IndexStorage_ &gt;</a>, and <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#ab82888461a18e44f9477c4e44b31af82">tatami::DelayedSubsetUnique&lt; Value_, Index_, IndexStorage_ &gt;</a>.</p>

</div>
</div>
<a id="af802c74c510eff3316ce0eea99c08810" name="af802c74c510eff3316ce0eea99c08810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af802c74c510eff3316ce0eea99c08810">&#9670;&#160;</a></span>sparse() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">virtual</a> std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::sparse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>block_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>block_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an extractor that retrieves a contiguous block of the non-target dimension in sparse form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Whether to create a row-wise extractor, i.e., the rows are the target dimension. </td></tr>
    <tr><td class="paramname">block_start</td><td>Index of the column (if <code>row = true</code>) or row (otherwise) at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of columns (if <code>row = true</code>) or rows (otherwise) in the block. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting a contiguous block from each row (if <code>row = true</code>) or column (otherwise) in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a76725ab1293975137e2ed2ec3c188464">tatami::CompressedSparseMatrix&lt; Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a76725ab1293975137e2ed2ec3c188464">tatami::CompressedSparseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt;, std::vector&lt; Index_ &gt;, std::vector&lt; size_t &gt; &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#ac06116b91a9b811f3253f31f11f7bfcb">tatami::DenseMatrix&lt; Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#ac06116b91a9b811f3253f31f11f7bfcb">tatami::DenseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt; &gt;</a>, <a class="el" href="classtatami_1_1DelayedBinaryIsometricOp.html#a0237cad93a7fd28c55fad70ae659c83e">tatami::DelayedBinaryIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedUnaryIsometricOp.html#a027da1b8333def8b4f66cc1a2320ad62">tatami::DelayedUnaryIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a1f42007d5ca11c0f2588a57330a7c556">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#aaf70ac46b720f9fd8c2be78a72a9e4fa">tatami::DelayedSubset&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#ad5ac39b6671feb1389e0b3fdabe25e4c">tatami::DelayedSubsetBlock&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#ad000a08b082d835260bdb3cbf22f44dd">tatami::DelayedSubsetSorted&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#acdaf88349be2858d81bad0e74140c94b">tatami::DelayedSubsetSortedUnique&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a7c676f767c48e1bea2f1edcb686524ee">tatami::DelayedSubsetUnique&lt; Value_, Index_, IndexStorage_ &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#a8464e48c09743cab8ae45fd8f7de190e">tatami::DelayedCast&lt; ValueOut_, IndexOut_, ValueIn_, IndexIn_ &gt;</a>.</p>

</div>
</div>
<a id="a59d055aed809a2036c10c1fce92bd036" name="a59d055aed809a2036c10c1fce92bd036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d055aed809a2036c10c1fce92bd036">&#9670;&#160;</a></span>sparse() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">virtual</a> std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::sparse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#abbb0bdf0b79fe19e504b49b43984f634">VectorPtr</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;&#160;</td>
          <td class="paramname"><em>indices_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an extractor that retrieves an indexed subset of the non-target dimension in sparse form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Whether to create a row-wise extractor, i.e., the rows are the target dimension. </td></tr>
    <tr><td class="paramname">indices_ptr</td><td>Pointer to a vector of sorted and unique column indices (if <code>row = true</code>) or row indices (otherwise). This should be non-NULL. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each row (if <code>row = true</code>) or column (otherwise) in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a02bd5381ee7ef01f44c22b207f350209">tatami::DelayedSubsetBlock&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a7a757cea83161373e48b0d2a506931e3">tatami::DenseMatrix&lt; Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a7a757cea83161373e48b0d2a506931e3">tatami::DenseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt; &gt;</a>, <a class="el" href="classtatami_1_1DelayedBinaryIsometricOp.html#a988488d3aa69b846a05bc1fcf7c2120d">tatami::DelayedBinaryIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedUnaryIsometricOp.html#aadaeb7b15958c3cd66616a89b098d2e1">tatami::DelayedUnaryIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a63f8ce1ffedcc671a36ead8fed6bf205">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a1ac7c97578e91c0727477d7fb6396d9d">tatami::DelayedSubset&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a483af25e42c6b48ce752516b63ff561e">tatami::DelayedSubsetSorted&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a866618bc1e79d6035157904d31954a70">tatami::DelayedSubsetSortedUnique&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#ad38a60ca8b73d02b0e82aa21dff6a0b7">tatami::DelayedSubsetUnique&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a6e8a09a45058548d7d55958e0a4d243e">tatami::CompressedSparseMatrix&lt; Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a6e8a09a45058548d7d55958e0a4d243e">tatami::CompressedSparseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt;, std::vector&lt; Index_ &gt;, std::vector&lt; size_t &gt; &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#aee3192a2bab277ca0e6420d86bd49bbd">tatami::DelayedCast&lt; ValueOut_, IndexOut_, ValueIn_, IndexIn_ &gt;</a>.</p>

</div>
</div>
<a id="afcb3651992dff44cdf8d560a527707f6" name="afcb3651992dff44cdf8d560a527707f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcb3651992dff44cdf8d560a527707f6">&#9670;&#160;</a></span>sparse_row() <span class="overload">[1/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::sparse_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a row-wise extractor that retrieves all columns in sparse form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting each row in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="ada39dd5987e82eb0aa50c302ee3ed564" name="ada39dd5987e82eb0aa50c302ee3ed564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada39dd5987e82eb0aa50c302ee3ed564">&#9670;&#160;</a></span>sparse_row() <span class="overload">[2/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::sparse_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>block_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>block_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a row-wise extractor that retrieves a contiguous block of columns in sparse form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_start</td><td>Index of the column at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of columns in the block. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting a contiguous block from each row in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="ac64a711a19ebc55da7b5fdc193db839c" name="ac64a711a19ebc55da7b5fdc193db839c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac64a711a19ebc55da7b5fdc193db839c">&#9670;&#160;</a></span>sparse_row() <span class="overload">[3/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::sparse_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#abbb0bdf0b79fe19e504b49b43984f634">VectorPtr</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;&#160;</td>
          <td class="paramname"><em>indices_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a row-wise extractor that retrieves an indexed subset of columns in sparse form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices_ptr</td><td>Pointer to a vector of sorted and unique column indices. This should not be NULL. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each row in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="afb26d2551fec7753001e8c274c9661de" name="afb26d2551fec7753001e8c274c9661de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb26d2551fec7753001e8c274c9661de">&#9670;&#160;</a></span>sparse_row() <span class="overload">[4/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::sparse_row </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a row-wise extractor that retrieves an indexed subset of columns in sparse form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Vector of sorted and unique column indices. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each row in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="aed47eef4ab4a6563db02acc77e22e5eb" name="aed47eef4ab4a6563db02acc77e22e5eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed47eef4ab4a6563db02acc77e22e5eb">&#9670;&#160;</a></span>sparse_column() <span class="overload">[1/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::sparse_column </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a column-wise extractor that retrieves all rows in sparse form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting each column in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="ad45028c0259b57630cdc23e4f3d08835" name="ad45028c0259b57630cdc23e4f3d08835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad45028c0259b57630cdc23e4f3d08835">&#9670;&#160;</a></span>sparse_column() <span class="overload">[2/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::sparse_column </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>block_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>block_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a column-wise extractor that retrieves a contiguous block of rows in sparse form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_start</td><td>Index of the row at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of rows in the block. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting a contiguous block from each column in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a9f340c985ed28a230745d87c9cd6ac44" name="a9f340c985ed28a230745d87c9cd6ac44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f340c985ed28a230745d87c9cd6ac44">&#9670;&#160;</a></span>sparse_column() <span class="overload">[3/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::sparse_column </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#abbb0bdf0b79fe19e504b49b43984f634">VectorPtr</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;&#160;</td>
          <td class="paramname"><em>indices_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a column-wise extractor that retrieves an indexed subset of rows in sparse form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices_ptr</td><td>Pointer to a vector of sorted and unique row indices. This should not be NULL. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each column in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a518b8f184afb562e8ef722c2feef0875" name="a518b8f184afb562e8ef722c2feef0875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a518b8f184afb562e8ef722c2feef0875">&#9670;&#160;</a></span>sparse_column() <span class="overload">[4/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::sparse_column </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a column-wise extractor that retrieves an indexed subset of rows in sparse form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Vector of sorted and unique row indices. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each column in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="aedecd4c23762ff43f49cfb0d2c687056" name="aedecd4c23762ff43f49cfb0d2c687056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedecd4c23762ff43f49cfb0d2c687056">&#9670;&#160;</a></span>sparse_row() <span class="overload">[5/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::sparse_row </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="classtatami_1_1Matrix.html#aedecd4c23762ff43f49cfb0d2c687056">sparse_row()</a></code> that uses the default options. </p><dl class="section return"><dt>Returns</dt><dd>Object for extracting each row in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="ad2aecb2560e570ec8f6e3efb0eddf55d" name="ad2aecb2560e570ec8f6e3efb0eddf55d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2aecb2560e570ec8f6e3efb0eddf55d">&#9670;&#160;</a></span>sparse_row() <span class="overload">[6/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::sparse_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>block_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>block_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="classtatami_1_1Matrix.html#aedecd4c23762ff43f49cfb0d2c687056">sparse_row()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_start</td><td>Index of the column at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of columns in the block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting a contiguous block from each row in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="acbe0fed52aae518a420114727e1c98a1" name="acbe0fed52aae518a420114727e1c98a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe0fed52aae518a420114727e1c98a1">&#9670;&#160;</a></span>sparse_row() <span class="overload">[7/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::sparse_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#abbb0bdf0b79fe19e504b49b43984f634">VectorPtr</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;&#160;</td>
          <td class="paramname"><em>indices_ptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="classtatami_1_1Matrix.html#aedecd4c23762ff43f49cfb0d2c687056">sparse_row()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices_ptr</td><td>Pointer to a vector of sorted and unique column indices. This should not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each row in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a3011f5e2ee8103fcc4c6488bfd228997" name="a3011f5e2ee8103fcc4c6488bfd228997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3011f5e2ee8103fcc4c6488bfd228997">&#9670;&#160;</a></span>sparse_row() <span class="overload">[8/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::sparse_row </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="classtatami_1_1Matrix.html#aedecd4c23762ff43f49cfb0d2c687056">sparse_row()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Vector of sorted and unique column indices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each row in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="ab0efad968be5f4b9a36bb50beb8460f8" name="ab0efad968be5f4b9a36bb50beb8460f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0efad968be5f4b9a36bb50beb8460f8">&#9670;&#160;</a></span>sparse_column() <span class="overload">[5/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::sparse_column </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="classtatami_1_1Matrix.html#ab0efad968be5f4b9a36bb50beb8460f8">sparse_column()</a></code> that uses the default options. </p><dl class="section return"><dt>Returns</dt><dd>Object for extracting each column in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a51f592922949fc50786de3eb6f58d0be" name="a51f592922949fc50786de3eb6f58d0be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51f592922949fc50786de3eb6f58d0be">&#9670;&#160;</a></span>sparse_column() <span class="overload">[6/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::sparse_column </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>block_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>block_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="classtatami_1_1Matrix.html#ab0efad968be5f4b9a36bb50beb8460f8">sparse_column()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_start</td><td>Index of the row at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of rows in the block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting a contiguous block from each column in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="adfb6b4e90e3ab5cf0112e7cbd31f18f4" name="adfb6b4e90e3ab5cf0112e7cbd31f18f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb6b4e90e3ab5cf0112e7cbd31f18f4">&#9670;&#160;</a></span>sparse_column() <span class="overload">[7/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::sparse_column </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#abbb0bdf0b79fe19e504b49b43984f634">VectorPtr</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;&#160;</td>
          <td class="paramname"><em>indices_ptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="classtatami_1_1Matrix.html#ab0efad968be5f4b9a36bb50beb8460f8">sparse_column()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices_ptr</td><td>Pointer to a vector of sorted and unique row indices. This should not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each column in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="aebbd197a7d1530397cff04660e78f28f" name="aebbd197a7d1530397cff04660e78f28f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebbd197a7d1530397cff04660e78f28f">&#9670;&#160;</a></span>sparse_column() <span class="overload">[8/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::sparse_column </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="classtatami_1_1Matrix.html#ab0efad968be5f4b9a36bb50beb8460f8">sparse_column()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Vector of sorted and unique row indices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each column in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a6502fdebcaeea40490c1780ab6e92b19" name="a6502fdebcaeea40490c1780ab6e92b19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6502fdebcaeea40490c1780ab6e92b19">&#9670;&#160;</a></span>dense() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">virtual</a> std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::dense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>oracle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an oracle-aware extractor that retrieves the full extent of the non-target dimension in dense form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Whether to create a row-wise extractor, i.e., the rows are the target dimension. </td></tr>
    <tr><td class="paramname">oracle</td><td>An oracle supplying predictions of the next requested row (if <code>row = true</code>) or column (otherwise). </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting each row (if <code>row = true)</code> or columns (otherwise) in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1DenseMatrix.html#a14937508d3eaed557eb9100cc9398371">tatami::DenseMatrix&lt; Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a14937508d3eaed557eb9100cc9398371">tatami::DenseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt; &gt;</a>, <a class="el" href="classtatami_1_1DelayedBinaryIsometricOp.html#a569b08abd821a1b59a1f64afb9927784">tatami::DelayedBinaryIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedUnaryIsometricOp.html#aa5297b3fa389324b2ed7cf275cb60a3c">tatami::DelayedUnaryIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a5996a26ad8168a073447402e5b1cc980">tatami::DelayedBind&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#accbbe64970c4396d590833c1a7195adf">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a99ab5dda78086432c4f164c9d1a59825">tatami::CompressedSparseMatrix&lt; Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a99ab5dda78086432c4f164c9d1a59825">tatami::CompressedSparseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt;, std::vector&lt; Index_ &gt;, std::vector&lt; size_t &gt; &gt;</a>, <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#a0714419818f4550a8535969eb1fe8236">tatami::FragmentedSparseMatrix&lt; Value_, Index_, ValueVectorStorage_, IndexVectorStorage_ &gt;</a>, <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#a0714419818f4550a8535969eb1fe8236">tatami::FragmentedSparseMatrix&lt; Value_, Index_, std::vector&lt; std::vector&lt; Value_ &gt; &gt;, std::vector&lt; std::vector&lt; Index_ &gt; &gt; &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#acb580a4d37f81b47b17296f608bb8519">tatami::DelayedSubset&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a849e1982154ebcc308131ef526d4b322">tatami::DelayedSubsetBlock&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a155dbdfe9fd517a0c0e85c62f7e31d87">tatami::DelayedSubsetSorted&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a5c7886eac29454f2e516bc07f9b43e72">tatami::DelayedSubsetSortedUnique&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#aa3f56e036e7992b4987b5deeade19119">tatami::DelayedSubsetUnique&lt; Value_, Index_, IndexStorage_ &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#a40d489e15dd088b4fa1a4a36bddf1ca6">tatami::DelayedCast&lt; ValueOut_, IndexOut_, ValueIn_, IndexIn_ &gt;</a>.</p>

</div>
</div>
<a id="a48b24fe319289ca76f2b366a2ffe798d" name="a48b24fe319289ca76f2b366a2ffe798d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48b24fe319289ca76f2b366a2ffe798d">&#9670;&#160;</a></span>dense() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">virtual</a> std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::dense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>oracle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>block_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>block_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an oracle-aware extractor that retrieves a contiguous block of the non-target dimension in dense form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Whether to create a row-wise extractor, i.e., the rows are the target dimension. </td></tr>
    <tr><td class="paramname">oracle</td><td>An oracle supplying predictions of the next requested row (if <code>row = true</code>) or column (otherwise). </td></tr>
    <tr><td class="paramname">block_start</td><td>Index of the column (if <code>row = true</code>) or row (otherwise) at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of columns (if <code>row = true</code>) or rows (otherwise) in the block. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting a contiguous block from each row (if <code>row = true</code>) or column (otherwise) in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1DenseMatrix.html#ad6920bef1b2f39a507d3e5f8e922daa8">tatami::DenseMatrix&lt; Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#ad6920bef1b2f39a507d3e5f8e922daa8">tatami::DenseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt; &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#aba826b0ac6300d36ca226e0ab0b6dc22">tatami::CompressedSparseMatrix&lt; Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#aba826b0ac6300d36ca226e0ab0b6dc22">tatami::CompressedSparseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt;, std::vector&lt; Index_ &gt;, std::vector&lt; size_t &gt; &gt;</a>, <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#a363af30fbd351a27cc7231f074ef7874">tatami::FragmentedSparseMatrix&lt; Value_, Index_, ValueVectorStorage_, IndexVectorStorage_ &gt;</a>, <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#a363af30fbd351a27cc7231f074ef7874">tatami::FragmentedSparseMatrix&lt; Value_, Index_, std::vector&lt; std::vector&lt; Value_ &gt; &gt;, std::vector&lt; std::vector&lt; Index_ &gt; &gt; &gt;</a>, <a class="el" href="classtatami_1_1DelayedBinaryIsometricOp.html#ad6bd08128f7701397f1e08627955039f">tatami::DelayedBinaryIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedUnaryIsometricOp.html#a0a183ee56947ce28c7b597d1983057ad">tatami::DelayedUnaryIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#aa2069d84db3b6907e187b177c7befab4">tatami::DelayedBind&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a64e5ebbc0364936474af1667e2e6a66c">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a74d14f13a25a6e6b03f28f48e58c0e9a">tatami::DelayedSubset&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#aca14e61cf151b970681fa1a2124feff9">tatami::DelayedSubsetBlock&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a06687d4a1bdb8a4dfb0fb00530e8c7fa">tatami::DelayedSubsetSorted&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#aa900b241cf2395a56637f80953332427">tatami::DelayedSubsetSortedUnique&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a2a53c100279347b2b591712b10f3d001">tatami::DelayedSubsetUnique&lt; Value_, Index_, IndexStorage_ &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#a0506809d80eaa439f9c7c7a66ab530c3">tatami::DelayedCast&lt; ValueOut_, IndexOut_, ValueIn_, IndexIn_ &gt;</a>.</p>

</div>
</div>
<a id="a4aecaa5038554d2c92c2ab7083497cb6" name="a4aecaa5038554d2c92c2ab7083497cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aecaa5038554d2c92c2ab7083497cb6">&#9670;&#160;</a></span>dense() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">virtual</a> std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::dense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>oracle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#abbb0bdf0b79fe19e504b49b43984f634">VectorPtr</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;&#160;</td>
          <td class="paramname"><em>indices_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an oracle-aware extractor that retrieves an indexed subset of the non-target dimension in dense form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Whether to create a row-wise extractor, i.e., the rows are the target dimension. </td></tr>
    <tr><td class="paramname">oracle</td><td>An oracle supplying predictions of the next requested row (if <code>row = true</code>) or column (otherwise). </td></tr>
    <tr><td class="paramname">indices_ptr</td><td>Pointer to a vector of sorted and unique column indices (if <code>row = true</code>) or row indices (otherwise). This should not be NULL. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each row (if <code>row = true</code>) or column (otherwise) in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1DenseMatrix.html#a2bda92623f1a91d9e6da8473e91b2159">tatami::DenseMatrix&lt; Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a2bda92623f1a91d9e6da8473e91b2159">tatami::DenseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt; &gt;</a>, <a class="el" href="classtatami_1_1DelayedBinaryIsometricOp.html#ac175990a9bd9bf4848530ef67aa1a151">tatami::DelayedBinaryIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedUnaryIsometricOp.html#a7716e2579e44afb51c97389662772023">tatami::DelayedUnaryIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a1aae5576005dc08ed6d62fedde194884">tatami::DelayedBind&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#adad4b60fc18324d0195da3405581e47d">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#affbf0bae310fcdb9522aa2c5edd30afc">tatami::CompressedSparseMatrix&lt; Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#affbf0bae310fcdb9522aa2c5edd30afc">tatami::CompressedSparseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt;, std::vector&lt; Index_ &gt;, std::vector&lt; size_t &gt; &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#abad94e2051230c7d440f8e409f0ab7d9">tatami::DelayedSubset&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a2abd9c3da5613f4af78db1a77c249182">tatami::DelayedSubsetBlock&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a341cbbd5f93a37a7e2dc6420ef823a1b">tatami::DelayedSubsetSorted&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#ac576bf4bccf3186a14fa79334deccbea">tatami::DelayedSubsetSortedUnique&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a5513955ba651a48571e82d9b52dc19ad">tatami::DelayedSubsetUnique&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#aa0308a4a8e9494bed030c51eba41811a">tatami::FragmentedSparseMatrix&lt; Value_, Index_, ValueVectorStorage_, IndexVectorStorage_ &gt;</a>, <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#aa0308a4a8e9494bed030c51eba41811a">tatami::FragmentedSparseMatrix&lt; Value_, Index_, std::vector&lt; std::vector&lt; Value_ &gt; &gt;, std::vector&lt; std::vector&lt; Index_ &gt; &gt; &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#a02a6367903e9be1311c25a14e743ef10">tatami::DelayedCast&lt; ValueOut_, IndexOut_, ValueIn_, IndexIn_ &gt;</a>.</p>

</div>
</div>
<a id="aa60952db300c69580a9eba01b5f787d6" name="aa60952db300c69580a9eba01b5f787d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa60952db300c69580a9eba01b5f787d6">&#9670;&#160;</a></span>dense_row() <span class="overload">[9/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::dense_row </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>oracle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an oracle-aware row-wise extractor that retrieves all columns in dense form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oracle</td><td>An oracle supplying row predictions. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting each row in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="acc57cd1f625bdc44af4946a0124f7464" name="acc57cd1f625bdc44af4946a0124f7464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc57cd1f625bdc44af4946a0124f7464">&#9670;&#160;</a></span>dense_row() <span class="overload">[10/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::dense_row </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>oracle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>block_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>block_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an oracle-aware row-wise extractor that retrieves a contiguous block of columns in dense form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oracle</td><td>An oracle supplying row predictions. </td></tr>
    <tr><td class="paramname">block_start</td><td>Index of the column at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of columns in the block. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting a contiguous block from each row. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="ab247d39db776da3e2143f4599f76920e" name="ab247d39db776da3e2143f4599f76920e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab247d39db776da3e2143f4599f76920e">&#9670;&#160;</a></span>dense_row() <span class="overload">[11/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::dense_row </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>oracle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#abbb0bdf0b79fe19e504b49b43984f634">VectorPtr</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;&#160;</td>
          <td class="paramname"><em>indices_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an oracle-aware row-wise extractor that retrieves an indexed subset of columns in dense form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oracle</td><td>An oracle supplying row predictions. </td></tr>
    <tr><td class="paramname">indices_ptr</td><td>Pointer to a vector of sorted and unique column indices. This should not be NULL. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each row in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="ad8f53f2f7b2a2e5972a91a56065ba28b" name="ad8f53f2f7b2a2e5972a91a56065ba28b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8f53f2f7b2a2e5972a91a56065ba28b">&#9670;&#160;</a></span>dense_row() <span class="overload">[12/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::dense_row </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>oracle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an oracle-aware row-wise extractor that retrieves an indexed subset of columns in dense form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oracle</td><td>An oracle supplying row predictions. </td></tr>
    <tr><td class="paramname">indices</td><td>Vector of sorted and unique column indices. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each row in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a8ca1e41bc821f551d76175687fd2e6b5" name="a8ca1e41bc821f551d76175687fd2e6b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ca1e41bc821f551d76175687fd2e6b5">&#9670;&#160;</a></span>dense_column() <span class="overload">[9/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::dense_column </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>oracle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an oracle-aware column-wise extractor that retrieves all rows in dense form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oracle</td><td>An oracle supplying column predictions. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting each column in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a2323a04228d638ec0340036acafa420f" name="a2323a04228d638ec0340036acafa420f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2323a04228d638ec0340036acafa420f">&#9670;&#160;</a></span>dense_column() <span class="overload">[10/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::dense_column </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>oracle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>block_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>block_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an oracle-aware column-wise extractor that retrieves a contiguous block of rows in dense form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_start</td><td>Index of the row at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of rows in the block. </td></tr>
    <tr><td class="paramname">oracle</td><td>An oracle supplying column predictions. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting a contiguous block from each column in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a8d717304d7cf4806c182ecd446de144d" name="a8d717304d7cf4806c182ecd446de144d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d717304d7cf4806c182ecd446de144d">&#9670;&#160;</a></span>dense_column() <span class="overload">[11/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::dense_column </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>oracle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#abbb0bdf0b79fe19e504b49b43984f634">VectorPtr</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;&#160;</td>
          <td class="paramname"><em>indices_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an oracle-aware column-wise extractor that retrieves an indexed subset of rows in dense form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oracle</td><td>An oracle supplying column predictions. </td></tr>
    <tr><td class="paramname">indices_ptr</td><td>Pointer to a vector of sorted and unique row indices. This should not be NULL. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each column in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a585337cdd3a90c5cf6cf2fdca2b43e84" name="a585337cdd3a90c5cf6cf2fdca2b43e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a585337cdd3a90c5cf6cf2fdca2b43e84">&#9670;&#160;</a></span>dense_column() <span class="overload">[12/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::dense_column </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>oracle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an oracle-aware column-wise extractor that retrieves an indexed subset of rows in dense form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oracle</td><td>An oracle supplying column predictions. </td></tr>
    <tr><td class="paramname">indices</td><td>Vector of sorted and unique row indices. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each column in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a9fb2b21aad79130762a8cb0c7069d3a3" name="a9fb2b21aad79130762a8cb0c7069d3a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fb2b21aad79130762a8cb0c7069d3a3">&#9670;&#160;</a></span>dense_row() <span class="overload">[13/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::dense_row </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>oracle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="classtatami_1_1Matrix.html#a4d572f319b614a7e74d426cac94194de">dense_row()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oracle</td><td>An oracle supplying row predictions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting each row in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a2cecc240982c961455ede8d329cda207" name="a2cecc240982c961455ede8d329cda207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cecc240982c961455ede8d329cda207">&#9670;&#160;</a></span>dense_row() <span class="overload">[14/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::dense_row </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>oracle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>block_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>block_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="classtatami_1_1Matrix.html#a4d572f319b614a7e74d426cac94194de">dense_row()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oracle</td><td>An oracle supplying row predictions. </td></tr>
    <tr><td class="paramname">block_start</td><td>Index of the column at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of columns in the block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting a contiguous block from each row in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a32275c6bf6553d6b1833abdce9165b5d" name="a32275c6bf6553d6b1833abdce9165b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32275c6bf6553d6b1833abdce9165b5d">&#9670;&#160;</a></span>dense_row() <span class="overload">[15/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::dense_row </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>oracle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#abbb0bdf0b79fe19e504b49b43984f634">VectorPtr</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;&#160;</td>
          <td class="paramname"><em>indices_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="classtatami_1_1Matrix.html#a4d572f319b614a7e74d426cac94194de">dense_row()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices_ptr</td><td>Pointer to a vector of sorted and unique column indices. This should not be NULL. </td></tr>
    <tr><td class="paramname">oracle</td><td>An oracle supplying row predictions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each row in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a6ce58d2a5e7b244b49a97cabff56c94b" name="a6ce58d2a5e7b244b49a97cabff56c94b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ce58d2a5e7b244b49a97cabff56c94b">&#9670;&#160;</a></span>dense_row() <span class="overload">[16/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::dense_row </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>oracle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="classtatami_1_1Matrix.html#a4d572f319b614a7e74d426cac94194de">dense_row()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Vector of sorted and unique column indices. </td></tr>
    <tr><td class="paramname">oracle</td><td>An oracle supplying row predictions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each row in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a068863a2b525300afb446aa249f67f6b" name="a068863a2b525300afb446aa249f67f6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068863a2b525300afb446aa249f67f6b">&#9670;&#160;</a></span>dense_column() <span class="overload">[13/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::dense_column </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>oracle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="classtatami_1_1Matrix.html#aa2dad77430f29f277f73028c7c2636e2">dense_column()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oracle</td><td>An oracle supplying column predictions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting each column in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a3a9d3994a74ebdf26894d92ad3625d8c" name="a3a9d3994a74ebdf26894d92ad3625d8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a9d3994a74ebdf26894d92ad3625d8c">&#9670;&#160;</a></span>dense_column() <span class="overload">[14/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::dense_column </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>oracle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>block_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>block_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="classtatami_1_1Matrix.html#aa2dad77430f29f277f73028c7c2636e2">dense_column()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_start</td><td>Index of the row at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of rows in the block. </td></tr>
    <tr><td class="paramname">oracle</td><td>An oracle supplying column predictions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting a contiguous block from each column in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a3d214b599712ab2f265b06d45d9e7047" name="a3d214b599712ab2f265b06d45d9e7047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d214b599712ab2f265b06d45d9e7047">&#9670;&#160;</a></span>dense_column() <span class="overload">[15/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::dense_column </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>oracle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#abbb0bdf0b79fe19e504b49b43984f634">VectorPtr</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;&#160;</td>
          <td class="paramname"><em>indices_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="classtatami_1_1Matrix.html#aa2dad77430f29f277f73028c7c2636e2">dense_column()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices_ptr</td><td>Pointer to a vector of sorted and unique row indices. This should not be NULL. </td></tr>
    <tr><td class="paramname">oracle</td><td>An oracle supplying column predictions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each column in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a6421e936b7d10b2dee56c41c6591322e" name="a6421e936b7d10b2dee56c41c6591322e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6421e936b7d10b2dee56c41c6591322e">&#9670;&#160;</a></span>dense_column() <span class="overload">[16/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::dense_column </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>oracle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="classtatami_1_1Matrix.html#aa2dad77430f29f277f73028c7c2636e2">dense_column()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Vector of sorted and unique row indices. </td></tr>
    <tr><td class="paramname">oracle</td><td>An oracle supplying column predictions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each column in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a5605c18620abdab0f82015b959e9813a" name="a5605c18620abdab0f82015b959e9813a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5605c18620abdab0f82015b959e9813a">&#9670;&#160;</a></span>sparse() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">virtual</a> std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::sparse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>oracle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an oracle-aware extractor that retrieves the full extent of the non-target dimension in sparse form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Whether to create a row-wise extractor, i.e., the rows are the target dimension. </td></tr>
    <tr><td class="paramname">oracle</td><td>An oracle supplying predictions of the next requested row (if <code>row = true</code>) or column (otherwise). </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting each row (if <code>row = true)</code> or columns (otherwise) in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1DenseMatrix.html#ae8b40e14802cdad7312caf3e8248489a">tatami::DenseMatrix&lt; Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#ae8b40e14802cdad7312caf3e8248489a">tatami::DenseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt; &gt;</a>, <a class="el" href="classtatami_1_1DelayedBinaryIsometricOp.html#a41c8f740445b52764e9199ba004f429c">tatami::DelayedBinaryIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedUnaryIsometricOp.html#a11a81a813efe81e3ed418c579895cd6e">tatami::DelayedUnaryIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a9e432929eb5b907baff964410dd35caf">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a021c20b362a86fd64620f712f9995f0e">tatami::CompressedSparseMatrix&lt; Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a021c20b362a86fd64620f712f9995f0e">tatami::CompressedSparseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt;, std::vector&lt; Index_ &gt;, std::vector&lt; size_t &gt; &gt;</a>, <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#a28e0ad8828c1e93e329fbf676dd5f582">tatami::FragmentedSparseMatrix&lt; Value_, Index_, ValueVectorStorage_, IndexVectorStorage_ &gt;</a>, <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#a28e0ad8828c1e93e329fbf676dd5f582">tatami::FragmentedSparseMatrix&lt; Value_, Index_, std::vector&lt; std::vector&lt; Value_ &gt; &gt;, std::vector&lt; std::vector&lt; Index_ &gt; &gt; &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#af215a2985049fc04f1d5c912672804fc">tatami::DelayedSubset&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a383ec95c99cfbd8787b69fab35e2e5ce">tatami::DelayedSubsetBlock&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a8cacaea9570300a3f4f34412dc2071a5">tatami::DelayedSubsetSorted&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#adbb19d843779a867e7d45ff46d9bfd63">tatami::DelayedSubsetSortedUnique&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a2369e8312245435a5b906870a6a28b65">tatami::DelayedSubsetUnique&lt; Value_, Index_, IndexStorage_ &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#af2eb799fb84aaacee5c7c1eebb3463fd">tatami::DelayedCast&lt; ValueOut_, IndexOut_, ValueIn_, IndexIn_ &gt;</a>.</p>

</div>
</div>
<a id="aacfcf54358970874051e5cc700730707" name="aacfcf54358970874051e5cc700730707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacfcf54358970874051e5cc700730707">&#9670;&#160;</a></span>sparse() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">virtual</a> std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::sparse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>oracle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>block_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>block_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an oracle-aware extractor that retrieves a contiguous block of the non-target dimension in sparse form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Whether to create a row-wise extractor, i.e., the rows are the target dimension. </td></tr>
    <tr><td class="paramname">oracle</td><td>An oracle supplying predictions of the next requested row (if <code>row = true</code>) or column (otherwise). </td></tr>
    <tr><td class="paramname">block_start</td><td>Index of the column (if <code>row = true</code>) or row (otherwise) at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of columns (if <code>row = true</code>) or rows (otherwise) in the block. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting a contiguous block from each row (if <code>row = true</code>) or column (otherwise) in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1DenseMatrix.html#a076632321ee3a36f1b7f306ffafe0150">tatami::DenseMatrix&lt; Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a076632321ee3a36f1b7f306ffafe0150">tatami::DenseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt; &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a9d7c4763266aacc9dd8e8bf18cd6bdf5">tatami::CompressedSparseMatrix&lt; Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a9d7c4763266aacc9dd8e8bf18cd6bdf5">tatami::CompressedSparseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt;, std::vector&lt; Index_ &gt;, std::vector&lt; size_t &gt; &gt;</a>, <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#a307940f3bbba99d017184a938833fe0a">tatami::FragmentedSparseMatrix&lt; Value_, Index_, ValueVectorStorage_, IndexVectorStorage_ &gt;</a>, <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#a307940f3bbba99d017184a938833fe0a">tatami::FragmentedSparseMatrix&lt; Value_, Index_, std::vector&lt; std::vector&lt; Value_ &gt; &gt;, std::vector&lt; std::vector&lt; Index_ &gt; &gt; &gt;</a>, <a class="el" href="classtatami_1_1DelayedBinaryIsometricOp.html#a838508085cd7cba5f75f3e7b3603971f">tatami::DelayedBinaryIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedUnaryIsometricOp.html#a4df36728071613a35df08fb13948ec01">tatami::DelayedUnaryIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a4bc7241dd0cbcba64844ff98b0f3c219">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#af9387c8af9cc8b7ce371b74e3bce9acb">tatami::DelayedSubset&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a7fd46b6f3a4cefb5709db879fe85287e">tatami::DelayedSubsetBlock&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#afbbcc960db85019ad9c377517e014311">tatami::DelayedSubsetSorted&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a4f2c396e829cf41d2a5bc72aa2218f3c">tatami::DelayedSubsetSortedUnique&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#aa2a589bcb668b82358301991dd65eb85">tatami::DelayedSubsetUnique&lt; Value_, Index_, IndexStorage_ &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#a69d08b80168e508dd42b321b742e825d">tatami::DelayedCast&lt; ValueOut_, IndexOut_, ValueIn_, IndexIn_ &gt;</a>.</p>

</div>
</div>
<a id="abe7557a27bbb09f8453a3e6848ad910e" name="abe7557a27bbb09f8453a3e6848ad910e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe7557a27bbb09f8453a3e6848ad910e">&#9670;&#160;</a></span>sparse() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">virtual</a> std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::sparse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>oracle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#abbb0bdf0b79fe19e504b49b43984f634">VectorPtr</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;&#160;</td>
          <td class="paramname"><em>indices_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an oracle-aware extractor that retrieves an indexed subset of the non-target dimension in sparse form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Whether to create a row-wise extractor, i.e., the rows are the target dimension. </td></tr>
    <tr><td class="paramname">oracle</td><td>An oracle supplying predictions of the next requested row (if <code>row = true</code>) or column (otherwise). </td></tr>
    <tr><td class="paramname">indices_ptr</td><td>Pointer to a vector of sorted and unique column indices (if <code>row = true</code>) or row indices (otherwise). This should not be NULL. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each row (if <code>row = true</code>) or column (otherwise) in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1DelayedTranspose.html#acae831b9ba93460af968b319a924a17a">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a5eb5622d0bf742933efc4a5712337504">tatami::DenseMatrix&lt; Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a5eb5622d0bf742933efc4a5712337504">tatami::DenseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt; &gt;</a>, <a class="el" href="classtatami_1_1DelayedBinaryIsometricOp.html#a161020535c5052af1154a8d578ed585a">tatami::DelayedBinaryIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedUnaryIsometricOp.html#a2acae9be5a86585c021899b755531a4a">tatami::DelayedUnaryIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a9421a1eae11ef1b96dd827e5cac93422">tatami::CompressedSparseMatrix&lt; Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a9421a1eae11ef1b96dd827e5cac93422">tatami::CompressedSparseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt;, std::vector&lt; Index_ &gt;, std::vector&lt; size_t &gt; &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a8e4dc8a870a15531390fa8aad1d5b91c">tatami::DelayedSubset&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a4c0f79b67346db6cfc40f0658b761f76">tatami::DelayedSubsetBlock&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a781562965f77a996db79a96993013540">tatami::DelayedSubsetSorted&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#ab692a3a4f46718854f7455ee55e55b2e">tatami::DelayedSubsetSortedUnique&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a347e927ce1e90d7675d4420d8cd06b16">tatami::DelayedSubsetUnique&lt; Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#a26ebfcf4c5f6ea5d4d4364991be2e9ce">tatami::FragmentedSparseMatrix&lt; Value_, Index_, ValueVectorStorage_, IndexVectorStorage_ &gt;</a>, <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#a26ebfcf4c5f6ea5d4d4364991be2e9ce">tatami::FragmentedSparseMatrix&lt; Value_, Index_, std::vector&lt; std::vector&lt; Value_ &gt; &gt;, std::vector&lt; std::vector&lt; Index_ &gt; &gt; &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#a269a645ac529416d11e1b3b3d115184f">tatami::DelayedCast&lt; ValueOut_, IndexOut_, ValueIn_, IndexIn_ &gt;</a>.</p>

</div>
</div>
<a id="a9914398b94a1a9f3082478d9646fc21d" name="a9914398b94a1a9f3082478d9646fc21d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9914398b94a1a9f3082478d9646fc21d">&#9670;&#160;</a></span>sparse_row() <span class="overload">[9/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::sparse_row </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>oracle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an oracle-aware row-wise extractor that retrieves all columns in sparse form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oracle</td><td>An oracle supplying row predictions. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting each row in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="af67262da7611609ba28f9ac1d9ed20e9" name="af67262da7611609ba28f9ac1d9ed20e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af67262da7611609ba28f9ac1d9ed20e9">&#9670;&#160;</a></span>sparse_row() <span class="overload">[10/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::sparse_row </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>oracle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>block_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>block_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an oracle-aware row-wise extractor that retrieves a contiguous block of columns in sparse form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oracle</td><td>An oracle supplying row predictions. </td></tr>
    <tr><td class="paramname">block_start</td><td>Index of the column at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of columns in the block. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting a contiguous block from each row in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="af86c164710f168484a0037169bf51622" name="af86c164710f168484a0037169bf51622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af86c164710f168484a0037169bf51622">&#9670;&#160;</a></span>sparse_row() <span class="overload">[11/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::sparse_row </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>oracle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#abbb0bdf0b79fe19e504b49b43984f634">VectorPtr</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;&#160;</td>
          <td class="paramname"><em>indices_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an oracle-aware row-wise extractor that retrieves an indexed subset of columns in sparse form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oracle</td><td>An oracle supplying row predictions. </td></tr>
    <tr><td class="paramname">indices_ptr</td><td>Pointer to a vector of sorted and unique column indices. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each row in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a47155bacf33f5c269c8da4ce96d1adb8" name="a47155bacf33f5c269c8da4ce96d1adb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47155bacf33f5c269c8da4ce96d1adb8">&#9670;&#160;</a></span>sparse_row() <span class="overload">[12/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::sparse_row </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>oracle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an oracle-aware row-wise extractor that retrieves an indexed subset of columns in sparse form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oracle</td><td>An oracle supplying row predictions. </td></tr>
    <tr><td class="paramname">indices</td><td>Vector of sorted and unique column indices. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each row in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a25ce6f1c8ad4f4d2e8d62c8e005c7df8" name="a25ce6f1c8ad4f4d2e8d62c8e005c7df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25ce6f1c8ad4f4d2e8d62c8e005c7df8">&#9670;&#160;</a></span>sparse_column() <span class="overload">[9/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::sparse_column </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>oracle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an oracle-aware column-wise extractor that retrieves all rows in sparse form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oracle</td><td>An oracle supplying column predictions. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting each column in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a576f3bd09c075d59101e561c715c82e2" name="a576f3bd09c075d59101e561c715c82e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a576f3bd09c075d59101e561c715c82e2">&#9670;&#160;</a></span>sparse_column() <span class="overload">[10/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::sparse_column </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>oracle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>block_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>block_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an oracle-aware column-wise extractor that retrieves a contiguous block of rows in sparse form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_start</td><td>Index of the row at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of rows in the block. </td></tr>
    <tr><td class="paramname">oracle</td><td>An oracle supplying column predictions. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting a contiguous block from each column in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a413c72fd73b8e156f3b2fb3f8ebd2497" name="a413c72fd73b8e156f3b2fb3f8ebd2497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a413c72fd73b8e156f3b2fb3f8ebd2497">&#9670;&#160;</a></span>sparse_column() <span class="overload">[11/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::sparse_column </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>oracle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#abbb0bdf0b79fe19e504b49b43984f634">VectorPtr</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;&#160;</td>
          <td class="paramname"><em>indices_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an oracle-aware column-wise extractor that retrieves an indexed subset of rows in sparse form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oracle</td><td>An oracle supplying column predictions. </td></tr>
    <tr><td class="paramname">indices_ptr</td><td>Pointer to a vector of sorted and unique row indices. This should not be NULL. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each column in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="acfbdd5c72c285b22942ce2714874b810" name="acfbdd5c72c285b22942ce2714874b810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfbdd5c72c285b22942ce2714874b810">&#9670;&#160;</a></span>sparse_column() <span class="overload">[12/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::sparse_column </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>oracle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an oracle-aware column-wise extractor that retrieves an indexed subset of rows in sparse form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oracle</td><td>An oracle supplying column predictions. </td></tr>
    <tr><td class="paramname">indices</td><td>Vector of sorted and unique row indices. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each column in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="ac69c3729445a087b33bfa9717b8e0bd1" name="ac69c3729445a087b33bfa9717b8e0bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac69c3729445a087b33bfa9717b8e0bd1">&#9670;&#160;</a></span>sparse_row() <span class="overload">[13/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::sparse_row </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>oracle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="classtatami_1_1Matrix.html#aedecd4c23762ff43f49cfb0d2c687056">sparse_row()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oracle</td><td>An oracle supplying row predictions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting each row in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="ae052d20e59e1cd0c58915f1165c42b44" name="ae052d20e59e1cd0c58915f1165c42b44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae052d20e59e1cd0c58915f1165c42b44">&#9670;&#160;</a></span>sparse_row() <span class="overload">[14/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::sparse_row </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>oracle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>block_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>block_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="classtatami_1_1Matrix.html#aedecd4c23762ff43f49cfb0d2c687056">sparse_row()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_start</td><td>Index of the column at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of columns in the block. </td></tr>
    <tr><td class="paramname">oracle</td><td>An oracle supplying row predictions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting a contiguous block from each row in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a3fc1dfadd943138f21cf3e9dd1f89147" name="a3fc1dfadd943138f21cf3e9dd1f89147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fc1dfadd943138f21cf3e9dd1f89147">&#9670;&#160;</a></span>sparse_row() <span class="overload">[15/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::sparse_row </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>oracle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#abbb0bdf0b79fe19e504b49b43984f634">VectorPtr</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;&#160;</td>
          <td class="paramname"><em>indices_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="classtatami_1_1Matrix.html#aedecd4c23762ff43f49cfb0d2c687056">sparse_row()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oracle</td><td>An oracle supplying row predictions. </td></tr>
    <tr><td class="paramname">indices_ptr</td><td>Pointer to a vector of sorted and unique column indices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each row in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a59f8dbf2064d74038813b5c0191a6542" name="a59f8dbf2064d74038813b5c0191a6542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f8dbf2064d74038813b5c0191a6542">&#9670;&#160;</a></span>sparse_row() <span class="overload">[16/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::sparse_row </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>oracle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="classtatami_1_1Matrix.html#aedecd4c23762ff43f49cfb0d2c687056">sparse_row()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oracle</td><td>An oracle supplying row predictions. </td></tr>
    <tr><td class="paramname">indices</td><td>Vector of sorted and unique column indices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each row in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a8274ac6fb2345fcece74e6fdb35e05d4" name="a8274ac6fb2345fcece74e6fdb35e05d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8274ac6fb2345fcece74e6fdb35e05d4">&#9670;&#160;</a></span>sparse_column() <span class="overload">[13/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::sparse_column </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>oracle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="classtatami_1_1Matrix.html#ab0efad968be5f4b9a36bb50beb8460f8">sparse_column()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oracle</td><td>An oracle supplying column predictions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting each column in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a9538dcc44c008dd203e719a855ac7fca" name="a9538dcc44c008dd203e719a855ac7fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9538dcc44c008dd203e719a855ac7fca">&#9670;&#160;</a></span>sparse_column() <span class="overload">[14/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::sparse_column </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>oracle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>block_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>block_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="classtatami_1_1Matrix.html#ab0efad968be5f4b9a36bb50beb8460f8">sparse_column()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_start</td><td>Index of the row at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of rows in the block. </td></tr>
    <tr><td class="paramname">oracle</td><td>An oracle supplying column predictions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting a contiguous block from each column in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a917f575b5430e14e2ccda56a5b6903be" name="a917f575b5430e14e2ccda56a5b6903be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a917f575b5430e14e2ccda56a5b6903be">&#9670;&#160;</a></span>sparse_column() <span class="overload">[15/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::sparse_column </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>oracle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#abbb0bdf0b79fe19e504b49b43984f634">VectorPtr</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;&#160;</td>
          <td class="paramname"><em>indices_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="classtatami_1_1Matrix.html#ab0efad968be5f4b9a36bb50beb8460f8">sparse_column()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices_ptr</td><td>Pointer to a vector of sorted and unique row indices. </td></tr>
    <tr><td class="paramname">oracle</td><td>An oracle supplying column predictions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each column in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="ad3c6514d93279e77fb8505d29c334217" name="ad3c6514d93279e77fb8505d29c334217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3c6514d93279e77fb8505d29c334217">&#9670;&#160;</a></span>sparse_column() <span class="overload">[16/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;::sparse_column </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>oracle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="classtatami_1_1Matrix.html#ab0efad968be5f4b9a36bb50beb8460f8">sparse_column()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Vector of sorted and unique row indices. </td></tr>
    <tr><td class="paramname">oracle</td><td>An oracle supplying column predictions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each column in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>tatami/base/<a class="el" href="Matrix_8hpp_source.html">Matrix.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
