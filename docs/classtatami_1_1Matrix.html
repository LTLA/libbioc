<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tatami: tatami::Matrix&lt; Value_, Index_ &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tatami
   </div>
   <div id="projectbrief">C++ API for different matrix representations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetatami.html">tatami</a></li><li class="navelem"><a class="el" href="classtatami_1_1Matrix.html">Matrix</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classtatami_1_1Matrix-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">tatami::Matrix&lt; Value_, Index_ &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Virtual class for a matrix with a defined type.  
 <a href="classtatami_1_1Matrix.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Matrix_8hpp_source.html">Matrix.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for tatami::Matrix&lt; Value_, Index_ &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classtatami_1_1Matrix__inherit__graph.png" border="0" usemap="#atatami_1_1Matrix_3_01Value___00_01Index___01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="atatami_1_1Matrix_3_01Value___00_01Index___01_4_inherit__map" id="atatami_1_1Matrix_3_01Value___00_01Index___01_4_inherit__map">
<area shape="rect" title="Virtual class for a matrix with a defined type." alt="" coords="5,129,148,170"/>
<area shape="rect" href="classtatami_1_1VirtualDenseMatrix.html" title=" " alt="" coords="224,5,397,46"/>
<area shape="rect" href="classtatami_1_1CompressedSparseMatrix.html" title="Compressed sparse matrix representation." alt="" coords="201,70,420,141"/>
<area shape="rect" href="classtatami_1_1SemiCompressedSparseMatrix.html" title="Semi&#45;compressed sparse matrix representation." alt="" coords="196,165,425,220"/>
<area shape="rect" href="classtatami_1_1VirtualDenseMatrix.html" title="Virtual class for a dense matrix with a defined type." alt="" coords="224,244,397,285"/>
<area shape="rect" href="classtatami_1_1DenseMatrix.html" title="Dense matrix representation." alt="" coords="473,237,618,292"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5b783d3ab440b7696c635a4b16516ba8"><td class="memItemLeft" align="right" valign="top">typedef Value_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a5b783d3ab440b7696c635a4b16516ba8">value_type</a></td></tr>
<tr class="separator:a5b783d3ab440b7696c635a4b16516ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adebf536caf3a3c1751eefc6e10f0b16e"><td class="memItemLeft" align="right" valign="top">typedef Index_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#adebf536caf3a3c1751eefc6e10f0b16e">index_type</a></td></tr>
<tr class="separator:adebf536caf3a3c1751eefc6e10f0b16e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a54fe7b4baf78069d35ff00357a1b6cc6"><td class="memItemLeft" align="right" valign="top">virtual Index_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a54fe7b4baf78069d35ff00357a1b6cc6">nrow</a> () const =0</td></tr>
<tr class="separator:a54fe7b4baf78069d35ff00357a1b6cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6fec43d5bae3f831841646bc02377b"><td class="memItemLeft" align="right" valign="top">virtual Index_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a1f6fec43d5bae3f831841646bc02377b">ncol</a> () const =0</td></tr>
<tr class="separator:a1f6fec43d5bae3f831841646bc02377b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de24a05a6aee62d4ba59799a73242e7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a9de24a05a6aee62d4ba59799a73242e7">sparse</a> () const =0</td></tr>
<tr class="separator:a9de24a05a6aee62d4ba59799a73242e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1a29b602b903201fc36ad65f76c78c"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a8a1a29b602b903201fc36ad65f76c78c">sparse_proportion</a> () const =0</td></tr>
<tr class="separator:a8a1a29b602b903201fc36ad65f76c78c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69382d2a4e66cda1a9eb48dc25ab113a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a69382d2a4e66cda1a9eb48dc25ab113a">prefer_rows</a> () const =0</td></tr>
<tr class="separator:a69382d2a4e66cda1a9eb48dc25ab113a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ddcc730155ca894df1c58b0a963d5e7"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a2ddcc730155ca894df1c58b0a963d5e7">prefer_rows_proportion</a> () const =0</td></tr>
<tr class="separator:a2ddcc730155ca894df1c58b0a963d5e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68da21245203cf9349648c5452cdb2ca"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a68da21245203cf9349648c5452cdb2ca">uses_oracle</a> (bool row) const =0</td></tr>
<tr class="separator:a68da21245203cf9349648c5452cdb2ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa29b9428f53453369256d7febc9ed0fc"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="namespacetatami.html#a6008dbced6de41e5619156b5335f5762">FullDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#aa29b9428f53453369256d7febc9ed0fc">dense_row</a> (const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const =0</td></tr>
<tr class="separator:aa29b9428f53453369256d7febc9ed0fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d96127de1d22a5d976b9a2f46ae0ab4"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="namespacetatami.html#ae75de1fc78b7d361ea8b59a5379ea4da">BlockDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a7d96127de1d22a5d976b9a2f46ae0ab4">dense_row</a> (Index_ block_start, Index_ block_length, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const =0</td></tr>
<tr class="separator:a7d96127de1d22a5d976b9a2f46ae0ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9cc13a9df94e59d03772bde6ef565a"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="namespacetatami.html#a47ce406c32c3914c2ecce187e21b6ced">IndexDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#aba9cc13a9df94e59d03772bde6ef565a">dense_row</a> (std::vector&lt; Index_ &gt; indices, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const =0</td></tr>
<tr class="separator:aba9cc13a9df94e59d03772bde6ef565a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6c3453a5c0c28a764f300f45bf860f"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="namespacetatami.html#a6008dbced6de41e5619156b5335f5762">FullDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a9f6c3453a5c0c28a764f300f45bf860f">dense_column</a> (const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const =0</td></tr>
<tr class="separator:a9f6c3453a5c0c28a764f300f45bf860f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ddceca01de5d1985aafa6e8bfdcf604"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="namespacetatami.html#ae75de1fc78b7d361ea8b59a5379ea4da">BlockDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a3ddceca01de5d1985aafa6e8bfdcf604">dense_column</a> (Index_ block_start, Index_ block_length, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const =0</td></tr>
<tr class="separator:a3ddceca01de5d1985aafa6e8bfdcf604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ddabd4babf3d162f0901578c520a9a"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="namespacetatami.html#a47ce406c32c3914c2ecce187e21b6ced">IndexDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a28ddabd4babf3d162f0901578c520a9a">dense_column</a> (std::vector&lt; Index_ &gt; indices, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const =0</td></tr>
<tr class="separator:a28ddabd4babf3d162f0901578c520a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee56bee86c500a4f4a3940e8ef18459"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="namespacetatami.html#a0fbb0624c8e1913a87e8fb5c975400e1">FullSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#adee56bee86c500a4f4a3940e8ef18459">sparse_row</a> (const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const =0</td></tr>
<tr class="separator:adee56bee86c500a4f4a3940e8ef18459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e592bf93aa216045a93efb923107e6"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="namespacetatami.html#ac8d0024399a66ce61f6315f5f46ebb63">BlockSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a82e592bf93aa216045a93efb923107e6">sparse_row</a> (Index_ block_start, Index_ block_length, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const =0</td></tr>
<tr class="separator:a82e592bf93aa216045a93efb923107e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa452ec9e476c69cdd9c7079a4d382af9"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="namespacetatami.html#a4b67b4d1b6c00cd0bd449703432a5f7b">IndexSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#aa452ec9e476c69cdd9c7079a4d382af9">sparse_row</a> (std::vector&lt; Index_ &gt; indices, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const =0</td></tr>
<tr class="separator:aa452ec9e476c69cdd9c7079a4d382af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fcbdc787f4b4980f57c228dc89f6289"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="namespacetatami.html#a0fbb0624c8e1913a87e8fb5c975400e1">FullSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a6fcbdc787f4b4980f57c228dc89f6289">sparse_column</a> (const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const =0</td></tr>
<tr class="separator:a6fcbdc787f4b4980f57c228dc89f6289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369b6b56d1f290d0b298ef840119468a"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="namespacetatami.html#ac8d0024399a66ce61f6315f5f46ebb63">BlockSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a369b6b56d1f290d0b298ef840119468a">sparse_column</a> (Index_ block_start, Index_ block_length, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const =0</td></tr>
<tr class="separator:a369b6b56d1f290d0b298ef840119468a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120c3a294a1ffd715c86b136902b8c51"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="namespacetatami.html#a4b67b4d1b6c00cd0bd449703432a5f7b">IndexSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a120c3a294a1ffd715c86b136902b8c51">sparse_column</a> (std::vector&lt; Index_ &gt; indices, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const =0</td></tr>
<tr class="separator:a120c3a294a1ffd715c86b136902b8c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3913e6cfd25586f37c0833a21c8f0ca6"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="namespacetatami.html#a6008dbced6de41e5619156b5335f5762">FullDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a3913e6cfd25586f37c0833a21c8f0ca6">dense_row</a> () const</td></tr>
<tr class="separator:a3913e6cfd25586f37c0833a21c8f0ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6456594fe017e5f61a2adce0ce152ee4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="namespacetatami.html#ae75de1fc78b7d361ea8b59a5379ea4da">BlockDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a6456594fe017e5f61a2adce0ce152ee4">dense_row</a> (Index_ block_start, Index_ block_length) const</td></tr>
<tr class="separator:a6456594fe017e5f61a2adce0ce152ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b4e61e29787566fcd78209d4930c2e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="namespacetatami.html#a47ce406c32c3914c2ecce187e21b6ced">IndexDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#aa2b4e61e29787566fcd78209d4930c2e">dense_row</a> (std::vector&lt; Index_ &gt; indices) const</td></tr>
<tr class="separator:aa2b4e61e29787566fcd78209d4930c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a543328188b8212c9267f9c5edc431"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="namespacetatami.html#a6008dbced6de41e5619156b5335f5762">FullDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a94a543328188b8212c9267f9c5edc431">dense_column</a> () const</td></tr>
<tr class="separator:a94a543328188b8212c9267f9c5edc431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39764e844f1da2b4027b61eb92b28674"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="namespacetatami.html#ae75de1fc78b7d361ea8b59a5379ea4da">BlockDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a39764e844f1da2b4027b61eb92b28674">dense_column</a> (Index_ block_start, Index_ block_length) const</td></tr>
<tr class="separator:a39764e844f1da2b4027b61eb92b28674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35af5355144252c421d3f4ee6c2aa51b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="namespacetatami.html#a47ce406c32c3914c2ecce187e21b6ced">IndexDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a35af5355144252c421d3f4ee6c2aa51b">dense_column</a> (std::vector&lt; Index_ &gt; indices) const</td></tr>
<tr class="separator:a35af5355144252c421d3f4ee6c2aa51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7274f8de1b6918f45291e10c054252a1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="namespacetatami.html#a0fbb0624c8e1913a87e8fb5c975400e1">FullSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a7274f8de1b6918f45291e10c054252a1">sparse_row</a> () const</td></tr>
<tr class="separator:a7274f8de1b6918f45291e10c054252a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae49828cfac71e469c569bd74a4ed006e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="namespacetatami.html#ac8d0024399a66ce61f6315f5f46ebb63">BlockSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#ae49828cfac71e469c569bd74a4ed006e">sparse_row</a> (Index_ block_start, Index_ block_length) const</td></tr>
<tr class="separator:ae49828cfac71e469c569bd74a4ed006e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f66f9ce349aabc63227aa4f1cad6ab"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="namespacetatami.html#a4b67b4d1b6c00cd0bd449703432a5f7b">IndexSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a26f66f9ce349aabc63227aa4f1cad6ab">sparse_row</a> (std::vector&lt; Index_ &gt; indices) const</td></tr>
<tr class="separator:a26f66f9ce349aabc63227aa4f1cad6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bfc42ee94b0068d1542c579718b52b4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="namespacetatami.html#a0fbb0624c8e1913a87e8fb5c975400e1">FullSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a8bfc42ee94b0068d1542c579718b52b4">sparse_column</a> () const</td></tr>
<tr class="separator:a8bfc42ee94b0068d1542c579718b52b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390f34d93c2b8d9dd561c6807aa8eac5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="namespacetatami.html#ac8d0024399a66ce61f6315f5f46ebb63">BlockSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a390f34d93c2b8d9dd561c6807aa8eac5">sparse_column</a> (Index_ block_start, Index_ block_length) const</td></tr>
<tr class="separator:a390f34d93c2b8d9dd561c6807aa8eac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f0867067f1b1e5a235a99ecf58924b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="namespacetatami.html#a4b67b4d1b6c00cd0bd449703432a5f7b">IndexSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a80f0867067f1b1e5a235a99ecf58924b">sparse_column</a> (std::vector&lt; Index_ &gt; indices) const</td></tr>
<tr class="separator:a80f0867067f1b1e5a235a99ecf58924b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Value_, typename Index_ = int&gt;<br />
class tatami::Matrix&lt; Value_, Index_ &gt;</div><p>Virtual class for a matrix with a defined type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value</td><td>Data value type, should be numeric. </td></tr>
    <tr><td class="paramname">Index</td><td>Row/column index type, should be integer. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a5b783d3ab440b7696c635a4b16516ba8" name="a5b783d3ab440b7696c635a4b16516ba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b783d3ab440b7696c635a4b16516ba8">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_  = int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Value_ <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::value_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of data to be returned by getters. </p>

</div>
</div>
<a id="adebf536caf3a3c1751eefc6e10f0b16e" name="adebf536caf3a3c1751eefc6e10f0b16e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adebf536caf3a3c1751eefc6e10f0b16e">&#9670;&#160;</a></span>index_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_  = int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Index_ <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::index_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of index to be returned by the sparse getters. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a54fe7b4baf78069d35ff00357a1b6cc6" name="a54fe7b4baf78069d35ff00357a1b6cc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54fe7b4baf78069d35ff00357a1b6cc6">&#9670;&#160;</a></span>nrow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Index_ <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::nrow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Number of rows. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1DenseMatrix.html#a108c3fffbcdd9ca44cde3c5e2ec8ce9a">tatami::DenseMatrix&lt; row_, Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a9e049edd599e1d740cab6642e5a7e849">tatami::DelayedIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#ad4b4b14a53e79294bb3c51e2d03edb54">tatami::DelayedBind&lt; margin_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#ac7cdb52624f338c4470990fd96a5ba25">tatami::DelayedCast&lt; Value_out_, Index_out_, Value_in_, Index_in_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#ae861c999ade80dfaab4e00ea0a3c9f89">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a3e67d6e54117433851d7c9453439f759">tatami::CompressedSparseMatrix&lt; row_, Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1SemiCompressedSparseMatrix.html#a0a168f9099fd7ffd63867af6365fd829">tatami::SemiCompressedSparseMatrix&lt; row_, Value_, Index_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a363f65ce5c29b4a4b9c8e49037559f69">tatami::DelayedSubset&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#ad464fba67568e017244f1a5378262b1f">tatami::DelayedSubsetBlock&lt; margin_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a4244a48118361e58e3b8dcf26384df45">tatami::DelayedSubsetSorted&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#ae01ccb17c3afde476f89dfe6b6312b45">tatami::DelayedSubsetSortedUnique&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a8cd3203978e03fc049acdb5c30609204">tatami::DelayedSubsetUnique&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#a163d426e4ce82fd02df6bbb57893f6c9">tatami::HDF5CompressedSparseMatrix&lt; row_, Value_, Index_ &gt;</a>, and <a class="el" href="classtatami_1_1HDF5DenseMatrix.html#a294b573e761f8dfc5225603b6eaa9e8b">tatami::HDF5DenseMatrix&lt; Value_, Index_, transpose_ &gt;</a>.</p>

</div>
</div>
<a id="a1f6fec43d5bae3f831841646bc02377b" name="a1f6fec43d5bae3f831841646bc02377b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f6fec43d5bae3f831841646bc02377b">&#9670;&#160;</a></span>ncol()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Index_ <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::ncol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Number of columns. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1DenseMatrix.html#ae025690fa69ae5acc9c2c25931c30efb">tatami::DenseMatrix&lt; row_, Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a951f20f06999e5bddd011f054c7eeed0">tatami::DelayedIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#af3e218d269c0dd0bf61358a2df462def">tatami::DelayedBind&lt; margin_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#adf4e97588cce683486827ab3325bb0ba">tatami::DelayedCast&lt; Value_out_, Index_out_, Value_in_, Index_in_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a495080ac6d15551d6816adf85ab2d481">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#aa3869e4e92e47566b5d238c2ac87526c">tatami::CompressedSparseMatrix&lt; row_, Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1SemiCompressedSparseMatrix.html#a6b2a17e27bc6a56f08096b6fbd147735">tatami::SemiCompressedSparseMatrix&lt; row_, Value_, Index_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#acf487dcd36c8612f8014bbe3b0362f4a">tatami::DelayedSubset&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#aeb6512ab3d6b70fa3ead75fd47995a60">tatami::DelayedSubsetBlock&lt; margin_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#abffcd6776a07da8f14fa4ca2b3410e8d">tatami::DelayedSubsetSorted&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#ad37c87845de22fd19218b32672f0a32f">tatami::DelayedSubsetSortedUnique&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#abc7eb3bb7c9f4024489deae9c1d3a78d">tatami::DelayedSubsetUnique&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#a0f449056dc91663ed8d31d2bcaadb3d7">tatami::HDF5CompressedSparseMatrix&lt; row_, Value_, Index_ &gt;</a>, and <a class="el" href="classtatami_1_1HDF5DenseMatrix.html#afe393cfdc1d176d2baa4471700f6d6a3">tatami::HDF5DenseMatrix&lt; Value_, Index_, transpose_ &gt;</a>.</p>

</div>
</div>
<a id="a9de24a05a6aee62d4ba59799a73242e7" name="a9de24a05a6aee62d4ba59799a73242e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9de24a05a6aee62d4ba59799a73242e7">&#9670;&#160;</a></span>sparse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Boolean indicating whether this matrix is sparse.</dd></dl>
<p>This can be used to choose between <code><a class="el" href="classtatami_1_1Matrix.html#a7274f8de1b6918f45291e10c054252a1">sparse_row()</a></code> and <code><a class="el" href="classtatami_1_1Matrix.html#a3913e6cfd25586f37c0833a21c8f0ca6">dense_row()</a></code> when iterating over the rows (similarly so for the columns). </p>

<p>Implemented in <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#a10ca176c496b318d7c84a73000d309ba">tatami::VirtualDenseMatrix&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#a10ca176c496b318d7c84a73000d309ba">tatami::VirtualDenseMatrix&lt; Value_, int &gt;</a>, <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#a10ca176c496b318d7c84a73000d309ba">tatami::VirtualDenseMatrix&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#ac6c8b7f109292373883f6a1fca8d91b9">tatami::DelayedIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a015cdac3de086438b5305195b84a2eee">tatami::DelayedBind&lt; margin_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#af0a4a7726a5b62c213c1d60470f026cb">tatami::DelayedCast&lt; Value_out_, Index_out_, Value_in_, Index_in_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a7e981425a1c2653be11ca4e1b14a2a64">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a96666f952ad63ede2f7920ce72fdaf37">tatami::CompressedSparseMatrix&lt; row_, Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1SemiCompressedSparseMatrix.html#a61a520975cbbdc711dd9e32681b11d49">tatami::SemiCompressedSparseMatrix&lt; row_, Value_, Index_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a2738d02a23fad9f5dca3125905533067">tatami::DelayedSubset&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#afbbdf9fe3282eb0e157020b44812daf1">tatami::DelayedSubsetBlock&lt; margin_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#ad3de98a3b6a0bd33081544b4757d014f">tatami::DelayedSubsetSorted&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a964965ffd2dbb46be8c2e43e43fe7021">tatami::DelayedSubsetSortedUnique&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#ab89df61da7d2dbda82198df41961f02d">tatami::DelayedSubsetUnique&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, and <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#a43de336cf9987caf8d2c59c6fe23602c">tatami::HDF5CompressedSparseMatrix&lt; row_, Value_, Index_ &gt;</a>.</p>

</div>
</div>
<a id="a8a1a29b602b903201fc36ad65f76c78c" name="a8a1a29b602b903201fc36ad65f76c78c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a1a29b602b903201fc36ad65f76c78c">&#9670;&#160;</a></span>sparse_proportion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse_proportion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Approximate proportion of the matrix that is sparse.</dd></dl>
<p>This is defined as the proportion of matrix elements that lie within sparse submatrices. It is intended for use in <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> representations that consist of combinations of multiple submatrices (e.g., <code><a class="el" href="classtatami_1_1DelayedBind.html" title="Delayed combining of a matrix.">DelayedBind</a></code>), allowing them to derive a suitable value for <code>sparse()</code> based on whether most of its submatrices are sparse. (A more granular approach would be to report the density of structural non-zero elements, but this may not be known by all representations at construction time.) </p>

<p>Implemented in <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#ad4a10daeac4ec28e4d8b256c9772f414">tatami::VirtualDenseMatrix&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#ad4a10daeac4ec28e4d8b256c9772f414">tatami::VirtualDenseMatrix&lt; Value_, int &gt;</a>, <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#ad4a10daeac4ec28e4d8b256c9772f414">tatami::VirtualDenseMatrix&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a6eba9d97d42a339c406a343990ddc880">tatami::DelayedIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a34cf182a2f93e85e8d408c25e01a5ac6">tatami::DelayedBind&lt; margin_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#a70fbb58b425d6a2898dcbd22e6492795">tatami::DelayedCast&lt; Value_out_, Index_out_, Value_in_, Index_in_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a778b7daddea3238c9aa8efe01b059fea">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a4f86d32bb4e4e74e3e20b60b02c45795">tatami::CompressedSparseMatrix&lt; row_, Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1SemiCompressedSparseMatrix.html#a849c19bd6cb418ebc09647b9b67084b9">tatami::SemiCompressedSparseMatrix&lt; row_, Value_, Index_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#acd7dfd1edbf3022c5140f5bc17330887">tatami::DelayedSubset&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a6d5db7efb0567a2447c82f1cefad7997">tatami::DelayedSubsetBlock&lt; margin_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a75b68a4d28ecc0073a81e6c407cb8930">tatami::DelayedSubsetSorted&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#acc91dead096884f86ef77b76a20dd775">tatami::DelayedSubsetSortedUnique&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a54c985af221be5d60b406f61e741691c">tatami::DelayedSubsetUnique&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, and <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#a0366548c6005913651ae54e12fa36f9b">tatami::HDF5CompressedSparseMatrix&lt; row_, Value_, Index_ &gt;</a>.</p>

</div>
</div>
<a id="a69382d2a4e66cda1a9eb48dc25ab113a" name="a69382d2a4e66cda1a9eb48dc25ab113a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69382d2a4e66cda1a9eb48dc25ab113a">&#9670;&#160;</a></span>prefer_rows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::prefer_rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The preferred dimension for extracting values. If <code>true</code>, row-wise extraction is preferred; if <code>false</code>, column-wise extraction is preferred. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1DenseMatrix.html#ab2dad56ac067668f2b845b7bcacf2f94">tatami::DenseMatrix&lt; row_, Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a9dbe5d5a51a0b410a69ba716e30ac8e2">tatami::DelayedIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a29672009babe2d5bea7a95ab94a827df">tatami::DelayedBind&lt; margin_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#a1c131c401dfbd89d3908c522a8876554">tatami::DelayedCast&lt; Value_out_, Index_out_, Value_in_, Index_in_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a8d386b8a0d05d6bcdbc1dd80c7d8118e">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a615e4caecc2e69d0adf16458908603e9">tatami::CompressedSparseMatrix&lt; row_, Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1SemiCompressedSparseMatrix.html#a74c4e8ac60e55b1d62aa159b85806467">tatami::SemiCompressedSparseMatrix&lt; row_, Value_, Index_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#ad7d937bb28815076108cf1d2cb7eb9ac">tatami::DelayedSubset&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a00ebfc270ed722fad12d9ca3349cbd33">tatami::DelayedSubsetBlock&lt; margin_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a685fbba599f884a4cf95a44e4fc4c7b9">tatami::DelayedSubsetSorted&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#abc50ddffc07bfe1075abcd7b4cc41e02">tatami::DelayedSubsetSortedUnique&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a8d030a0b68a377bc30962b0662acd856">tatami::DelayedSubsetUnique&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#adcb174f1a959314888c42b0cb9cecd2c">tatami::HDF5CompressedSparseMatrix&lt; row_, Value_, Index_ &gt;</a>, and <a class="el" href="classtatami_1_1HDF5DenseMatrix.html#a35f1ce4048550093989501a34735e204">tatami::HDF5DenseMatrix&lt; Value_, Index_, transpose_ &gt;</a>.</p>

</div>
</div>
<a id="a2ddcc730155ca894df1c58b0a963d5e7" name="a2ddcc730155ca894df1c58b0a963d5e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ddcc730155ca894df1c58b0a963d5e7">&#9670;&#160;</a></span>prefer_rows_proportion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::prefer_rows_proportion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Approximate proportion of the matrix that prefers row-level access.</dd></dl>
<p>This is defined as the proportion of matrix elements that lie within submatrices that prefer row-level access. It is useful for determining the return value of <code><a class="el" href="classtatami_1_1Matrix.html#a69382d2a4e66cda1a9eb48dc25ab113a">prefer_rows()</a></code> in combined matrices consisting of both row- and column-preferred submatrices. In such cases, the net preference can be determined based on the combined size of the submatrices for each preference. (A more granular approach would be to report the iteration cost on each dimension, but this is difficult to estimate.) </p>

<p>Implemented in <a class="el" href="classtatami_1_1DenseMatrix.html#a6e2b959fc2b6f7de296d244cbba5cfa8">tatami::DenseMatrix&lt; row_, Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#aeebc419c3764eaca3de72c899beea2a6">tatami::DelayedIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#ab225a92ca17c09b1eed5d4086cb1e33d">tatami::DelayedBind&lt; margin_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#a1b56caede22f9ef0b5ea2165265f0f51">tatami::DelayedCast&lt; Value_out_, Index_out_, Value_in_, Index_in_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#af218bfcac74f403cc9d5bd6be84cc7a5">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#acbe930f2e78252b1631d7657bbda2455">tatami::CompressedSparseMatrix&lt; row_, Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1SemiCompressedSparseMatrix.html#a2f603458319450865dc1226f05319050">tatami::SemiCompressedSparseMatrix&lt; row_, Value_, Index_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a86417eb7b4ea08c49a03b91098b50568">tatami::DelayedSubset&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a9de5fba27b120ec0a07c008ab964524a">tatami::DelayedSubsetBlock&lt; margin_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#aa643b08f0d8443d1611665205fd0bfe1">tatami::DelayedSubsetSorted&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#ad55e79fa2702133b64af71e5b93a41e3">tatami::DelayedSubsetSortedUnique&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#af303be4a8cf50222b93bd126a69920d7">tatami::DelayedSubsetUnique&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#a8e9c0bbab0df9e793888cec744c1478d">tatami::HDF5CompressedSparseMatrix&lt; row_, Value_, Index_ &gt;</a>, and <a class="el" href="classtatami_1_1HDF5DenseMatrix.html#a2991e36cab5dce92f729946ceaff63c2">tatami::HDF5DenseMatrix&lt; Value_, Index_, transpose_ &gt;</a>.</p>

</div>
</div>
<a id="a68da21245203cf9349648c5452cdb2ca" name="a68da21245203cf9349648c5452cdb2ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68da21245203cf9349648c5452cdb2ca">&#9670;&#160;</a></span>uses_oracle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::uses_oracle </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Row access if <code>true</code>, column access otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether this matrix's <code><a class="el" href="namespacetatami.html#ae9f8db5316521603085577d977a6955f">tatami::Extractor</a></code> classes make use of oracle predictions for row (if <code>row = true</code>) or column access (otherwise).</dd></dl>
<p>The output of this method indicates whether callers should construct an oracle for use in <code><a class="el" href="structtatami_1_1ExtractorBase.html#ab0e98cdedccd44333ab88cee7548221b">ExtractorBase::set_oracle()</a></code>. If <code>false</code>, callers should not bother to pass an oracle as it will be ignored. </p>

<p>Implemented in <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a50f95be58421a23d1488bf2f732b7287">tatami::DelayedIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#abd1a1ba10e6bd17707cd70852119e38c">tatami::DelayedBind&lt; margin_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#a07167517245ed8f4d3c112e4f4f3edac">tatami::DelayedCast&lt; Value_out_, Index_out_, Value_in_, Index_in_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a6e814addfd1b93d7999a5383d0e69104">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a3d6296d55f02ba1f39b5b9d66e50386c">tatami::DelayedSubset&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#ac989b4ed58351821d0b4e995db3ab658">tatami::DelayedSubsetBlock&lt; margin_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a810f2bab68978a1297e44fd6015dcb31">tatami::DelayedSubsetSorted&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#afd0685e407df2d3c0c08419f06d08802">tatami::DelayedSubsetSortedUnique&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#af9d1f0ab74ed37b79696f6fc993014f4">tatami::DelayedSubsetUnique&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a9b62638264c912ecb06cd8cf66bbe967">tatami::DenseMatrix&lt; row_, Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a3cb93a9b9f549f26eb847e29d8fa61e2">tatami::CompressedSparseMatrix&lt; row_, Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1SemiCompressedSparseMatrix.html#a6d059ba00d1970499fe34579c6ca5120">tatami::SemiCompressedSparseMatrix&lt; row_, Value_, Index_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#aa3666db63a8ca6d4ec6be26811667cbd">tatami::HDF5CompressedSparseMatrix&lt; row_, Value_, Index_ &gt;</a>, and <a class="el" href="classtatami_1_1HDF5DenseMatrix.html#a5e40d54fe33a6ee979da034d9fae1277">tatami::HDF5DenseMatrix&lt; Value_, Index_, transpose_ &gt;</a>.</p>

</div>
</div>
<a id="aa29b9428f53453369256d7febc9ed0fc" name="aa29b9428f53453369256d7febc9ed0fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa29b9428f53453369256d7febc9ed0fc">&#9670;&#160;</a></span>dense_row() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; <a class="el" href="namespacetatami.html#a6008dbced6de41e5619156b5335f5762">FullDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense_row </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for iteration and extraction.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>FullDenseExtractor</code> object for dense access to full rows. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> from which it was created. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1DenseMatrix.html#afcb586f220c1df06c464def9c6c4f004">tatami::DenseMatrix&lt; row_, Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a2a58dc540ba0184ac1cc0ac49bc5d589">tatami::DelayedIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#ac56b0c60e1604760d061053d2a3f1cda">tatami::DelayedBind&lt; margin_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#aa4ac0acd64fc490be115037e2192a409">tatami::DelayedCast&lt; Value_out_, Index_out_, Value_in_, Index_in_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a88e3074c6b7d05f49f6ae9a0ec660729">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#aa516aa869fbb00c8c71fd0742fdc8498">tatami::CompressedSparseMatrix&lt; row_, Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1SemiCompressedSparseMatrix.html#ae7ca8ec0934562765ac468936ac61dbe">tatami::SemiCompressedSparseMatrix&lt; row_, Value_, Index_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a8cb0f716fed6ad1683a098accf4153b7">tatami::DelayedSubsetBlock&lt; margin_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a95eaa479c3e83de0e1b53470253db651">tatami::DelayedSubsetSortedUnique&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#a1b4741f8cbb28b8430e5900f284023cc">tatami::HDF5CompressedSparseMatrix&lt; row_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1HDF5DenseMatrix.html#ac2e73739bd5f57a503ce41796b06e358">tatami::HDF5DenseMatrix&lt; Value_, Index_, transpose_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a520f715166298b1a82e65f9a19f98686">tatami::DelayedSubset&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a66efaad2aa759c175c7d1e2b9d9d9919">tatami::DelayedSubsetSorted&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, and <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#ab457721fe5480a252d4faf5f5fb6bf44">tatami::DelayedSubsetUnique&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>.</p>

</div>
</div>
<a id="a7d96127de1d22a5d976b9a2f46ae0ab4" name="a7d96127de1d22a5d976b9a2f46ae0ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d96127de1d22a5d976b9a2f46ae0ab4">&#9670;&#160;</a></span>dense_row() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; <a class="el" href="namespacetatami.html#ae75de1fc78b7d361ea8b59a5379ea4da">BlockDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense_row </td>
          <td>(</td>
          <td class="paramtype">Index_&#160;</td>
          <td class="paramname"><em>block_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_&#160;</td>
          <td class="paramname"><em>block_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_start</td><td>Index of the column at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of columns in the block. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for iteration and extraction.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>BlockDenseExtractor</code> object for dense access to a block of each row. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> from which it was created. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1DenseMatrix.html#ae94aa68c8f754dbd45bad996a4d4af9d">tatami::DenseMatrix&lt; row_, Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a8b779278a203b0a140efa56632de9b9f">tatami::DelayedIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a9606ec7e5d1bfd116242aa8e8db5776f">tatami::DelayedBind&lt; margin_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a5e8cedd000e22ff767c5acc9fb49c704">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a4b6c0fd7cef115174287f339922d0796">tatami::CompressedSparseMatrix&lt; row_, Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1SemiCompressedSparseMatrix.html#ae2164a57ed55013cff3e21fba1b28af4">tatami::SemiCompressedSparseMatrix&lt; row_, Value_, Index_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a0c0e2302475402e3240e07529a802c58">tatami::DelayedSubsetBlock&lt; margin_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#afb987ea0309670ed53272bccfa99affd">tatami::DelayedSubsetSortedUnique&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#abf8dbfab5d6aa4b2512d016ce00df63a">tatami::HDF5CompressedSparseMatrix&lt; row_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1HDF5DenseMatrix.html#a89ba1118a16443a99e4fbd6bb4b5d2c2">tatami::HDF5DenseMatrix&lt; Value_, Index_, transpose_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a37c70a9729008bf4c0295732edbee9ca">tatami::DelayedSubset&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a0f5aae7a06ea022edba764e349be4ef1">tatami::DelayedSubsetSorted&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a7b3d5379597fabc1bc2cb2be70ee5859">tatami::DelayedSubsetUnique&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#a0afdc535aa0540ce1e0fce2beda40d1c">tatami::DelayedCast&lt; Value_out_, Index_out_, Value_in_, Index_in_ &gt;</a>.</p>

</div>
</div>
<a id="aba9cc13a9df94e59d03772bde6ef565a" name="aba9cc13a9df94e59d03772bde6ef565a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba9cc13a9df94e59d03772bde6ef565a">&#9670;&#160;</a></span>dense_row() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; <a class="el" href="namespacetatami.html#a47ce406c32c3914c2ecce187e21b6ced">IndexDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense_row </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Index_ &gt;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Vector of sorted and unique column indices. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for iteration and extraction.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>IndexDenseExtractor</code> object for dense access to a indexed subset of each row. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> from which it was created. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1DenseMatrix.html#ae9fe012376d25e7357d4590f200606fd">tatami::DenseMatrix&lt; row_, Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a44bd6c40872239af5aa4dc671d0ffd3a">tatami::DelayedIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#aed6d8ffb63bb0b52c8535b458508214b">tatami::DelayedBind&lt; margin_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#aac3f9816a6694fda0a957c77ba4f7539">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#ae350260bfe054c54eaf10e500bfb5f39">tatami::CompressedSparseMatrix&lt; row_, Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1SemiCompressedSparseMatrix.html#a2f7652e1874cbeda36b47de5c09c4847">tatami::SemiCompressedSparseMatrix&lt; row_, Value_, Index_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a03fa3bbc8570e89733b725ed9296c215">tatami::DelayedSubsetBlock&lt; margin_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a24c590cca14c2046c10f701ed0f402c0">tatami::DelayedSubsetSortedUnique&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#ac867e324b80d8b9005f07a57c6d89e7b">tatami::HDF5CompressedSparseMatrix&lt; row_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1HDF5DenseMatrix.html#a6d27346d29071029ebef4b4ba4166984">tatami::HDF5DenseMatrix&lt; Value_, Index_, transpose_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#ad3d06f77fd7401cec1a497257655c280">tatami::DelayedSubset&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a82f95e2c19acbaa7d7d5ce3045ec8ede">tatami::DelayedSubsetSorted&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a2f3685a1092d6497bbdac10ab5578e05">tatami::DelayedSubsetUnique&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#a87aa25e476372f2b45080c050031e8d5">tatami::DelayedCast&lt; Value_out_, Index_out_, Value_in_, Index_in_ &gt;</a>.</p>

</div>
</div>
<a id="a9f6c3453a5c0c28a764f300f45bf860f" name="a9f6c3453a5c0c28a764f300f45bf860f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6c3453a5c0c28a764f300f45bf860f">&#9670;&#160;</a></span>dense_column() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; <a class="el" href="namespacetatami.html#a6008dbced6de41e5619156b5335f5762">FullDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense_column </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for iteration and extraction.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>FullDenseExtractor</code> object for dense access to full columns. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> from which it was created. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1DenseMatrix.html#a8ace942278f3ba1638401d5fd864d28a">tatami::DenseMatrix&lt; row_, Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a3dbcfc5b81fa0ad58ced2727bca2333e">tatami::DelayedIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#afa05d17a2ef5d844d4a79c13e42ed11c">tatami::DelayedBind&lt; margin_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#a792d159e920c23cd07faf20a22cb6a26">tatami::DelayedCast&lt; Value_out_, Index_out_, Value_in_, Index_in_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#aca3af5f469b31c8cdfd17110f46c1d68">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#ac6ac5a086f25e46725f5fb0c574b9437">tatami::CompressedSparseMatrix&lt; row_, Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1SemiCompressedSparseMatrix.html#a58fe6fd533b511ff1764a0c4969b90e8">tatami::SemiCompressedSparseMatrix&lt; row_, Value_, Index_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a489ddc00702fe3699f818a13d9707c59">tatami::DelayedSubsetBlock&lt; margin_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#af511de57e55eb7050552c6e92f4111ff">tatami::DelayedSubsetSortedUnique&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#a476e0ad1605e3b1da2c9b1a803c83295">tatami::HDF5CompressedSparseMatrix&lt; row_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1HDF5DenseMatrix.html#a2a103a0031f9f90b3642d9b805468eb1">tatami::HDF5DenseMatrix&lt; Value_, Index_, transpose_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#aad418776eb05e3fe3c2f311cbcee2d5d">tatami::DelayedSubset&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#af61b1f12840591ac26292d79905bcd48">tatami::DelayedSubsetSorted&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, and <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a0ae48533d1627324e08ca464aaff25d7">tatami::DelayedSubsetUnique&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>.</p>

</div>
</div>
<a id="a3ddceca01de5d1985aafa6e8bfdcf604" name="a3ddceca01de5d1985aafa6e8bfdcf604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ddceca01de5d1985aafa6e8bfdcf604">&#9670;&#160;</a></span>dense_column() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; <a class="el" href="namespacetatami.html#ae75de1fc78b7d361ea8b59a5379ea4da">BlockDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense_column </td>
          <td>(</td>
          <td class="paramtype">Index_&#160;</td>
          <td class="paramname"><em>block_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_&#160;</td>
          <td class="paramname"><em>block_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_start</td><td>Index of the row at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of rows in the block. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for iteration and extraction.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>BlockDenseExtractor</code> object for dense access to a block of each column. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> from which it was created. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1DenseMatrix.html#a08ca9bd8c2cd11fc553110486e7f7f22">tatami::DenseMatrix&lt; row_, Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a6f8d7842bbba944f589bd709708e4e29">tatami::DelayedIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a98d3d0040a8bd1442c7c48165dbc214c">tatami::DelayedBind&lt; margin_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a78584737c5b404e06898550a8234b86a">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a0a4fcb350adb08def60565714524c43d">tatami::CompressedSparseMatrix&lt; row_, Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1SemiCompressedSparseMatrix.html#ae51cb25e91b0f54d780db17f04422c06">tatami::SemiCompressedSparseMatrix&lt; row_, Value_, Index_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a42d9195918c209e70759d5b8cb2444f9">tatami::DelayedSubsetBlock&lt; margin_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a69a4131fd196926170018947359e38ba">tatami::DelayedSubsetSortedUnique&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#a3b8bd0a4ee298c95b08dd53eb3526154">tatami::HDF5CompressedSparseMatrix&lt; row_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1HDF5DenseMatrix.html#a7d217b9062edd4f0fd1762b490c560a0">tatami::HDF5DenseMatrix&lt; Value_, Index_, transpose_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a2bb1557b57f3048e9ad3046d637e3675">tatami::DelayedSubset&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#ac296502d83bd8d623bac89f8afc708d9">tatami::DelayedSubsetSorted&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a976cc7b3e6808575f4b0eb3c3125a9f6">tatami::DelayedSubsetUnique&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#a2791fdc5d90beacdf0b03e434896c307">tatami::DelayedCast&lt; Value_out_, Index_out_, Value_in_, Index_in_ &gt;</a>.</p>

</div>
</div>
<a id="a28ddabd4babf3d162f0901578c520a9a" name="a28ddabd4babf3d162f0901578c520a9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28ddabd4babf3d162f0901578c520a9a">&#9670;&#160;</a></span>dense_column() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; <a class="el" href="namespacetatami.html#a47ce406c32c3914c2ecce187e21b6ced">IndexDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense_column </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Index_ &gt;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Vector of sorted and unique column indices. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for iteration and extraction.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>IndexDenseExtractor</code> object for dense access to a indexed subset of each column. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> from which it was created. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1DenseMatrix.html#a94146a6703b5315b87257acc5115b153">tatami::DenseMatrix&lt; row_, Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#af7fe4fcb465e2f10ff48ad4fbe0259dd">tatami::DelayedIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#af45d99f9425031c3cd3ab9a1e1e7adeb">tatami::DelayedBind&lt; margin_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a6cddd31a66c2e566a1969fc1146099bb">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a30815fb2c7a4940e2f72e18e2ebf5dbf">tatami::CompressedSparseMatrix&lt; row_, Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1SemiCompressedSparseMatrix.html#aadf33c3b1c3198f272e994cdefbcf60b">tatami::SemiCompressedSparseMatrix&lt; row_, Value_, Index_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#aedc41486ad938840ec159620b5bc120a">tatami::DelayedSubsetBlock&lt; margin_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#ab1d00c4b33bc6a8b70cf7b62744d69cf">tatami::DelayedSubsetSortedUnique&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#a277e14dcc1b478f8e27ffbaa35465b33">tatami::HDF5CompressedSparseMatrix&lt; row_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1HDF5DenseMatrix.html#ae2b1d27ff3718d1127195e1a262e4a9d">tatami::HDF5DenseMatrix&lt; Value_, Index_, transpose_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a72022dbd75040ebe21ffdf5483d3d932">tatami::DelayedSubset&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a0d189857678a091bf263269e150217e0">tatami::DelayedSubsetSorted&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a0e1ee2c7754ccceb01ff02cce4340b6a">tatami::DelayedSubsetUnique&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#a482e7b7aadd3610e060e44c93dafc047">tatami::DelayedCast&lt; Value_out_, Index_out_, Value_in_, Index_in_ &gt;</a>.</p>

</div>
</div>
<a id="adee56bee86c500a4f4a3940e8ef18459" name="adee56bee86c500a4f4a3940e8ef18459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adee56bee86c500a4f4a3940e8ef18459">&#9670;&#160;</a></span>sparse_row() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; <a class="el" href="namespacetatami.html#a0fbb0624c8e1913a87e8fb5c975400e1">FullSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse_row </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for iteration and extraction.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>FullSparseExtractor</code> object for sparse access to full rows. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> from which it was created. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#a6d39bc3ff038786f058d6180f1369252">tatami::VirtualDenseMatrix&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#a6d39bc3ff038786f058d6180f1369252">tatami::VirtualDenseMatrix&lt; Value_, int &gt;</a>, <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#a6d39bc3ff038786f058d6180f1369252">tatami::VirtualDenseMatrix&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a4209b8829ec4f96b42112dad6cf4e5ed">tatami::DelayedIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a09843333a18e5e1917c96d6399078ce8">tatami::DelayedBind&lt; margin_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#a5fbaeb7a93a078983add7ff26c611e40">tatami::DelayedCast&lt; Value_out_, Index_out_, Value_in_, Index_in_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#aa8f0b02f3dc8f7c6207f8a90f703f81b">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a3573e9c46b77c06e88aa8142f611654c">tatami::CompressedSparseMatrix&lt; row_, Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1SemiCompressedSparseMatrix.html#a5fb0d0da1c3b59fb9794d94e85938b9f">tatami::SemiCompressedSparseMatrix&lt; row_, Value_, Index_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a7b4bccf8b6e5d5473934499a1be8c4ba">tatami::DelayedSubsetBlock&lt; margin_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a6964e114bbe219fdd321ca86b51b04c5">tatami::DelayedSubsetSortedUnique&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#a63c7dea6539c86b6ae6f3381c1efe51f">tatami::HDF5CompressedSparseMatrix&lt; row_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a9604ab0813ca3a9827f7fdcb8276e9cb">tatami::DelayedSubset&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a8f36a618c9495e2899a5dff11bd6c75b">tatami::DelayedSubsetSorted&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, and <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a3a2f7dc0c2816054c2ca48aca530be0a">tatami::DelayedSubsetUnique&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>.</p>

</div>
</div>
<a id="a82e592bf93aa216045a93efb923107e6" name="a82e592bf93aa216045a93efb923107e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82e592bf93aa216045a93efb923107e6">&#9670;&#160;</a></span>sparse_row() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; <a class="el" href="namespacetatami.html#ac8d0024399a66ce61f6315f5f46ebb63">BlockSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse_row </td>
          <td>(</td>
          <td class="paramtype">Index_&#160;</td>
          <td class="paramname"><em>block_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_&#160;</td>
          <td class="paramname"><em>block_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_start</td><td>Index of the column at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of columns in the block. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for iteration and extraction.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>BlockSparseExtractor</code> object for sparse access to a block of each row. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> from which it was created. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#a956946c98a7d06e917c78b5dcdc836ab">tatami::VirtualDenseMatrix&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#a956946c98a7d06e917c78b5dcdc836ab">tatami::VirtualDenseMatrix&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a8ea01736785d73ba2c1454c90eeef0ea">tatami::DelayedIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#aca855b3323d167a3087e2426c97c990f">tatami::DelayedBind&lt; margin_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a94b76d50f8046fd5f3abc99f1dd84fef">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#aa82a4748a02e119301ce52baacc31c73">tatami::CompressedSparseMatrix&lt; row_, Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1SemiCompressedSparseMatrix.html#a60c6510f93cf1345a74d2eb04796de33">tatami::SemiCompressedSparseMatrix&lt; row_, Value_, Index_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#ad99125d6c095e615f104f86d4e93633a">tatami::DelayedSubsetBlock&lt; margin_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#ad52e3e667f4824187dfd85287060cbdc">tatami::DelayedSubsetSortedUnique&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#a1dc1eca808d04444e3f6f9cac2c07fdf">tatami::HDF5CompressedSparseMatrix&lt; row_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a2f37a9cf5db5736d85281274d5888998">tatami::DelayedSubset&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#af314f2bb2c3d535e271f412d8c76f066">tatami::DelayedSubsetSorted&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a680baef1a688e43eaf04e86f6c4d57b3">tatami::DelayedSubsetUnique&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#a1c77a0b18385f569df2fc7808e84fc92">tatami::DelayedCast&lt; Value_out_, Index_out_, Value_in_, Index_in_ &gt;</a>.</p>

</div>
</div>
<a id="aa452ec9e476c69cdd9c7079a4d382af9" name="aa452ec9e476c69cdd9c7079a4d382af9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa452ec9e476c69cdd9c7079a4d382af9">&#9670;&#160;</a></span>sparse_row() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; <a class="el" href="namespacetatami.html#a4b67b4d1b6c00cd0bd449703432a5f7b">IndexSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse_row </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Index_ &gt;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Vector of sorted and unique column indices. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for iteration and extraction.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>IndexSparseExtractor</code> object for sparse access to a indexed subset of each row. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> from which it was created. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#a4c9eb67e9aaf1bd533b7ad3b9074ce6f">tatami::VirtualDenseMatrix&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#a4c9eb67e9aaf1bd533b7ad3b9074ce6f">tatami::VirtualDenseMatrix&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a7393aa9abb194e585e11bb054f5028c3">tatami::DelayedIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a905ee4de8c18087c1af4988b7d11fd05">tatami::DelayedBind&lt; margin_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#af9bdca9700d767e78128e3dcbad9e9ff">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#afe3e44e7ab9df3b45f0724951a662d17">tatami::CompressedSparseMatrix&lt; row_, Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1SemiCompressedSparseMatrix.html#a79c1bb50d009f097453942f9eb8ce1d7">tatami::SemiCompressedSparseMatrix&lt; row_, Value_, Index_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a495c8cb29e2a3fc049fe4468c0fbe8e4">tatami::DelayedSubsetBlock&lt; margin_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a41812757a117fd56cccd2268729b56c1">tatami::DelayedSubsetSortedUnique&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#a67b8a23b6b5d3abfbae67b5265a1f61d">tatami::HDF5CompressedSparseMatrix&lt; row_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#adfa2f65489d5c90786416c3c714cf821">tatami::DelayedSubset&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#ac6497dc8677ec669a2bce95c166b02ef">tatami::DelayedSubsetSorted&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a190cd0ada220fa3664c2bfdcf8e9ea0a">tatami::DelayedSubsetUnique&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#a476e3097dba559b475145350183593fa">tatami::DelayedCast&lt; Value_out_, Index_out_, Value_in_, Index_in_ &gt;</a>.</p>

</div>
</div>
<a id="a6fcbdc787f4b4980f57c228dc89f6289" name="a6fcbdc787f4b4980f57c228dc89f6289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fcbdc787f4b4980f57c228dc89f6289">&#9670;&#160;</a></span>sparse_column() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; <a class="el" href="namespacetatami.html#a0fbb0624c8e1913a87e8fb5c975400e1">FullSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse_column </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for iteration and extraction.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>FullSparseExtractor</code> object for sparse access to full columns. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> from which it was created. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#a3b44e951cc4c966f7f561fddbec0cb35">tatami::VirtualDenseMatrix&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#a3b44e951cc4c966f7f561fddbec0cb35">tatami::VirtualDenseMatrix&lt; Value_, int &gt;</a>, <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#a3b44e951cc4c966f7f561fddbec0cb35">tatami::VirtualDenseMatrix&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a1c766dbead032275d3b98e04a5999e34">tatami::DelayedIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a23015c47f274dd2d83f2e3b8ea90821c">tatami::DelayedBind&lt; margin_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#a52b9a5d62e3ce0b7618d763b82ba0416">tatami::DelayedCast&lt; Value_out_, Index_out_, Value_in_, Index_in_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#ac9ee6ab5a2900718bfc929520324d7b3">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#ae56e0afe6873b2186a0945b9312519dc">tatami::CompressedSparseMatrix&lt; row_, Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1SemiCompressedSparseMatrix.html#ae6876383fce85a907a4324595f8b0370">tatami::SemiCompressedSparseMatrix&lt; row_, Value_, Index_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#ac1f92e628289749083b8459f05cbd84d">tatami::DelayedSubsetBlock&lt; margin_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#aa78dc1f08ae74964ecfdc6dbf3d1f4b8">tatami::DelayedSubsetSortedUnique&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#afdc76b5e34a647a29d7c6a6c017ff9cf">tatami::HDF5CompressedSparseMatrix&lt; row_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a82f97c7cd46e9e4a3ce9f20114553a81">tatami::DelayedSubset&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a37f83309c4d561f45702596224778486">tatami::DelayedSubsetSorted&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, and <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a77d74e2c87b0ca638c5810cf8778369b">tatami::DelayedSubsetUnique&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>.</p>

</div>
</div>
<a id="a369b6b56d1f290d0b298ef840119468a" name="a369b6b56d1f290d0b298ef840119468a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a369b6b56d1f290d0b298ef840119468a">&#9670;&#160;</a></span>sparse_column() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; <a class="el" href="namespacetatami.html#ac8d0024399a66ce61f6315f5f46ebb63">BlockSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse_column </td>
          <td>(</td>
          <td class="paramtype">Index_&#160;</td>
          <td class="paramname"><em>block_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_&#160;</td>
          <td class="paramname"><em>block_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_start</td><td>Index of the row at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of rows in the block. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for iteration and extraction.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>BlockSparseExtractor</code> object for sparse access to a block of each column. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> from which it was created. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#a8de5cef8cbf819e538f2289f5f52e6c4">tatami::VirtualDenseMatrix&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#a8de5cef8cbf819e538f2289f5f52e6c4">tatami::VirtualDenseMatrix&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a34dc46729c63efd7c9ccdad3bf30c736">tatami::DelayedIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a3cf86883e75357e64d89adbc48a70563">tatami::DelayedBind&lt; margin_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#ace4ddb430ed329ab3ddf12c45c6f18a2">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#ade534aca393bd02fe77ed58cc93454ad">tatami::CompressedSparseMatrix&lt; row_, Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1SemiCompressedSparseMatrix.html#ada2224d2142ca6b0837741c0cf2fa9be">tatami::SemiCompressedSparseMatrix&lt; row_, Value_, Index_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#ad5be144b2bddc041681ce3b340844708">tatami::DelayedSubsetBlock&lt; margin_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a256fe6dc55e2b7317292f5ccac395a0e">tatami::DelayedSubsetSortedUnique&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#a568313c89ec39d75a48fe84cae6769d8">tatami::HDF5CompressedSparseMatrix&lt; row_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#acf5f157d2a355448c02dba67e6bb17bb">tatami::DelayedSubset&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a195bdde3ffd966b3a421a3ee263d4b1b">tatami::DelayedSubsetSorted&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a8823ff62bcb495f742a1943637196247">tatami::DelayedSubsetUnique&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#a7ab6420842e1686361b23823a751fee8">tatami::DelayedCast&lt; Value_out_, Index_out_, Value_in_, Index_in_ &gt;</a>.</p>

</div>
</div>
<a id="a120c3a294a1ffd715c86b136902b8c51" name="a120c3a294a1ffd715c86b136902b8c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a120c3a294a1ffd715c86b136902b8c51">&#9670;&#160;</a></span>sparse_column() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; <a class="el" href="namespacetatami.html#a4b67b4d1b6c00cd0bd449703432a5f7b">IndexSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse_column </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Index_ &gt;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Vector of sorted and unique column indices. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for iteration and extraction.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>IndexSparseExtractor</code> object for sparse access to a indexed subset of each column. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> from which it was created. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#a4c16857ea52bde64900581af4db2da97">tatami::VirtualDenseMatrix&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1VirtualDenseMatrix.html#a4c16857ea52bde64900581af4db2da97">tatami::VirtualDenseMatrix&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a989b7d164611a71a3182baf4f1fb7525">tatami::DelayedIsometricOp&lt; Value_, Index_, Operation_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a1431ba4def7af7275f0a2fc2ae14ed01">tatami::DelayedBind&lt; margin_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#aaa45e99399c24068984dc2159d1be726">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#aa300f54d8f02e1fab49d6700c9564480">tatami::CompressedSparseMatrix&lt; row_, Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1SemiCompressedSparseMatrix.html#a25a6d306f43ef68e2b7945be91330f1f">tatami::SemiCompressedSparseMatrix&lt; row_, Value_, Index_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a2bc07cc9c9319a8a4f4eaf16caf74bf3">tatami::DelayedSubsetBlock&lt; margin_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a398c9a5518f32c1ecf3db3629e3c5a76">tatami::DelayedSubsetSortedUnique&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html#a2245957e270a8b961de7adb00b8009ff">tatami::HDF5CompressedSparseMatrix&lt; row_, Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a0bb000a1ebd708a148785f8a904cc9f0">tatami::DelayedSubset&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a3a6143b184db99fc1ab30422fdaec5f9">tatami::DelayedSubsetSorted&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a4eb8f770e84ca2cb67bedb287a0d27ad">tatami::DelayedSubsetUnique&lt; margin_, Value_, Index_, IndexStorage_ &gt;</a>, and <a class="el" href="classtatami_1_1DelayedCast.html#afad930739c2f81aa6e563201907c0b1b">tatami::DelayedCast&lt; Value_out_, Index_out_, Value_in_, Index_in_ &gt;</a>.</p>

</div>
</div>
<a id="a3913e6cfd25586f37c0833a21c8f0ca6" name="a3913e6cfd25586f37c0833a21c8f0ca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3913e6cfd25586f37c0833a21c8f0ca6">&#9670;&#160;</a></span>dense_row() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="namespacetatami.html#a6008dbced6de41e5619156b5335f5762">FullDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense_row </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A <code>FullDenseExtractor</code> object for dense access to full rows, using default options. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a6456594fe017e5f61a2adce0ce152ee4" name="a6456594fe017e5f61a2adce0ce152ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6456594fe017e5f61a2adce0ce152ee4">&#9670;&#160;</a></span>dense_row() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="namespacetatami.html#ae75de1fc78b7d361ea8b59a5379ea4da">BlockDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense_row </td>
          <td>(</td>
          <td class="paramtype">Index_&#160;</td>
          <td class="paramname"><em>block_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_&#160;</td>
          <td class="paramname"><em>block_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_start</td><td>Index of the column at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of columns in the block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>BlockDenseExtractor</code> object for dense access to a block of each row, using default options. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="aa2b4e61e29787566fcd78209d4930c2e" name="aa2b4e61e29787566fcd78209d4930c2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2b4e61e29787566fcd78209d4930c2e">&#9670;&#160;</a></span>dense_row() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="namespacetatami.html#a47ce406c32c3914c2ecce187e21b6ced">IndexDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense_row </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Index_ &gt;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Vector of sorted and unique column indices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>IndexDenseExtractor</code> object for dense access to a indexed subset of each row, using default options. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a94a543328188b8212c9267f9c5edc431" name="a94a543328188b8212c9267f9c5edc431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94a543328188b8212c9267f9c5edc431">&#9670;&#160;</a></span>dense_column() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="namespacetatami.html#a6008dbced6de41e5619156b5335f5762">FullDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense_column </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A <code>FullDenseExtractor</code> object for dense access to full columns, using default options. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a39764e844f1da2b4027b61eb92b28674" name="a39764e844f1da2b4027b61eb92b28674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39764e844f1da2b4027b61eb92b28674">&#9670;&#160;</a></span>dense_column() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="namespacetatami.html#ae75de1fc78b7d361ea8b59a5379ea4da">BlockDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense_column </td>
          <td>(</td>
          <td class="paramtype">Index_&#160;</td>
          <td class="paramname"><em>block_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_&#160;</td>
          <td class="paramname"><em>block_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_start</td><td>Index of the row at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of rows in the block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>BlockDenseExtractor</code> object for dense access to a block of each column, using default options. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a35af5355144252c421d3f4ee6c2aa51b" name="a35af5355144252c421d3f4ee6c2aa51b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35af5355144252c421d3f4ee6c2aa51b">&#9670;&#160;</a></span>dense_column() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="namespacetatami.html#a47ce406c32c3914c2ecce187e21b6ced">IndexDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense_column </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Index_ &gt;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Vector of sorted and unique column indices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>IndexDenseExtractor</code> object for dense access to a indexed subset of each column, using default options. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a7274f8de1b6918f45291e10c054252a1" name="a7274f8de1b6918f45291e10c054252a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7274f8de1b6918f45291e10c054252a1">&#9670;&#160;</a></span>sparse_row() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="namespacetatami.html#a0fbb0624c8e1913a87e8fb5c975400e1">FullSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse_row </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A <code>FullSparseExtractor</code> object for sparse access to full rows, using default options. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="ae49828cfac71e469c569bd74a4ed006e" name="ae49828cfac71e469c569bd74a4ed006e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae49828cfac71e469c569bd74a4ed006e">&#9670;&#160;</a></span>sparse_row() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="namespacetatami.html#ac8d0024399a66ce61f6315f5f46ebb63">BlockSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse_row </td>
          <td>(</td>
          <td class="paramtype">Index_&#160;</td>
          <td class="paramname"><em>block_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_&#160;</td>
          <td class="paramname"><em>block_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_start</td><td>Index of the column at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of columns in the block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>BlockSparseExtractor</code> object for sparse access to a block of each row, using default options. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a26f66f9ce349aabc63227aa4f1cad6ab" name="a26f66f9ce349aabc63227aa4f1cad6ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f66f9ce349aabc63227aa4f1cad6ab">&#9670;&#160;</a></span>sparse_row() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="namespacetatami.html#a4b67b4d1b6c00cd0bd449703432a5f7b">IndexSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse_row </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Index_ &gt;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Vector of sorted and unique column indices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>IndexSparseExtractor</code> object for sparse access to a indexed subset of each row, using default options. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a8bfc42ee94b0068d1542c579718b52b4" name="a8bfc42ee94b0068d1542c579718b52b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bfc42ee94b0068d1542c579718b52b4">&#9670;&#160;</a></span>sparse_column() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="namespacetatami.html#a0fbb0624c8e1913a87e8fb5c975400e1">FullSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse_column </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A <code>FullSparseExtractor</code> object for sparse access to full columns, using default options. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a390f34d93c2b8d9dd561c6807aa8eac5" name="a390f34d93c2b8d9dd561c6807aa8eac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a390f34d93c2b8d9dd561c6807aa8eac5">&#9670;&#160;</a></span>sparse_column() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="namespacetatami.html#ac8d0024399a66ce61f6315f5f46ebb63">BlockSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse_column </td>
          <td>(</td>
          <td class="paramtype">Index_&#160;</td>
          <td class="paramname"><em>block_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_&#160;</td>
          <td class="paramname"><em>block_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_start</td><td>Index of the row at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of rows in the block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>BlockSparseExtractor</code> object for sparse access to a block of each column, using default options. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a80f0867067f1b1e5a235a99ecf58924b" name="a80f0867067f1b1e5a235a99ecf58924b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80f0867067f1b1e5a235a99ecf58924b">&#9670;&#160;</a></span>sparse_column() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="namespacetatami.html#a4b67b4d1b6c00cd0bd449703432a5f7b">IndexSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse_column </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Index_ &gt;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Vector of sorted and unique column indices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>IndexSparseExtractor</code> object for sparse access to a indexed subset of each column, using default options. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>tatami/base/<a class="el" href="Matrix_8hpp_source.html">Matrix.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
