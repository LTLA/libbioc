<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tatami: tatami Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tatami
   </div>
   <div id="projectbrief">C++ API for different matrix representations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">tatami Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Flexible representations for matrix data.  
<a href="namespacetatami.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacetatami_1_1MatrixMarket"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami_1_1MatrixMarket.html">MatrixMarket</a></td></tr>
<tr class="memdesc:namespacetatami_1_1MatrixMarket"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classes and utilites to handle <a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a> Market files. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1ArrayView.html">ArrayView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">View into a pre-allocated array.  <a href="classtatami_1_1ArrayView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1CompressedSparseMatrix.html">CompressedSparseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compressed sparse matrix representation.  <a href="classtatami_1_1CompressedSparseMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedAbsHelper.html">DelayedAbsHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the absolute value of a matrix entry.  <a href="structtatami_1_1DelayedAbsHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedAddScalarHelper.html">DelayedAddScalarHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a scalar to all values of a matrix.  <a href="structtatami_1_1DelayedAddScalarHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedAddVectorHelper.html">DelayedAddVectorHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a vector along the rows or columns of a matrix.  <a href="structtatami_1_1DelayedAddVectorHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedBind.html">DelayedBind</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed combining of a matrix.  <a href="classtatami_1_1DelayedBind.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedCast.html">DelayedCast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recast a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> to a different interface type.  <a href="classtatami_1_1DelayedCast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedDivideScalarHelper.html">DelayedDivideScalarHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide a scalar from all values of a matrix, or vice versa.  <a href="structtatami_1_1DelayedDivideScalarHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedDivideVectorHelper.html">DelayedDivideVectorHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide the rows/columns of a matrix by a vector, or vice versa.  <a href="structtatami_1_1DelayedDivideVectorHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedExpHelper.html">DelayedExpHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a matrix entry as an exponent.  <a href="structtatami_1_1DelayedExpHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedIsometricOp.html">DelayedIsometricOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed isometric operations on a matrix.  <a href="classtatami_1_1DelayedIsometricOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedLog1pHelper.html">DelayedLog1pHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the logarithm of a matrix entry plus 1.  <a href="structtatami_1_1DelayedLog1pHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedLogHelper.html">DelayedLogHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the logarithm of a matrix entry.  <a href="structtatami_1_1DelayedLogHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedMultiplyScalarHelper.html">DelayedMultiplyScalarHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a scalar with all values of a matrix.  <a href="structtatami_1_1DelayedMultiplyScalarHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedMultiplyVectorHelper.html">DelayedMultiplyVectorHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a vector along the rows or columns of a matrix.  <a href="structtatami_1_1DelayedMultiplyVectorHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedRoundHelper.html">DelayedRoundHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round a matrix entry to the nearest integer.  <a href="structtatami_1_1DelayedRoundHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedSqrtHelper.html">DelayedSqrtHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the square root of a matrix entry.  <a href="structtatami_1_1DelayedSqrtHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedSubset.html">DelayedSubset</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed subsetting of a matrix.  <a href="classtatami_1_1DelayedSubset.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedSubsetBlock.html">DelayedSubsetBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed subsetting to a contiguous block.  <a href="classtatami_1_1DelayedSubsetBlock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedSubtractScalarHelper.html">DelayedSubtractScalarHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract a scalar from all values of a matrix, or vice versa.  <a href="structtatami_1_1DelayedSubtractScalarHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedSubtractVectorHelper.html">DelayedSubtractVectorHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract a vector from the rows/columns of a matrix, or vice versa.  <a href="structtatami_1_1DelayedSubtractVectorHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedTranspose.html">DelayedTranspose</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed transposition of a matrix.  <a href="classtatami_1_1DelayedTranspose.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DenseMatrix.html">DenseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dense matrix representation.  <a href="classtatami_1_1DenseMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html">HDF5CompressedSparseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compressed sparse matrix in a HDF5 file.  <a href="classtatami_1_1HDF5CompressedSparseMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1HDF5DenseMatrix.html">HDF5DenseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dense matrix backed by a DataSet in a HDF5 file.  <a href="classtatami_1_1HDF5DenseMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1LayeredMatrixData.html">LayeredMatrixData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer and permutations for a layered sparse matrix.  <a href="structtatami_1_1LayeredMatrixData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html">Matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual class for a matrix with a defined type.  <a href="classtatami_1_1Matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1SomeNumericArray.html">SomeNumericArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of some numeric type, determined at runtime.  <a href="structtatami_1_1SomeNumericArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A range of a sparse vector.  <a href="structtatami_1_1SparseRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1SparseRangeCopy.html">SparseRangeCopy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A range of a sparse vector with copying.  <a href="structtatami_1_1SparseRangeCopy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Workspace.html">Workspace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual workspace class.  <a href="classtatami_1_1Workspace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1WriteSparseMatrixToHdf5Parameters.html">WriteSparseMatrixToHdf5Parameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for <code><a class="el" href="namespacetatami.html#ad9cce803e8db12c73f1678ff3c022a19">write_sparse_matrix_to_hdf5()</a></code>.  <a href="structtatami_1_1WriteSparseMatrixToHdf5Parameters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a3d1338ade036e38b6d363a6c8a704a2b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename IDX , class U  = std::vector&lt;T&gt;, class V  = std::vector&lt;IDX&gt;, class W  = std::vector&lt;size_t&gt;&gt; </td></tr>
<tr class="memitem:a3d1338ade036e38b6d363a6c8a704a2b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a3d1338ade036e38b6d363a6c8a704a2b">CompressedSparseColumnMatrix</a> = <a class="el" href="classtatami_1_1CompressedSparseMatrix.html">CompressedSparseMatrix</a>&lt; false, T, IDX, U, V, W &gt;</td></tr>
<tr class="separator:a3d1338ade036e38b6d363a6c8a704a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a0b775b994304c942e990fe12e793e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename IDX , class U  = std::vector&lt;T&gt;, class V  = std::vector&lt;IDX&gt;, class W  = std::vector&lt;size_t&gt;&gt; </td></tr>
<tr class="memitem:a33a0b775b994304c942e990fe12e793e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a33a0b775b994304c942e990fe12e793e">CompressedSparseRowMatrix</a> = <a class="el" href="classtatami_1_1CompressedSparseMatrix.html">CompressedSparseMatrix</a>&lt; true, T, IDX, U, V, W &gt;</td></tr>
<tr class="separator:a33a0b775b994304c942e990fe12e793e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c118308300d626e53436a9540dd8bd9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename IDX  = int, class V  = std::vector&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a1c118308300d626e53436a9540dd8bd9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a1c118308300d626e53436a9540dd8bd9">DenseColumnMatrix</a> = <a class="el" href="classtatami_1_1DenseMatrix.html">DenseMatrix</a>&lt; false, T, IDX, V &gt;</td></tr>
<tr class="separator:a1c118308300d626e53436a9540dd8bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4db75262ca90f85a4278b90f844cffd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename IDX  = int, class V  = std::vector&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ad4db75262ca90f85a4278b90f844cffd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ad4db75262ca90f85a4278b90f844cffd">DenseRowMatrix</a> = <a class="el" href="classtatami_1_1DenseMatrix.html">DenseMatrix</a>&lt; true, T, IDX, V &gt;</td></tr>
<tr class="separator:ad4db75262ca90f85a4278b90f844cffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c670894994f1d620abb55953f98441"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a35c670894994f1d620abb55953f98441">NumericMatrix</a> = <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; double, int &gt;</td></tr>
<tr class="separator:a35c670894994f1d620abb55953f98441"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac4dba1039cc39910b0dd3bcccfea0f71"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ac4dba1039cc39910b0dd3bcccfea0f71">SparseCopyMode</a> { <b>SPARSE_COPY_INDEX</b>
, <b>SPARSE_COPY_VALUE</b>
, <b>SPARSE_COPY_BOTH</b>
 }</td></tr>
<tr class="separator:ac4dba1039cc39910b0dd3bcccfea0f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa82419090e54a4674d971429e93e6af5"><td class="memTemplParams" colspan="2">template&lt;int MARGIN, typename T  = double, class V  = std::vector&lt;T&gt;&gt; </td></tr>
<tr class="memitem:aa82419090e54a4674d971429e93e6af5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedAddVectorHelper.html">DelayedAddVectorHelper</a>&lt; MARGIN, T, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#aa82419090e54a4674d971429e93e6af5">make_DelayedAddVectorHelper</a> (V v)</td></tr>
<tr class="separator:aa82419090e54a4674d971429e93e6af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb68a8d27e821f213965edab7f029c48"><td class="memTemplParams" colspan="2">template&lt;bool RIGHT, int MARGIN, typename T  = double, class V  = std::vector&lt;T&gt;&gt; </td></tr>
<tr class="memitem:abb68a8d27e821f213965edab7f029c48"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedSubtractVectorHelper.html">DelayedSubtractVectorHelper</a>&lt; RIGHT, MARGIN, T, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#abb68a8d27e821f213965edab7f029c48">make_DelayedSubtractVectorHelper</a> (V v)</td></tr>
<tr class="separator:abb68a8d27e821f213965edab7f029c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a316f4cf0ae5a9e83c2dad6ccbbbcfb43"><td class="memTemplParams" colspan="2">template&lt;int MARGIN, typename T  = double, class V  = std::vector&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a316f4cf0ae5a9e83c2dad6ccbbbcfb43"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedMultiplyVectorHelper.html">DelayedMultiplyVectorHelper</a>&lt; MARGIN, T, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a316f4cf0ae5a9e83c2dad6ccbbbcfb43">make_DelayedMultiplyVectorHelper</a> (V v)</td></tr>
<tr class="separator:a316f4cf0ae5a9e83c2dad6ccbbbcfb43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab104e5029db4d09afe0b47a125f457bf"><td class="memTemplParams" colspan="2">template&lt;bool RIGHT, int MARGIN, typename T  = double, class V  = std::vector&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ab104e5029db4d09afe0b47a125f457bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedDivideVectorHelper.html">DelayedDivideVectorHelper</a>&lt; RIGHT, MARGIN, T, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ab104e5029db4d09afe0b47a125f457bf">make_DelayedDivideVectorHelper</a> (V v)</td></tr>
<tr class="separator:ab104e5029db4d09afe0b47a125f457bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac019a143af4fd0eb34f530527a424888"><td class="memTemplParams" colspan="2">template&lt;int MARGIN, class MAT &gt; </td></tr>
<tr class="memitem:ac019a143af4fd0eb34f530527a424888"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; MAT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ac019a143af4fd0eb34f530527a424888">make_DelayedBind</a> (std::vector&lt; std::shared_ptr&lt; MAT &gt; &gt; ps)</td></tr>
<tr class="separator:ac019a143af4fd0eb34f530527a424888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83170fbdceea0e9a7e0074f1b193c66b"><td class="memTemplParams" colspan="2">template&lt;typename T_out , typename IDX_out , typename T_in , typename IDX_in &gt; </td></tr>
<tr class="memitem:a83170fbdceea0e9a7e0074f1b193c66b"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T_out, IDX_out &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a83170fbdceea0e9a7e0074f1b193c66b">make_DelayedCast</a> (const std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T_in, IDX_in &gt; &gt; p)</td></tr>
<tr class="separator:a83170fbdceea0e9a7e0074f1b193c66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2cd6fd2c5bba7eb83582619ffc9cea"><td class="memTemplParams" colspan="2">template&lt;class MAT , class OP &gt; </td></tr>
<tr class="memitem:a0e2cd6fd2c5bba7eb83582619ffc9cea"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; MAT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a0e2cd6fd2c5bba7eb83582619ffc9cea">make_DelayedIsometricOp</a> (std::shared_ptr&lt; MAT &gt; p, OP op)</td></tr>
<tr class="separator:a0e2cd6fd2c5bba7eb83582619ffc9cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd395c7ec8bb251ab11206166a972bbc"><td class="memTemplParams" colspan="2">template&lt;int MARGIN, class MAT , class V &gt; </td></tr>
<tr class="memitem:acd395c7ec8bb251ab11206166a972bbc"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; MAT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#acd395c7ec8bb251ab11206166a972bbc">make_DelayedSubset</a> (std::shared_ptr&lt; MAT &gt; p, V idx)</td></tr>
<tr class="separator:acd395c7ec8bb251ab11206166a972bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef69731d317edc4ce24de03e67f8097"><td class="memTemplParams" colspan="2">template&lt;int MARGIN, class MAT &gt; </td></tr>
<tr class="memitem:a4ef69731d317edc4ce24de03e67f8097"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; MAT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a4ef69731d317edc4ce24de03e67f8097">make_DelayedSubsetBlock</a> (std::shared_ptr&lt; MAT &gt; p, size_t f, size_t l)</td></tr>
<tr class="separator:a4ef69731d317edc4ce24de03e67f8097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8888d53a1922d378a7abafa1a1146ff"><td class="memTemplParams" colspan="2">template&lt;class MAT &gt; </td></tr>
<tr class="memitem:ab8888d53a1922d378a7abafa1a1146ff"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; MAT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ab8888d53a1922d378a7abafa1a1146ff">make_DelayedTranspose</a> (std::shared_ptr&lt; MAT &gt; p)</td></tr>
<tr class="separator:ab8888d53a1922d378a7abafa1a1146ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e62b7595d4b0d1d06cb203952007b28"><td class="memTemplParams" colspan="2">template&lt;bool ROW, typename T , typename IDX  = int, class U  = std::vector&lt;T&gt;, class V  = std::vector&lt;IDX&gt;, class W  = std::vector&lt;size_t&gt;&gt; </td></tr>
<tr class="memitem:a8e62b7595d4b0d1d06cb203952007b28"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1CompressedSparseMatrix.html">CompressedSparseMatrix</a>&lt; ROW, T, IDX, U, V, W &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a8e62b7595d4b0d1d06cb203952007b28">load_hdf5_compressed_sparse_matrix</a> (size_t nr, size_t nc, const std::string &amp;file, const std::string &amp;vals, const std::string &amp;idx, const std::string &amp;ptr)</td></tr>
<tr class="separator:a8e62b7595d4b0d1d06cb203952007b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13e199dab7f4ab7c4d3045a032f8cac"><td class="memTemplParams" colspan="2">template&lt;typename T , typename IDX  = int, class V  = std::vector&lt;T&gt;, bool transpose = false&gt; </td></tr>
<tr class="memitem:ad13e199dab7f4ab7c4d3045a032f8cac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DenseMatrix.html">DenseMatrix</a>&lt;!transpose, T, IDX, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ad13e199dab7f4ab7c4d3045a032f8cac">load_hdf5_dense_matrix</a> (const std::string &amp;file, const std::string &amp;name)</td></tr>
<tr class="separator:ad13e199dab7f4ab7c4d3045a032f8cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9cce803e8db12c73f1678ff3c022a19"><td class="memTemplParams" colspan="2">template&lt;typename T , typename IDX &gt; </td></tr>
<tr class="memitem:ad9cce803e8db12c73f1678ff3c022a19"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ad9cce803e8db12c73f1678ff3c022a19">write_sparse_matrix_to_hdf5</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; *mat, H5::Group &amp;location, const <a class="el" href="structtatami_1_1WriteSparseMatrixToHdf5Parameters.html">WriteSparseMatrixToHdf5Parameters</a> &amp;params)</td></tr>
<tr class="separator:ad9cce803e8db12c73f1678ff3c022a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d4f99c974648a98b6d9cf99e4a8ec4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename IDX &gt; </td></tr>
<tr class="memitem:a39d4f99c974648a98b6d9cf99e4a8ec4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a39d4f99c974648a98b6d9cf99e4a8ec4">write_sparse_matrix_to_hdf5</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; *mat, H5::Group &amp;location)</td></tr>
<tr class="separator:a39d4f99c974648a98b6d9cf99e4a8ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0692b6c82646df0131b9872431a11bf2"><td class="memTemplParams" colspan="2">template&lt;int MARGIN, typename T , typename IDX , class Factory &gt; </td></tr>
<tr class="memitem:a0692b6c82646df0131b9872431a11bf2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a0692b6c82646df0131b9872431a11bf2">apply</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; *p, Factory &amp;factory, int threads=1)</td></tr>
<tr class="separator:a0692b6c82646df0131b9872431a11bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde903394a6c87915d3262d08b48fdea"><td class="memTemplParams" colspan="2">template&lt;typename Output  = double, typename T , typename IDX &gt; </td></tr>
<tr class="memitem:acde903394a6c87915d3262d08b48fdea"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Output &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#acde903394a6c87915d3262d08b48fdea">column_medians</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; *p, int threads=1)</td></tr>
<tr class="separator:acde903394a6c87915d3262d08b48fdea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5406cb065686144b1fa807d6c1af09d1"><td class="memTemplParams" colspan="2">template&lt;typename Output  = double, typename T , typename IDX &gt; </td></tr>
<tr class="memitem:a5406cb065686144b1fa807d6c1af09d1"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Output &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a5406cb065686144b1fa807d6c1af09d1">row_medians</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; *p, int threads=1)</td></tr>
<tr class="separator:a5406cb065686144b1fa807d6c1af09d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ebbc4660ae0ae0bb1cb514f193837ff"><td class="memTemplParams" colspan="2">template&lt;typename Output  = double, typename T , typename IDX &gt; </td></tr>
<tr class="memitem:a3ebbc4660ae0ae0bb1cb514f193837ff"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Output &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a3ebbc4660ae0ae0bb1cb514f193837ff">column_maxs</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; *p, int threads=1)</td></tr>
<tr class="separator:a3ebbc4660ae0ae0bb1cb514f193837ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c924a9443481b6598bce6968a920e4"><td class="memTemplParams" colspan="2">template&lt;typename Output  = double, typename T , typename IDX &gt; </td></tr>
<tr class="memitem:ae9c924a9443481b6598bce6968a920e4"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Output &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ae9c924a9443481b6598bce6968a920e4">row_maxs</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; *p, int threads=1)</td></tr>
<tr class="separator:ae9c924a9443481b6598bce6968a920e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0436862fff854690153b3c19f286674"><td class="memTemplParams" colspan="2">template&lt;typename Output  = double, typename T , typename IDX &gt; </td></tr>
<tr class="memitem:ae0436862fff854690153b3c19f286674"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Output &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ae0436862fff854690153b3c19f286674">column_mins</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; *p, int threads=1)</td></tr>
<tr class="separator:ae0436862fff854690153b3c19f286674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa692c0282852e73b4617ce1d11fbc866"><td class="memTemplParams" colspan="2">template&lt;typename Output  = double, typename T , typename IDX &gt; </td></tr>
<tr class="memitem:aa692c0282852e73b4617ce1d11fbc866"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Output &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#aa692c0282852e73b4617ce1d11fbc866">row_mins</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; *p, int threads=1)</td></tr>
<tr class="separator:aa692c0282852e73b4617ce1d11fbc866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17db0156d225f63b3d63fc4a27ea950d"><td class="memTemplParams" colspan="2">template&lt;typename Output  = double, typename T , typename IDX &gt; </td></tr>
<tr class="memitem:a17db0156d225f63b3d63fc4a27ea950d"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; Output &gt;, std::vector&lt; Output &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a17db0156d225f63b3d63fc4a27ea950d">column_ranges</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; *p, int threads=1)</td></tr>
<tr class="separator:a17db0156d225f63b3d63fc4a27ea950d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2954fabae4819e4dd1433a34691642e1"><td class="memTemplParams" colspan="2">template&lt;typename Output  = double, typename T , typename IDX &gt; </td></tr>
<tr class="memitem:a2954fabae4819e4dd1433a34691642e1"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; Output &gt;, std::vector&lt; Output &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a2954fabae4819e4dd1433a34691642e1">row_ranges</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; *p, int threads=1)</td></tr>
<tr class="separator:a2954fabae4819e4dd1433a34691642e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b06061261eeb15d1827dd7290162ae8"><td class="memTemplParams" colspan="2">template&lt;typename Output  = double, typename T , typename IDX &gt; </td></tr>
<tr class="memitem:a3b06061261eeb15d1827dd7290162ae8"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Output &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a3b06061261eeb15d1827dd7290162ae8">column_sums</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; *p, int threads=1)</td></tr>
<tr class="separator:a3b06061261eeb15d1827dd7290162ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d121e9c7c0ded4ba86382bd83abf103"><td class="memTemplParams" colspan="2">template&lt;typename Output  = double, typename T , typename IDX &gt; </td></tr>
<tr class="memitem:a3d121e9c7c0ded4ba86382bd83abf103"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Output &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a3d121e9c7c0ded4ba86382bd83abf103">row_sums</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; *p, int threads=1)</td></tr>
<tr class="separator:a3d121e9c7c0ded4ba86382bd83abf103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101a4123f87b6c4fd919004c2f3d3a91"><td class="memTemplParams" colspan="2">template&lt;typename Output  = double, typename T , typename IDX &gt; </td></tr>
<tr class="memitem:a101a4123f87b6c4fd919004c2f3d3a91"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Output &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a101a4123f87b6c4fd919004c2f3d3a91">column_variances</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; *p, int threads=1)</td></tr>
<tr class="separator:a101a4123f87b6c4fd919004c2f3d3a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa54193cf4c92ace983cba8c118ca1a"><td class="memTemplParams" colspan="2">template&lt;typename Output  = double, typename T , typename IDX &gt; </td></tr>
<tr class="memitem:a2aa54193cf4c92ace983cba8c118ca1a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Output &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a2aa54193cf4c92ace983cba8c118ca1a">row_variances</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; *p, int threads=1)</td></tr>
<tr class="separator:a2aa54193cf4c92ace983cba8c118ca1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c52cf8a974ad0025550b002d391d39"><td class="memTemplParams" colspan="2">template&lt;int margin, class <a class="el" href="classtatami_1_1Matrix.html">Matrix</a> , typename Id &gt; </td></tr>
<tr class="memitem:a87c52cf8a974ad0025550b002d391d39"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a> &gt;, std::vector&lt; size_t &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a87c52cf8a974ad0025550b002d391d39">bind_intersection</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a> &gt; &gt; &amp;inputs, const std::vector&lt; const Id * &gt; &amp;ids)</td></tr>
<tr class="separator:a87c52cf8a974ad0025550b002d391d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17e92414b0bff60f7b7a6431ac8a330"><td class="memTemplParams" colspan="2">template&lt;bool ROW, class U , class V , class W &gt; </td></tr>
<tr class="memitem:ab17e92414b0bff60f7b7a6431ac8a330"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ab17e92414b0bff60f7b7a6431ac8a330">compress_sparse_triplets</a> (size_t nr, size_t nc, U &amp;values, V &amp;rows, W &amp;cols)</td></tr>
<tr class="separator:ab17e92414b0bff60f7b7a6431ac8a330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd35b3b6f34a8b4965ef9a1cef6fc93"><td class="memTemplParams" colspan="2">template&lt;bool row, typename DataInterface  = double, typename Index  = int, typename DataStore  = DataInterface, class MatrixIn &gt; </td></tr>
<tr class="memitem:a5fd35b3b6f34a8b4965ef9a1cef6fc93"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; DataInterface, Index &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a5fd35b3b6f34a8b4965ef9a1cef6fc93">convert_to_dense</a> (const MatrixIn *incoming)</td></tr>
<tr class="separator:a5fd35b3b6f34a8b4965ef9a1cef6fc93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1a033ef94ba9f52be54fbd86f85568"><td class="memTemplParams" colspan="2">template&lt;typename DataInterface  = double, typename Index  = int, typename DataStore  = DataInterface, class MatrixIn &gt; </td></tr>
<tr class="memitem:a9a1a033ef94ba9f52be54fbd86f85568"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; DataInterface, Index &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a9a1a033ef94ba9f52be54fbd86f85568">convert_to_dense</a> (const MatrixIn *incoming, int order)</td></tr>
<tr class="separator:a9a1a033ef94ba9f52be54fbd86f85568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369c51892651351f16e24ae1dae68984"><td class="memTemplParams" colspan="2">template&lt;bool row, typename DataInterface  = double, typename IndexInterface  = int, typename DataStore  = DataInterface, typename IndexStore  = IndexInterface, class MatrixIn &gt; </td></tr>
<tr class="memitem:a369c51892651351f16e24ae1dae68984"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; DataInterface, IndexInterface &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a369c51892651351f16e24ae1dae68984">convert_to_sparse</a> (const MatrixIn *incoming, double reserve=0.1)</td></tr>
<tr class="separator:a369c51892651351f16e24ae1dae68984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d51ef21a7f65f0386b4bff00961f637"><td class="memTemplParams" colspan="2">template&lt;typename DataInterface  = double, typename IndexInterface  = int, typename DataStore  = DataInterface, typename IndexStore  = IndexInterface, class MatrixIn &gt; </td></tr>
<tr class="memitem:a4d51ef21a7f65f0386b4bff00961f637"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; DataInterface, IndexInterface &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a4d51ef21a7f65f0386b4bff00961f637">convert_to_sparse</a> (const MatrixIn *incoming, int order)</td></tr>
<tr class="separator:a4d51ef21a7f65f0386b4bff00961f637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7518f5e8e09a6f6d7d3955b8ea286689"><td class="memTemplParams" colspan="2">template&lt;typename T , typename IDX &gt; </td></tr>
<tr class="memitem:a7518f5e8e09a6f6d7d3955b8ea286689"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a7518f5e8e09a6f6d7d3955b8ea286689">wrap_shared_ptr</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; *ptr)</td></tr>
<tr class="separator:a7518f5e8e09a6f6d7d3955b8ea286689"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Flexible representations for matrix data. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a3d1338ade036e38b6d363a6c8a704a2b" name="a3d1338ade036e38b6d363a6c8a704a2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d1338ade036e38b6d363a6c8a704a2b">&#9670;&#160;</a></span>CompressedSparseColumnMatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX , class U  = std::vector&lt;T&gt;, class V  = std::vector&lt;IDX&gt;, class W  = std::vector&lt;size_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetatami.html#a3d1338ade036e38b6d363a6c8a704a2b">tatami::CompressedSparseColumnMatrix</a> = typedef <a class="el" href="classtatami_1_1CompressedSparseMatrix.html">CompressedSparseMatrix</a>&lt;false, T, IDX, U, V, W&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compressed sparse column matrix. See <code><a class="el" href="classtatami_1_1CompressedSparseMatrix.html" title="Compressed sparse matrix representation.">tatami::CompressedSparseMatrix</a></code> for details on the template parameters. </p>

</div>
</div>
<a id="a33a0b775b994304c942e990fe12e793e" name="a33a0b775b994304c942e990fe12e793e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a0b775b994304c942e990fe12e793e">&#9670;&#160;</a></span>CompressedSparseRowMatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX , class U  = std::vector&lt;T&gt;, class V  = std::vector&lt;IDX&gt;, class W  = std::vector&lt;size_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetatami.html#a33a0b775b994304c942e990fe12e793e">tatami::CompressedSparseRowMatrix</a> = typedef <a class="el" href="classtatami_1_1CompressedSparseMatrix.html">CompressedSparseMatrix</a>&lt;true, T, IDX, U, V, W&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compressed sparse row matrix. See <code><a class="el" href="classtatami_1_1CompressedSparseMatrix.html" title="Compressed sparse matrix representation.">tatami::CompressedSparseMatrix</a></code> for details on the template parameters. </p>

</div>
</div>
<a id="a1c118308300d626e53436a9540dd8bd9" name="a1c118308300d626e53436a9540dd8bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c118308300d626e53436a9540dd8bd9">&#9670;&#160;</a></span>DenseColumnMatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int, class V  = std::vector&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetatami.html#a1c118308300d626e53436a9540dd8bd9">tatami::DenseColumnMatrix</a> = typedef <a class="el" href="classtatami_1_1DenseMatrix.html">DenseMatrix</a>&lt;false, T, IDX, V&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Column-major matrix. See <code><a class="el" href="classtatami_1_1DenseMatrix.html" title="Dense matrix representation.">tatami::DenseMatrix</a></code> for details on the template parameters. </p>

</div>
</div>
<a id="ad4db75262ca90f85a4278b90f844cffd" name="ad4db75262ca90f85a4278b90f844cffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4db75262ca90f85a4278b90f844cffd">&#9670;&#160;</a></span>DenseRowMatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int, class V  = std::vector&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetatami.html#ad4db75262ca90f85a4278b90f844cffd">tatami::DenseRowMatrix</a> = typedef <a class="el" href="classtatami_1_1DenseMatrix.html">DenseMatrix</a>&lt;true, T, IDX, V&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Row-major matrix. See <code><a class="el" href="classtatami_1_1DenseMatrix.html" title="Dense matrix representation.">tatami::DenseMatrix</a></code> for details on the template parameters. </p>

</div>
</div>
<a id="a35c670894994f1d620abb55953f98441" name="a35c670894994f1d620abb55953f98441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35c670894994f1d620abb55953f98441">&#9670;&#160;</a></span>NumericMatrix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetatami.html#a35c670894994f1d620abb55953f98441">tatami::NumericMatrix</a> = typedef <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt;double, int&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenient shorthand for the most common use case of double-precision matrices. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ac4dba1039cc39910b0dd3bcccfea0f71" name="ac4dba1039cc39910b0dd3bcccfea0f71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4dba1039cc39910b0dd3bcccfea0f71">&#9670;&#160;</a></span>SparseCopyMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetatami.html#ac4dba1039cc39910b0dd3bcccfea0f71">tatami::SparseCopyMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>What components of the non-zero elements should be copied? Just the indices (<code>INDEX</code>), the values (<code>VALUE</code>) or both (<code>BOTH</code>). </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa82419090e54a4674d971429e93e6af5" name="aa82419090e54a4674d971429e93e6af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa82419090e54a4674d971429e93e6af5">&#9670;&#160;</a></span>make_DelayedAddVectorHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int MARGIN, typename T  = double, class V  = std::vector&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedAddVectorHelper.html">DelayedAddVectorHelper</a>&lt; MARGIN, T, V &gt; tatami::make_DelayedAddVectorHelper </td>
          <td>(</td>
          <td class="paramtype">V&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <code>make_*</code> helper function to enable partial template deduction of supplied types. See the <code><a class="el" href="structtatami_1_1DelayedAddVectorHelper.html" title="Add a vector along the rows or columns of a matrix.">tatami::DelayedAddVectorHelper</a></code> documentation for more details on the arguments. </p>

</div>
</div>
<a id="abb68a8d27e821f213965edab7f029c48" name="abb68a8d27e821f213965edab7f029c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb68a8d27e821f213965edab7f029c48">&#9670;&#160;</a></span>make_DelayedSubtractVectorHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool RIGHT, int MARGIN, typename T  = double, class V  = std::vector&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedSubtractVectorHelper.html">DelayedSubtractVectorHelper</a>&lt; RIGHT, MARGIN, T, V &gt; tatami::make_DelayedSubtractVectorHelper </td>
          <td>(</td>
          <td class="paramtype">V&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <code>make_*</code> helper function to enable partial template deduction of supplied types. See the <code><a class="el" href="structtatami_1_1DelayedSubtractVectorHelper.html" title="Subtract a vector from the rows/columns of a matrix, or vice versa.">tatami::DelayedSubtractVectorHelper</a></code> documentation for more details on the arguments. </p>

</div>
</div>
<a id="a316f4cf0ae5a9e83c2dad6ccbbbcfb43" name="a316f4cf0ae5a9e83c2dad6ccbbbcfb43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a316f4cf0ae5a9e83c2dad6ccbbbcfb43">&#9670;&#160;</a></span>make_DelayedMultiplyVectorHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int MARGIN, typename T  = double, class V  = std::vector&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedMultiplyVectorHelper.html">DelayedMultiplyVectorHelper</a>&lt; MARGIN, T, V &gt; tatami::make_DelayedMultiplyVectorHelper </td>
          <td>(</td>
          <td class="paramtype">V&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <code>make_*</code> helper function to enable partial template deduction of supplied types. See the <code><a class="el" href="structtatami_1_1DelayedMultiplyVectorHelper.html" title="Multiply a vector along the rows or columns of a matrix.">tatami::DelayedMultiplyVectorHelper</a></code> documentation for more details on the arguments. </p>

</div>
</div>
<a id="ab104e5029db4d09afe0b47a125f457bf" name="ab104e5029db4d09afe0b47a125f457bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab104e5029db4d09afe0b47a125f457bf">&#9670;&#160;</a></span>make_DelayedDivideVectorHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool RIGHT, int MARGIN, typename T  = double, class V  = std::vector&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedDivideVectorHelper.html">DelayedDivideVectorHelper</a>&lt; RIGHT, MARGIN, T, V &gt; tatami::make_DelayedDivideVectorHelper </td>
          <td>(</td>
          <td class="paramtype">V&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <code>make_*</code> helper function to enable partial template deduction of supplied types. See the <code><a class="el" href="structtatami_1_1DelayedDivideVectorHelper.html" title="Divide the rows/columns of a matrix by a vector, or vice versa.">tatami::DelayedDivideVectorHelper</a></code> documentation for more details on the arguments. </p>

</div>
</div>
<a id="ac019a143af4fd0eb34f530527a424888" name="ac019a143af4fd0eb34f530527a424888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac019a143af4fd0eb34f530527a424888">&#9670;&#160;</a></span>make_DelayedBind()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int MARGIN, class MAT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; MAT &gt; tatami::make_DelayedBind </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::shared_ptr&lt; MAT &gt; &gt;&#160;</td>
          <td class="paramname"><em>ps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <code>make_*</code> helper function to enable partial template deduction of supplied types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MARGIN</td><td>Dimension along which the combining is to occur. If 0, matrices are combined along the rows; if 1, matrices are combined to the columns. </td></tr>
    <tr><td class="paramname">MAT</td><td>A specialized <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code>, to be automatically deducted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ps</td><td>Pointers to <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <code><a class="el" href="classtatami_1_1DelayedBind.html" title="Delayed combining of a matrix.">DelayedBind</a></code> instance. </dd></dl>

</div>
</div>
<a id="a83170fbdceea0e9a7e0074f1b193c66b" name="a83170fbdceea0e9a7e0074f1b193c66b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83170fbdceea0e9a7e0074f1b193c66b">&#9670;&#160;</a></span>make_DelayedCast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_out , typename IDX_out , typename T_in , typename IDX_in &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T_out, IDX_out &gt; &gt; tatami::make_DelayedCast </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T_in, IDX_in &gt; &gt;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recast a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> to a different interface type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_out</td><td>Data type to cast to. </td></tr>
    <tr><td class="paramname">IDX_out</td><td>Index type to cast to. </td></tr>
    <tr><td class="paramname">T_in</td><td>Data type to cast from. </td></tr>
    <tr><td class="paramname">IDX_in</td><td>Index type to cast from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to the <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> instance to cast from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> instance of the desired interface type. </dd></dl>

</div>
</div>
<a id="a0e2cd6fd2c5bba7eb83582619ffc9cea" name="a0e2cd6fd2c5bba7eb83582619ffc9cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e2cd6fd2c5bba7eb83582619ffc9cea">&#9670;&#160;</a></span>make_DelayedIsometricOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MAT , class OP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; MAT &gt; tatami::make_DelayedIsometricOp </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; MAT &gt;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OP&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <code>make_*</code> helper function to enable partial template deduction of supplied types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MAT</td><td>A specialized <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code>, to be automatically deducted. </td></tr>
    <tr><td class="paramname">OP</td><td>Helper class defining the operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code>. </td></tr>
    <tr><td class="paramname">op</td><td>Instance of the operation helper class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd395c7ec8bb251ab11206166a972bbc" name="acd395c7ec8bb251ab11206166a972bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd395c7ec8bb251ab11206166a972bbc">&#9670;&#160;</a></span>make_DelayedSubset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int MARGIN, class MAT , class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; MAT &gt; tatami::make_DelayedSubset </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; MAT &gt;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <code>make_*</code> helper function to enable partial template deduction of supplied types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MARGIN</td><td>Dimension along which the subsetting is to occur. If 0, the subset is applied to the rows; if 1, the subset is applied to the columns. </td></tr>
    <tr><td class="paramname">MAT</td><td>A specialized <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code>, to be automatically deducted. </td></tr>
    <tr><td class="paramname">V</td><td>Vector containing the subset indices, to be automatically deducted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code>. </td></tr>
    <tr><td class="paramname">idx</td><td>Instance of the index vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <code><a class="el" href="classtatami_1_1DelayedSubset.html" title="Delayed subsetting of a matrix.">DelayedSubset</a></code> instance. </dd></dl>

</div>
</div>
<a id="a4ef69731d317edc4ce24de03e67f8097" name="a4ef69731d317edc4ce24de03e67f8097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ef69731d317edc4ce24de03e67f8097">&#9670;&#160;</a></span>make_DelayedSubsetBlock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int MARGIN, class MAT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; MAT &gt; tatami::make_DelayedSubsetBlock </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; MAT &gt;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <code>make_*</code> helper function to enable partial template deduction of supplied types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MARGIN</td><td>Dimension along which the addition is to occur. If 0, the subset is applied to the rows; if 1, the subset is applied to the columns. </td></tr>
    <tr><td class="paramname">MAT</td><td>A specialized <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code>, to be automatically deducted. </td></tr>
    <tr><td class="paramname">V</td><td>Vector containing the subset indices, to be automatically deducted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to the underlying (pre-subset) <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code>. </td></tr>
    <tr><td class="paramname">f</td><td>Index of the start of the block. This should be a row index if <code>MARGIN = 0</code> and a column index otherwise. </td></tr>
    <tr><td class="paramname">l</td><td>Index of the one-past-the-end of the block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <code><a class="el" href="classtatami_1_1DelayedSubsetBlock.html" title="Delayed subsetting to a contiguous block.">DelayedSubsetBlock</a></code> instance. </dd></dl>

</div>
</div>
<a id="ab8888d53a1922d378a7abafa1a1146ff" name="ab8888d53a1922d378a7abafa1a1146ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8888d53a1922d378a7abafa1a1146ff">&#9670;&#160;</a></span>make_DelayedTranspose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MAT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; MAT &gt; tatami::make_DelayedTranspose </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; MAT &gt;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <code>make_*</code> helper function to enable partial template deduction of supplied types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MAT</td><td>A specialized <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code>, to be automatically deducted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <code><a class="el" href="classtatami_1_1DelayedTranspose.html" title="Delayed transposition of a matrix.">DelayedTranspose</a></code> instance. </dd></dl>

</div>
</div>
<a id="a8e62b7595d4b0d1d06cb203952007b28" name="a8e62b7595d4b0d1d06cb203952007b28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e62b7595d4b0d1d06cb203952007b28">&#9670;&#160;</a></span>load_hdf5_compressed_sparse_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool ROW, typename T , typename IDX  = int, class U  = std::vector&lt;T&gt;, class V  = std::vector&lt;IDX&gt;, class W  = std::vector&lt;size_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1CompressedSparseMatrix.html">CompressedSparseMatrix</a>&lt; ROW, T, IDX, U, V, W &gt; tatami::load_hdf5_compressed_sparse_matrix </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load a <code><a class="el" href="classtatami_1_1CompressedSparseMatrix.html" title="Compressed sparse matrix representation.">CompressedSparseMatrix</a></code> from a HDF5 file.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ROW</td><td>Whether the matrix is stored in compressed sparse row format. </td></tr>
    <tr><td class="paramname">T</td><td>Type of the matrix values in the <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> interface. </td></tr>
    <tr><td class="paramname">IDX</td><td>Type of the row/column indices. </td></tr>
    <tr><td class="paramname">U</td><td>Vector type for storing the values of the non-zero elements. Elements of this vector may be of a different type than <code>T</code> for more efficient storage. </td></tr>
    <tr><td class="paramname">V</td><td>Vector type for storing the indices. Elements of this vector may be of a different type than <code>IDX</code> for more efficient storage. </td></tr>
    <tr><td class="paramname">W</td><td>Vector type for storing the index pointers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nr</td><td>Number of rows in the matrix. </td></tr>
    <tr><td class="paramname">nc</td><td>Number of columns in the matrix. </td></tr>
    <tr><td class="paramname">file</td><td>Path to the file. </td></tr>
    <tr><td class="paramname">vals</td><td>Name of the 1D dataset inside <code>file</code> containing the non-zero elements. </td></tr>
    <tr><td class="paramname">idx</td><td>Name of the 1D dataset inside <code>file</code> containing the indices of the non-zero elements. If <code>ROW = true</code>, this should contain column indices sorted within each row, otherwise it should contain row indices sorted within each column. </td></tr>
    <tr><td class="paramname">ptr</td><td>Name of the 1D dataset inside <code>file</code> containing the index pointers for the start and end of each row (if <code>ROW = true</code>) or column (otherwise). This should have length equal to the number of rows (if <code>ROW = true</code>) or columns (otherwise).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="classtatami_1_1CompressedSparseMatrix.html" title="Compressed sparse matrix representation.">CompressedSparseMatrix</a></code> containing all values and indices in memory. This differs from a <code><a class="el" href="classtatami_1_1HDF5CompressedSparseMatrix.html" title="Compressed sparse matrix in a HDF5 file.">HDF5CompressedSparseMatrix</a></code>, where the loading of data is deferred until requested. </dd></dl>

</div>
</div>
<a id="ad13e199dab7f4ab7c4d3045a032f8cac" name="ad13e199dab7f4ab7c4d3045a032f8cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad13e199dab7f4ab7c4d3045a032f8cac">&#9670;&#160;</a></span>load_hdf5_dense_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX  = int, class V  = std::vector&lt;T&gt;, bool transpose = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DenseMatrix.html">DenseMatrix</a>&lt;!transpose, T, IDX, V &gt; tatami::load_hdf5_dense_matrix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load a <code><a class="el" href="classtatami_1_1DenseMatrix.html" title="Dense matrix representation.">DenseMatrix</a></code> from a HDF5 DataSet.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the matrix values in the <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> interface. </td></tr>
    <tr><td class="paramname">IDX</td><td>Type of the row/column indices. </td></tr>
    <tr><td class="paramname">V</td><td>Vector type for storing the matrix values. This may be different from <code>T</code> for more efficient storage. </td></tr>
    <tr><td class="paramname">transpose</td><td>Whether the dataset is transposed in its storage order, i.e., rows in HDF5 are columns in the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>Path to the HDF5 file. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the dataset inside the file. This should refer to a 2-dimensional dataset of integer or floating-point type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="classtatami_1_1DenseMatrix.html" title="Dense matrix representation.">DenseMatrix</a></code> where all values are in memory. This differs from a <code><a class="el" href="classtatami_1_1HDF5DenseMatrix.html" title="Dense matrix backed by a DataSet in a HDF5 file.">HDF5DenseMatrix</a></code>, where the loading of data is deferred until requested. </dd></dl>

</div>
</div>
<a id="ad9cce803e8db12c73f1678ff3c022a19" name="ad9cce803e8db12c73f1678ff3c022a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9cce803e8db12c73f1678ff3c022a19">&#9670;&#160;</a></span>write_sparse_matrix_to_hdf5() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tatami::write_sparse_matrix_to_hdf5 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; *&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">H5::Group &amp;&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1WriteSparseMatrixToHdf5Parameters.html">WriteSparseMatrixToHdf5Parameters</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a sparse matrix inside a HDF5 group. On return, <code>location</code> will be populated with three datasets containing the matrix contents in a compressed sparse format. Storage of dimensions and other metadata (e.g., related to column versus row layout) is left to the caller.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the matrix values. </td></tr>
    <tr><td class="paramname">IDX</td><td>Type of the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Pointer to the (presumably sparse) matrix to be written. </td></tr>
    <tr><td class="paramname">location</td><td>Handle to a HDF5 group in which to write the matrix contents. </td></tr>
    <tr><td class="paramname">params</td><td>Parameters to use when writing the matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a39d4f99c974648a98b6d9cf99e4a8ec4" name="a39d4f99c974648a98b6d9cf99e4a8ec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39d4f99c974648a98b6d9cf99e4a8ec4">&#9670;&#160;</a></span>write_sparse_matrix_to_hdf5() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tatami::write_sparse_matrix_to_hdf5 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; *&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">H5::Group &amp;&#160;</td>
          <td class="paramname"><em>location</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a sparse matrix inside a HDF5 group. On return, <code>location</code> will be populated with three datasets containing the matrix contents in a compressed sparse format. Storage of dimensions and other metadata (e.g., related to column versus row layout) is left to the caller.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the matrix values. </td></tr>
    <tr><td class="paramname">IDX</td><td>Type of the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Pointer to the (presumably sparse) matrix to be written. </td></tr>
    <tr><td class="paramname">location</td><td>Handle to a HDF5 group in which to write the matrix contents. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0692b6c82646df0131b9872431a11bf2" name="a0692b6c82646df0131b9872431a11bf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0692b6c82646df0131b9872431a11bf2">&#9670;&#160;</a></span>apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int MARGIN, typename T , typename IDX , class Factory &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tatami::apply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Factory &amp;&#160;</td>
          <td class="paramname"><em>factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MARGIN</td><td>The dimension over which to apply the calculation of statistics, i.e., rows (0) or columns (1). </td></tr>
    <tr><td class="paramname">T</td><td>Type of the matrix value, should be summable. </td></tr>
    <tr><td class="paramname">IDX</td><td>Type of the row/column indices. </td></tr>
    <tr><td class="paramname">Factory</td><td>Factory class to create the statistic-calculating classes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">factory</td><td>Instance of a factory. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use for matrix traversal.</td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="apply_overview"></a>
Overview</h1>
<p>In this function, we consider the matrix to be a collection of "target vectors". When <code>MARGIN = 0</code>, each row is a target vector, whereas when <code>MARGIN = 1</code>, each column is a target vector. The goal is to compute some statistic along each of these target vectors, e.g., the per-row sums (<code><a class="el" href="namespacetatami.html#a3d121e9c7c0ded4ba86382bd83abf103">row_sums()</a></code>) or the per-column variances (<code><a class="el" href="namespacetatami.html#a2aa54193cf4c92ace983cba8c118ca1a">row_variances()</a></code>). (For brevity, we will refer to the vectors along the other dimension as "non-target vectors".)</p>
<p><code><a class="el" href="namespacetatami.html#a0692b6c82646df0131b9872431a11bf2">apply()</a></code> will automatically choose the most efficient iteration strategy for the supplied matrix. This depends on whether the matrix is sparse or dense; whether the matrix prefers iteration across rows or columns; and whether the desired statistic must be computed directly (i.e., given one target vector at a time) or can be computed in a "running" fashion (i.e., given one non-target vector at a time).</p>
<h1><a class="anchor" id="apply_factory"></a>
Factory requirements</h1>
<p>Arbitrary computations are supported via the supplied <code>factory</code> instance of the factory class. The factory class should have a <code>dense_direct()</code> method that accepts no arguments and returns an arbitrary object (referred to here as a "worker"). The worker should have a <code>compute()</code> method that accepts the index of the target vector and a <code>const</code> pointer to the target vector. This will be used in the "direct" iteration strategy, i.e., the statistic for a target vector is directly computed from the target vector's values in memory.</p>
<p>Optionally, the factory class may have one or more of:</p>
<ul>
<li>A <code>sparse_direct()</code> method that accepts no arguments and returns an arbitrary worker (not necessarily of the same class as <code>dense_direct()</code>). The worker should have a <code>compute()</code> method that accepts the index of the target vector and a <code><a class="el" href="structtatami_1_1SparseRange.html" title="A range of a sparse vector.">SparseRange</a></code> object containing the non-zero elements of the target vector. This will be favored for direct iteration over a sparse matrix.</li>
<li>A <code>dense_running()</code> method that accepts no arguments and returns an arbitrary worker. The worker should have an <code>add()</code> method that accepts a pointer to a non-target vector. It may also have a <code>finish()</code> method, to be called to finalize any calculations after all non-target vectors are supplied. This will be favored for running iteration over a dense matrix.</li>
<li>A <code>sparse_running()</code> method that accepts no arguments and returns an arbitrary worker. The worker should have an <code>add()</code> method that accepts a <code><a class="el" href="structtatami_1_1SparseRange.html" title="A range of a sparse vector.">SparseRange</a></code> object specifying the non-zero elements of a non-target vector. It may also have a <code>finish()</code> method, to be called to finalize any calculations after all non-target vectors are supplied. This will be favored for running iteration over a sparse matrix.</li>
</ul>
<p><code><a class="el" href="namespacetatami.html#a0692b6c82646df0131b9872431a11bf2">apply()</a></code> will automatically choose the most appropriate iteration strategy based on the various inputs. If <code>MARGIN</code> is consistent with the matrix's preferred dimension for iteration, a direct strategy is used; otherwise a running strategy will be chosen. If the matrix is sparse, the <code>sparse_*()</code> versions of the methods above will be favored. If the factory does not implement the method for the best iteration strategy, <code><a class="el" href="namespacetatami.html#a0692b6c82646df0131b9872431a11bf2">apply()</a></code> will attempt other strategies, finally falling back to the <code>dense_direct()</code> method. We assume that iteration in the non-preferred dimension is costly and will attempt to avoid this wherever possible.</p>
<p>Each of these <code>compute()</code> and <code>add()</code> methods should modify the contents of <code>factory</code> by reference. This is achieved by passing pointers from <code>factory</code> to each worker and writing to those pointers in <code>compute()</code> and <code>add()</code>. Computed statistics can then be extracted from <code>factory</code> once <code><a class="el" href="namespacetatami.html#a0692b6c82646df0131b9872431a11bf2">apply()</a></code> has finished running. Results should be agnostic to the choice of calculation, notwithstanding minor differences due to numerical precision.</p>
<p>In the running calculations, the statistic for each target vector should be computed incrementally as new values become available in successive non-target vectors. For example, if the matrix prefers row access but we want to compute column sums, <code><a class="el" href="namespacetatami.html#a0692b6c82646df0131b9872431a11bf2">apply()</a></code> can use a running strategy to exploit the more efficient access pattern. This could be achieved in <code>add()</code> by iterating across the supplied non-target vector and adding each entry to the running statistic for the corresponding target vector.</p>
<p>See the <code>VarianceFactory</code> in <code><a class="el" href="variances_8hpp.html" title="Compute row and column variances from a tatami::Matrix.">variances.hpp</a></code> for an example of a valid factory class.</p>
<h1><a class="anchor" id="apply_mutable"></a>
Mutating copies</h1>
<p>In some applications, it may be necessary to mutate the buffers containing the contents of each target vector (e.g., sorting for quantile calculations). This is accommodated by replacing the <code>compute()</code> method with a <code>compute_copy()</code> method for the <code>*_direct()</code> workers.</p>
<ul>
<li>In the dense case, the <code>compute_copy()</code> method should accept the index of the target vector and a non-<code>const</code> pointer to a buffer with the values of the row/column.</li>
<li>In the sparse case, the <code>compute_copy()</code> should accept the index of the target vector, the number of non-zero elements, a non-<code>const</code> pointer to a buffer with the non-zero values, and a non-<code>const</code> pointer to the indices of the non-zero elements. The worker may also contain a static <code>copy_mode</code> member specifying whether one or both the values/indices should be copied into the buffers, see the options for a <code>SparseCopyMode</code>.</li>
</ul>
<p>If a <code>compute_copy()</code> method is available, <code><a class="el" href="namespacetatami.html#a0692b6c82646df0131b9872431a11bf2">apply()</a></code> will create a copy upon row/column extraction and the developer is free to modify the buffers inside the <code>compute_copy()</code> method. Note that we do not provide a copyable option for the <code>*_running()</code> workers, as there is nothing to mutate when the target vector is never instantiated.</p>
<p>See the <code>MedianFactory</code> in <code><a class="el" href="medians_8hpp.html" title="Compute row and column medians from a tatami::Matrix.">medians.hpp</a></code> for an example of a factory that mutates the buffer.</p>
<h1><a class="anchor" id="method_prep"></a>
Method-specific preparation</h1>
<p>The factory class may optionally implement any number of the following methods:</p>
<ul>
<li><code>prepare_dense_direct()</code>, which will be called once before any invocation of <code>dense_direct()</code>.</li>
<li><code>prepare_dense_running()</code>, which will be called once before any invocation of <code>dense_running()</code>.</li>
<li><code>prepare_sparse_direct()</code>, which will be called once before any invocation of <code>sparse_direct()</code>.</li>
<li><code>prepare_sparse_running()</code>, which will be called once before any invocation of <code>sparse_running()</code>.</li>
</ul>
<p>This can be used by developers to perform any necessary preparation before iteration over the input matrix. Importantly, the manner of preparation can vary according to the chosen iteration strategy. For example, running calculations will typically require more intermediate structures than their direct counterparts; the <code>prepare_*_running()</code> methods can be used to set up those intermediates as needed, without committing to the setup cost if <code><a class="el" href="namespacetatami.html#a0692b6c82646df0131b9872431a11bf2">apply()</a></code> chooses to use a direct strategy.</p>
<h1><a class="anchor" id="apply_parallel2"></a>
Caller parallelization</h1>
<p><code><a class="el" href="namespacetatami.html#a0692b6c82646df0131b9872431a11bf2">apply()</a></code> supports parallelization via OpenMP by default, so callers can simply compile with <code>-fopenmp</code> to parallelize their code. <code><a class="el" href="namespacetatami.html#a0692b6c82646df0131b9872431a11bf2">apply()</a></code> will automatically distribute the calculations for each target vector across available threads. The maximum number of threads is defined by the <code>threads</code> argument.</p>
<p>Advanced callers of <code><a class="el" href="namespacetatami.html#a0692b6c82646df0131b9872431a11bf2">apply()</a></code> may specify their own parallelization scheme by defining a <code>TATAMI_CUSTOM_PARALLEL</code> macro. This should be a function-like macro with three arguments:</p>
<ul>
<li><code>n</code>, an integer specifying the total number of jobs.</li>
<li><code>f</code>, a lambda specifying the function to run on a range of jobs in <code>n</code>. This should take two <code>size_t</code> arguments specifying the start and one-past-the-end of the range.</li>
<li><code>t</code>, an integer specifying the number of available threads. This is set to <code>threads</code>.</li>
</ul>
<p>The <code>TATAMI_CUSTOM_PARALLEL</code> function is expected to split <code>n</code> into non-overlapping ranges where each range is assigned to a worker. It should then call <code>f</code> within each worker on the corresponding range of jobs. For example:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Function&gt;</div>
<div class="line"><span class="keywordtype">void</span> parallelize(<span class="keywordtype">size_t</span> n, Function f, <span class="keywordtype">size_t</span> nworkers) {</div>
<div class="line">    <span class="keywordtype">size_t</span> jobs_per_worker = std::ceil(<span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(n) / nworkers);</div>
<div class="line">    <span class="keywordtype">size_t</span> start = 0;</div>
<div class="line">    std::vector&lt;std::thread&gt; jobs;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> w = 0; w &lt; nworkers; ++w) {</div>
<div class="line">        <span class="keywordtype">size_t</span> end = std::min(n, start + jobs_per_worker);</div>
<div class="line">        <span class="keywordflow">if</span> (start &gt;= end) {</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">        jobs.emplace_back(f, start, end);</div>
<div class="line">        start += jobs_per_worker;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; job : jobs) {</div>
<div class="line">        job.join();</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define TATAMI_CUSTOM_PARALLEL parallelize</span></div>
</div><!-- fragment --><h1><a class="anchor" id="apply_parallel"></a>
Factory parallelization</h1>
<p>Worker methods (i.e., <code>compute()</code>, <code>add()</code>, <code>finish()</code>) for a single worker instance do not have to be thread-safe. That is, methods for a single worker will only ever be called in a serial fashion, as each worker is local to a thread.</p>
<p>However, worker methods should be thread-safe across multiple worker instances. For example, <code><a class="el" href="namespacetatami.html#a0692b6c82646df0131b9872431a11bf2">apply()</a></code> may simultaneously call the <code>add()</code> method of different workers from different threads. This is most relevant when results are being written back to the shared memory in <code>factory</code>, and is usually easy to achieve as long as the memory spaces for the results of two target vectors do not overlap.</p>
<p>The direct calculations are trivially parallelizable - it is assumed that they can be called independently for different target indices. It is also assumed that each <code>compute()</code> call will only write to the shared memory at its supplied target index.</p>
<p>To support parallelization in the running calculations, we require some overloads to the <code>dense_running()</code> and <code>sparse_running()</code> methods:</p>
<ul>
<li><code>dense_running()</code> now accepts two arguments: namely, the indices of the first and one-past-the-last target vectors to be processed. This should return a worker with an <code>add()</code> method that accepts a pointer to the subinterval of the non-target vector, corresponding to the target vectors to be processed. It may also have a <code>finish()</code> method, to be called to finalize any calculations after all non-target vectors are supplied.</li>
<li><code>sparse_running()</code> now accepts two arguments: namely, the indices of the first and one-past-the-last target vectors to be processed. The returned worker should have an <code>add()</code> method that accepts a <code><a class="el" href="structtatami_1_1SparseRange.html" title="A range of a sparse vector.">SparseRange</a></code> object, specifying the non-zero elements in the subinterval of the non-target vector. It may also have a <code>finish()</code> method, to be called to finalize any calculations after all non-target vectors are supplied.</li>
</ul>
<p>These overloads are optional and the function will fall back to serial processing if they are not supplied (and the function decides perform a running calculation).</p>
<p>Calls to <code>dense_direct()</code> and counterparts should be thread-safe for any single instance of a factory class. </p>

</div>
</div>
<a id="acde903394a6c87915d3262d08b48fdea" name="acde903394a6c87915d3262d08b48fdea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acde903394a6c87915d3262d08b48fdea">&#9670;&#160;</a></span>column_medians()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output  = double, typename T , typename IDX &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Output &gt; tatami::column_medians </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Output</td><td>Type of the output. </td></tr>
    <tr><td class="paramname">T</td><td>Type of the matrix value. </td></tr>
    <tr><td class="paramname">IDX</td><td>Type of the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Shared pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of length equal to the number of columns, containing the column medians. </dd></dl>

</div>
</div>
<a id="a5406cb065686144b1fa807d6c1af09d1" name="a5406cb065686144b1fa807d6c1af09d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5406cb065686144b1fa807d6c1af09d1">&#9670;&#160;</a></span>row_medians()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output  = double, typename T , typename IDX &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Output &gt; tatami::row_medians </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Output</td><td>Type of the output. </td></tr>
    <tr><td class="paramname">T</td><td>Type of the matrix value. </td></tr>
    <tr><td class="paramname">IDX</td><td>Type of the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Shared pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of length equal to the number of rows, containing the row medians. </dd></dl>

</div>
</div>
<a id="a3ebbc4660ae0ae0bb1cb514f193837ff" name="a3ebbc4660ae0ae0bb1cb514f193837ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ebbc4660ae0ae0bb1cb514f193837ff">&#9670;&#160;</a></span>column_maxs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output  = double, typename T , typename IDX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Output &gt; tatami::column_maxs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Output</td><td>Type of the output value. </td></tr>
    <tr><td class="paramname">T</td><td>Type of the matrix value. </td></tr>
    <tr><td class="paramname">IDX</td><td>Type of the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of length equal to the number of columns, containing the maximum value in each column. </dd></dl>

</div>
</div>
<a id="ae9c924a9443481b6598bce6968a920e4" name="ae9c924a9443481b6598bce6968a920e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9c924a9443481b6598bce6968a920e4">&#9670;&#160;</a></span>row_maxs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output  = double, typename T , typename IDX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Output &gt; tatami::row_maxs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Output</td><td>Type of the output value. </td></tr>
    <tr><td class="paramname">T</td><td>Type of the matrix value. </td></tr>
    <tr><td class="paramname">IDX</td><td>Type of the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of length equal to the number of rows, containing the maximum value in each row. </dd></dl>

</div>
</div>
<a id="ae0436862fff854690153b3c19f286674" name="ae0436862fff854690153b3c19f286674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0436862fff854690153b3c19f286674">&#9670;&#160;</a></span>column_mins()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output  = double, typename T , typename IDX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Output &gt; tatami::column_mins </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Output</td><td>Type of the output value. </td></tr>
    <tr><td class="paramname">T</td><td>Type of the matrix value. </td></tr>
    <tr><td class="paramname">IDX</td><td>Type of the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of length equal to the number of columns, containing the minimum value in each column. </dd></dl>

</div>
</div>
<a id="aa692c0282852e73b4617ce1d11fbc866" name="aa692c0282852e73b4617ce1d11fbc866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa692c0282852e73b4617ce1d11fbc866">&#9670;&#160;</a></span>row_mins()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output  = double, typename T , typename IDX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Output &gt; tatami::row_mins </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Output</td><td>Type of the output value. </td></tr>
    <tr><td class="paramname">T</td><td>Type of the matrix value. </td></tr>
    <tr><td class="paramname">IDX</td><td>Type of the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of length equal to the number of rows, containing the minimum value in each row. </dd></dl>

</div>
</div>
<a id="a17db0156d225f63b3d63fc4a27ea950d" name="a17db0156d225f63b3d63fc4a27ea950d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17db0156d225f63b3d63fc4a27ea950d">&#9670;&#160;</a></span>column_ranges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output  = double, typename T , typename IDX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; Output &gt;, std::vector&lt; Output &gt; &gt; tatami::column_ranges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Output</td><td>Type of the output value. </td></tr>
    <tr><td class="paramname">T</td><td>Type of the matrix value. </td></tr>
    <tr><td class="paramname">IDX</td><td>Type of the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of vectors, each of length equal to the number of rows. The first and second vector contains the minimum and maximum value per row, respectively. </dd></dl>

</div>
</div>
<a id="a2954fabae4819e4dd1433a34691642e1" name="a2954fabae4819e4dd1433a34691642e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2954fabae4819e4dd1433a34691642e1">&#9670;&#160;</a></span>row_ranges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output  = double, typename T , typename IDX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; Output &gt;, std::vector&lt; Output &gt; &gt; tatami::row_ranges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Output</td><td>Type of the output value. </td></tr>
    <tr><td class="paramname">T</td><td>Type of the matrix value. </td></tr>
    <tr><td class="paramname">IDX</td><td>Type of the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of vectors, each of length equal to the number of rows. The first and second vector contains the minimum and maximum value per row, respectively. </dd></dl>

</div>
</div>
<a id="a3b06061261eeb15d1827dd7290162ae8" name="a3b06061261eeb15d1827dd7290162ae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b06061261eeb15d1827dd7290162ae8">&#9670;&#160;</a></span>column_sums()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output  = double, typename T , typename IDX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Output &gt; tatami::column_sums </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Output</td><td>Type of the output value. </td></tr>
    <tr><td class="paramname">T</td><td>Type of the matrix value, should be summable. </td></tr>
    <tr><td class="paramname">IDX</td><td>Type of the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of length equal to the number of columns, containing the column sums. </dd></dl>

</div>
</div>
<a id="a3d121e9c7c0ded4ba86382bd83abf103" name="a3d121e9c7c0ded4ba86382bd83abf103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d121e9c7c0ded4ba86382bd83abf103">&#9670;&#160;</a></span>row_sums()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output  = double, typename T , typename IDX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Output &gt; tatami::row_sums </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Output</td><td>Type of the output value. </td></tr>
    <tr><td class="paramname">T</td><td>Type of the matrix value, should be summable. </td></tr>
    <tr><td class="paramname">IDX</td><td>Type of the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of length equal to the number of rows, containing the row sums. </dd></dl>

</div>
</div>
<a id="a101a4123f87b6c4fd919004c2f3d3a91" name="a101a4123f87b6c4fd919004c2f3d3a91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a101a4123f87b6c4fd919004c2f3d3a91">&#9670;&#160;</a></span>column_variances()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output  = double, typename T , typename IDX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Output &gt; tatami::column_variances </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This uses the usual algorithm for matrices where <code><a class="el" href="classtatami_1_1Matrix.html#ac31ddc309419b4b2f6a2d0a01837e7a3">tatami::Matrix::prefer_rows()</a></code> is false, otherwise it uses Welford's algorithm. As a result, the computed variances will be slightly different (within numerical precision) for row- and column-major matrices.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Output</td><td>Type of the output value. </td></tr>
    <tr><td class="paramname">T</td><td>Type of the matrix value, should be numeric. </td></tr>
    <tr><td class="paramname">IDX</td><td>Type of the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of length equal to the number of columns, containing the column variances. </dd></dl>

</div>
</div>
<a id="a2aa54193cf4c92ace983cba8c118ca1a" name="a2aa54193cf4c92ace983cba8c118ca1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aa54193cf4c92ace983cba8c118ca1a">&#9670;&#160;</a></span>row_variances()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output  = double, typename T , typename IDX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Output &gt; tatami::row_variances </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This uses the usual algorithm for matrices where <code><a class="el" href="classtatami_1_1Matrix.html#ac31ddc309419b4b2f6a2d0a01837e7a3">tatami::Matrix::prefer_rows()</a></code> is true, otherwise it uses Welford's algorithm. As a result, the computed variances will be slightly different (within numerical precision) for row- and column-major matrices.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Output</td><td>Type of the output value. </td></tr>
    <tr><td class="paramname">T</td><td>Type of the matrix value, should be numeric. </td></tr>
    <tr><td class="paramname">IDX</td><td>Type of the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of length equal to the number of rows, containing the row variances. </dd></dl>

</div>
</div>
<a id="a87c52cf8a974ad0025550b002d391d39" name="a87c52cf8a974ad0025550b002d391d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87c52cf8a974ad0025550b002d391d39">&#9670;&#160;</a></span>bind_intersection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int margin, class <a class="el" href="classtatami_1_1Matrix.html">Matrix</a> , typename Id &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a> &gt;, std::vector&lt; size_t &gt; &gt; tatami::bind_intersection </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const Id * &gt; &amp;&#160;</td>
          <td class="paramname"><em>ids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Combine multiple matrices along the specified dimension while accounting for non-identical IDs along the other dimension. This function will identify the intersection of common identifiers across all matrices, subset each individual matrix to the intersection in the other dimension, and then combine them along the specified dimension.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">margin</td><td>The dimension to combine along - by rows (0) or columns (1). </td></tr>
    <tr><td class="paramname"><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></td><td>The <b>tatami</b> matrix class. </td></tr>
    <tr><td class="paramname">Id</td><td>Integer type representing the identifiers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputs</td><td>Vector of pointers to matrices to be combined along the dimension specified by <code>margin</code>. </td></tr>
    <tr><td class="paramname">ids</td><td>Vector of length equal to that of <code>inputs</code>, containing pointers to the identifiers for the matrices. Each pointer should refer to an array equal to the number of columns (if <code>margin = 0</code>) or rows (if <code>margin = 1</code>) in the corresponding entry of <code>inputs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair containing the combined matrix (first) and a vector of indices for the intersection (second). In the combined matrix, each column (if <code>margin = 0</code>) or row (if <code>margin = 1</code>) will correspond to an entry in the intersection vector. Indices in the intersection vector should be applied to <code>ids[0]</code> to obtain the actual identifiers of the rows/columns. </dd></dl>

</div>
</div>
<a id="ab17e92414b0bff60f7b7a6431ac8a330" name="ab17e92414b0bff60f7b7a6431ac8a330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab17e92414b0bff60f7b7a6431ac8a330">&#9670;&#160;</a></span>compress_sparse_triplets()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool ROW, class U , class V , class W &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; size_t &gt; tatami::compress_sparse_triplets </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">W &amp;&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ROW</td><td>Whether to create a compressed sparse row format. If <code>false</code>, the compressed sparse column format is used instead. </td></tr>
    <tr><td class="paramname">U</td><td>Random-access container for the values. </td></tr>
    <tr><td class="paramname">V</td><td>Random access container for the row indices. </td></tr>
    <tr><td class="paramname">W</td><td>Random access container for the column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nr</td><td>Number of rows. </td></tr>
    <tr><td class="paramname">nc</td><td>Number of columns. </td></tr>
    <tr><td class="paramname">rows</td><td>Row indices. Values must be non-negative integers less than <code>nr</code>. </td></tr>
    <tr><td class="paramname">cols</td><td>Column indices. Values must be non-negative integers less than <code>nc</code>. </td></tr>
    <tr><td class="paramname">values</td><td>Non-zero values.</td></tr>
  </table>
  </dd>
</dl>
<p><code>rows</code>, <code>cols</code> and <code>values</code> must be of the same length. Corresponding entries across these vectors are assumed to contain data for a single non-zero element.</p>
<dl class="section return"><dt>Returns</dt><dd><code>rows</code>, <code>cols</code> and <code>values</code> are sorted in-place by the row and column indices (if <code>ROW = true</code>) or by the column and row indices (if <code>ROW = false</code>). A vector of index pointers is returned with length <code>nr + 1</code> (if <code>ROW = true</code>) or <code>nc + 1</code> (if <code>ROW = false</code>). </dd></dl>

</div>
</div>
<a id="a5fd35b3b6f34a8b4965ef9a1cef6fc93" name="a5fd35b3b6f34a8b4965ef9a1cef6fc93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fd35b3b6f34a8b4965ef9a1cef6fc93">&#9670;&#160;</a></span>convert_to_dense() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool row, typename DataInterface  = double, typename Index  = int, typename DataStore  = DataInterface, class MatrixIn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; DataInterface, Index &gt; &gt; tatami::convert_to_dense </td>
          <td>(</td>
          <td class="paramtype">const MatrixIn *&#160;</td>
          <td class="paramname"><em>incoming</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">row</td><td>Whether to return a row-major matrix. </td></tr>
    <tr><td class="paramname">DataInterface</td><td>Type of data values in the output interface. </td></tr>
    <tr><td class="paramname">Index</td><td>Integer type for the indices in the output interface. </td></tr>
    <tr><td class="paramname">DataStore</td><td>Type of data values to be stored in the output. </td></tr>
    <tr><td class="paramname">MatrixIn</td><td>Input matrix class, most typically a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">incoming</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a new <code><a class="el" href="classtatami_1_1DenseMatrix.html" title="Dense matrix representation.">tatami::DenseMatrix</a></code> with the same dimensions and type as the matrix referenced by <code>incoming</code>. If <code>row = true</code>, the matrix is row-major, otherwise it is column-major. </dd></dl>

</div>
</div>
<a id="a9a1a033ef94ba9f52be54fbd86f85568" name="a9a1a033ef94ba9f52be54fbd86f85568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a1a033ef94ba9f52be54fbd86f85568">&#9670;&#160;</a></span>convert_to_dense() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataInterface  = double, typename Index  = int, typename DataStore  = DataInterface, class MatrixIn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; DataInterface, Index &gt; &gt; tatami::convert_to_dense </td>
          <td>(</td>
          <td class="paramtype">const MatrixIn *&#160;</td>
          <td class="paramname"><em>incoming</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This overload makes it easier to control the desired output order when it is not known at compile time.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataInterface</td><td>Type of data values in the output interface. </td></tr>
    <tr><td class="paramname">DataStore</td><td>Type of data values to be stored in the output. </td></tr>
    <tr><td class="paramname">Index</td><td>Integer type for the indices in the output interface. </td></tr>
    <tr><td class="paramname">MatrixIn</td><td>Input matrix class, most typically a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">incoming</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">order</td><td>Ordering of values in the output dense matrix - row-major (0) or column-major (1). If set to -1, the ordering is chosen based on <code><a class="el" href="classtatami_1_1Matrix.html#ac31ddc309419b4b2f6a2d0a01837e7a3">tatami::Matrix::prefer_rows()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a new <code><a class="el" href="classtatami_1_1DenseMatrix.html" title="Dense matrix representation.">tatami::DenseMatrix</a></code> with the same dimensions and type as the matrix referenced by <code>incoming</code>. </dd></dl>

</div>
</div>
<a id="a369c51892651351f16e24ae1dae68984" name="a369c51892651351f16e24ae1dae68984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a369c51892651351f16e24ae1dae68984">&#9670;&#160;</a></span>convert_to_sparse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool row, typename DataInterface  = double, typename IndexInterface  = int, typename DataStore  = DataInterface, typename IndexStore  = IndexInterface, class MatrixIn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; DataInterface, IndexInterface &gt; &gt; tatami::convert_to_sparse </td>
          <td>(</td>
          <td class="paramtype">const MatrixIn *&#160;</td>
          <td class="paramname"><em>incoming</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>reserve</em> = <code>0.1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">row</td><td>Whether to return a compressed sparse row matrix. </td></tr>
    <tr><td class="paramname">DataInterface</td><td>Type of data values in the output interface. </td></tr>
    <tr><td class="paramname">IndexInterface</td><td>Integer type for the indices in the output interface. </td></tr>
    <tr><td class="paramname">DataStore</td><td>Type of data values to be stored in the output. </td></tr>
    <tr><td class="paramname">IndexStore</td><td>Integer type for storing the indices in the output. </td></tr>
    <tr><td class="paramname">MatrixIn</td><td>Input matrix class, most typically a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">incoming</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>, possibly containing delayed operations. </td></tr>
    <tr><td class="paramname">reserve</td><td>The expected density of non-zero values in <code>incoming</code>. A slight overestimate will avoid reallocation of the temporary vectors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a new <code><a class="el" href="classtatami_1_1CompressedSparseMatrix.html" title="Compressed sparse matrix representation.">tatami::CompressedSparseMatrix</a></code>, with the same dimensions and type as the matrix referenced by <code>incoming</code>. If <code>row = true</code>, the matrix is compressed sparse row, otherwise it is compressed sparse column. </dd></dl>

</div>
</div>
<a id="a4d51ef21a7f65f0386b4bff00961f637" name="a4d51ef21a7f65f0386b4bff00961f637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d51ef21a7f65f0386b4bff00961f637">&#9670;&#160;</a></span>convert_to_sparse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataInterface  = double, typename IndexInterface  = int, typename DataStore  = DataInterface, typename IndexStore  = IndexInterface, class MatrixIn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; DataInterface, IndexInterface &gt; &gt; tatami::convert_to_sparse </td>
          <td>(</td>
          <td class="paramtype">const MatrixIn *&#160;</td>
          <td class="paramname"><em>incoming</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This overload makes it easier to control the desired output order when it is not known at compile time.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataInterface</td><td>Type of data values in the output interface. </td></tr>
    <tr><td class="paramname">IndexInterface</td><td>Integer type for the indices in the output interface. </td></tr>
    <tr><td class="paramname">DataStore</td><td>Type of data values to be stored in the output. </td></tr>
    <tr><td class="paramname">IndexStore</td><td>Integer type for storing the indices in the output. </td></tr>
    <tr><td class="paramname">MatrixIn</td><td>Input matrix class, most typically a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">incoming</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">order</td><td>Ordering of values in the output matrix - compressed sparse row (0) or column (1). If set to -1, the ordering is chosen based on <code><a class="el" href="classtatami_1_1Matrix.html#ac31ddc309419b4b2f6a2d0a01837e7a3">tatami::Matrix::prefer_rows()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a new <code><a class="el" href="classtatami_1_1CompressedSparseMatrix.html" title="Compressed sparse matrix representation.">tatami::CompressedSparseMatrix</a></code>, with the same dimensions and type as the matrix referenced by <code>incoming</code>. </dd></dl>

</div>
</div>
<a id="a7518f5e8e09a6f6d7d3955b8ea286689" name="a7518f5e8e09a6f6d7d3955b8ea286689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7518f5e8e09a6f6d7d3955b8ea286689">&#9670;&#160;</a></span>wrap_shared_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; &gt; tatami::wrap_shared_ptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrap a raw pointer inside a <code>shared_ptr</code>, typically to enable use of a raw <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code> pointer with delayed operation wrappers. This enables use of delayed operations inside functions that accept a raw pointer to an externally owned <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to the same object addressed by <code>ptr</code>. The assumption is that <code>ptr</code> will always outlive the returned pointer. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
