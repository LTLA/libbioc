<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tatami: tatami Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tatami
   </div>
   <div id="projectbrief">C++ API for different matrix representations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">tatami Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Flexible representations for matrix data.  
<a href="namespacetatami.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacetatami_1_1MatrixMarket"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami_1_1MatrixMarket.html">MatrixMarket</a></td></tr>
<tr class="memdesc:namespacetatami_1_1MatrixMarket"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classes and utilites to handle <a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a> Market files. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1ArrayView.html">ArrayView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">View into a pre-allocated array.  <a href="classtatami_1_1ArrayView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1BlockExtractor.html">BlockExtractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual base class for block access.  <a href="structtatami_1_1BlockExtractor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1CompressedSparseMatrix.html">CompressedSparseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compressed sparse matrix representation.  <a href="classtatami_1_1CompressedSparseMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1ConsecutiveOracle.html">ConsecutiveOracle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predict future accesses of a consecutive sequence.  <a href="structtatami_1_1ConsecutiveOracle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedAbsHelper.html">DelayedAbsHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the absolute value of a matrix entry.  <a href="structtatami_1_1DelayedAbsHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedAddScalarHelper.html">DelayedAddScalarHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a scalar to all values of a matrix.  <a href="structtatami_1_1DelayedAddScalarHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedAddVectorHelper.html">DelayedAddVectorHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a vector along the rows or columns of a matrix.  <a href="structtatami_1_1DelayedAddVectorHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedBind.html">DelayedBind</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed combining of a matrix.  <a href="classtatami_1_1DelayedBind.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedCast.html">DelayedCast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recast a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> to a different interface type.  <a href="classtatami_1_1DelayedCast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedDivideScalarHelper.html">DelayedDivideScalarHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide a scalar from all values of a matrix, or vice versa.  <a href="structtatami_1_1DelayedDivideScalarHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedDivideVectorHelper.html">DelayedDivideVectorHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide the rows/columns of a matrix by a vector, or vice versa.  <a href="structtatami_1_1DelayedDivideVectorHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedExpHelper.html">DelayedExpHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a matrix entry as an exponent.  <a href="structtatami_1_1DelayedExpHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedIsometricOp.html">DelayedIsometricOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed isometric operations on a matrix.  <a href="classtatami_1_1DelayedIsometricOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedLog1pHelper.html">DelayedLog1pHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the logarithm of a matrix entry plus 1.  <a href="structtatami_1_1DelayedLog1pHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedLogHelper.html">DelayedLogHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the logarithm of a matrix entry.  <a href="structtatami_1_1DelayedLogHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedMultiplyScalarHelper.html">DelayedMultiplyScalarHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a scalar with all values of a matrix.  <a href="structtatami_1_1DelayedMultiplyScalarHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedMultiplyVectorHelper.html">DelayedMultiplyVectorHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a vector along the rows or columns of a matrix.  <a href="structtatami_1_1DelayedMultiplyVectorHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedRoundHelper.html">DelayedRoundHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round a matrix entry to the nearest integer.  <a href="structtatami_1_1DelayedRoundHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedSqrtHelper.html">DelayedSqrtHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the square root of a matrix entry.  <a href="structtatami_1_1DelayedSqrtHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedSubset.html">DelayedSubset</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed subsetting of a matrix with general indices.  <a href="classtatami_1_1DelayedSubset.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedSubsetBlock.html">DelayedSubsetBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed subsetting to a contiguous block.  <a href="classtatami_1_1DelayedSubsetBlock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedSubsetSorted.html">DelayedSubsetSorted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed subsetting of a matrix with sorted indices.  <a href="classtatami_1_1DelayedSubsetSorted.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html">DelayedSubsetSortedUnique</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed subsetting of a matrix with sorted, unique indices.  <a href="classtatami_1_1DelayedSubsetSortedUnique.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedSubsetUnique.html">DelayedSubsetUnique</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed subsetting of a matrix with unique indices.  <a href="classtatami_1_1DelayedSubsetUnique.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedSubtractScalarHelper.html">DelayedSubtractScalarHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract a scalar from all values of a matrix, or vice versa.  <a href="structtatami_1_1DelayedSubtractScalarHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedSubtractVectorHelper.html">DelayedSubtractVectorHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract a vector from the rows/columns of a matrix, or vice versa.  <a href="structtatami_1_1DelayedSubtractVectorHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedTranspose.html">DelayedTranspose</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed transposition of a matrix.  <a href="classtatami_1_1DelayedTranspose.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DenseExtractor.html">DenseExtractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual base class for dense extraction.  <a href="classtatami_1_1DenseExtractor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DenseMatrix.html">DenseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dense matrix representation.  <a href="classtatami_1_1DenseMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1ExtractorBase.html">ExtractorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual base extractor class.  <a href="structtatami_1_1ExtractorBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1FixedOracle.html">FixedOracle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predict future accesses from a known sequence.  <a href="structtatami_1_1FixedOracle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1FullExtractor.html">FullExtractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual base class for full access.  <a href="structtatami_1_1FullExtractor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1IndexExtractor.html">IndexExtractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual base class for indexed access.  <a href="structtatami_1_1IndexExtractor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1LayeredMatrixData.html">LayeredMatrixData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer and permutations for a layered sparse matrix.  <a href="structtatami_1_1LayeredMatrixData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html">Matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual class for a matrix with a defined type.  <a href="classtatami_1_1Matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1Options.html">Options</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structtatami_1_1Options.html" title="Options for iteration and extraction.">Options</a> for iteration and extraction.  <a href="structtatami_1_1Options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1Oracle.html">Oracle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predict future access requests.  <a href="structtatami_1_1Oracle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1OracleStream.html">OracleStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream predictions from the oracle.  <a href="structtatami_1_1OracleStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1SemiCompressedSparseMatrix.html">SemiCompressedSparseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Semi-compressed sparse matrix representation.  <a href="classtatami_1_1SemiCompressedSparseMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1SomeNumericArray.html">SomeNumericArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of some numeric type, determined at runtime.  <a href="structtatami_1_1SomeNumericArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1SparseExtractor.html">SparseExtractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual base class for sparse extraction.  <a href="classtatami_1_1SparseExtractor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A range of a sparse vector.  <a href="structtatami_1_1SparseRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1SparseRangeCopy.html">SparseRangeCopy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A range of a sparse vector with copying.  <a href="structtatami_1_1SparseRangeCopy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1VirtualDenseMatrix.html">VirtualDenseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual class for a dense matrix with a defined type.  <a href="classtatami_1_1VirtualDenseMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac47a769e00660eb7e9b5fcd543bcf2d3"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_  = int, class Storage_  = std::vector&lt;Value_&gt;&gt; </td></tr>
<tr class="memitem:ac47a769e00660eb7e9b5fcd543bcf2d3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ac47a769e00660eb7e9b5fcd543bcf2d3">DenseColumnMatrix</a> = <a class="el" href="classtatami_1_1DenseMatrix.html">DenseMatrix</a>&lt; false, Value_, Index_, Storage_ &gt;</td></tr>
<tr class="separator:ac47a769e00660eb7e9b5fcd543bcf2d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51122d20490b377cd3f4609cc044f314"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_  = int, class Storage_  = std::vector&lt;Value_&gt;&gt; </td></tr>
<tr class="memitem:a51122d20490b377cd3f4609cc044f314"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a51122d20490b377cd3f4609cc044f314">DenseRowMatrix</a> = <a class="el" href="classtatami_1_1DenseMatrix.html">DenseMatrix</a>&lt; true, Value_, Index_, Storage_ &gt;</td></tr>
<tr class="separator:a51122d20490b377cd3f4609cc044f314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ed61a4f772a2f7be4a12f739554e6e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#a0a2ecaf58e2b69bb4a808e814aeb16a1">DimensionSelectionType</a> selection_, typename Index_ &gt; </td></tr>
<tr class="memitem:a85ed61a4f772a2f7be4a12f739554e6e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a85ed61a4f772a2f7be4a12f739554e6e">ConditionalSelectionExtractor</a> = typename std::conditional&lt; selection_==DimensionSelectionType::FULL, <a class="el" href="structtatami_1_1FullExtractor.html">FullExtractor</a>&lt; Index_ &gt;, typename std::conditional&lt; selection_==DimensionSelectionType::BLOCK, <a class="el" href="structtatami_1_1BlockExtractor.html">BlockExtractor</a>&lt; Index_ &gt;, <a class="el" href="structtatami_1_1IndexExtractor.html">IndexExtractor</a>&lt; Index_ &gt; &gt;::type &gt;::type</td></tr>
<tr class="separator:a85ed61a4f772a2f7be4a12f739554e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f8db5316521603085577d977a6955f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#a0a2ecaf58e2b69bb4a808e814aeb16a1">DimensionSelectionType</a> selection_, bool sparse_, typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:ae9f8db5316521603085577d977a6955f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ae9f8db5316521603085577d977a6955f">Extractor</a> = typename std::conditional&lt; sparse_, <a class="el" href="classtatami_1_1SparseExtractor.html">SparseExtractor</a>&lt; selection_, Value_, Index_ &gt;, <a class="el" href="classtatami_1_1DenseExtractor.html">DenseExtractor</a>&lt; selection_, Value_, Index_ &gt; &gt;::type</td></tr>
<tr class="separator:ae9f8db5316521603085577d977a6955f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6008dbced6de41e5619156b5335f5762"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a6008dbced6de41e5619156b5335f5762"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a6008dbced6de41e5619156b5335f5762">FullDenseExtractor</a> = <a class="el" href="namespacetatami.html#ae9f8db5316521603085577d977a6955f">Extractor</a>&lt; DimensionSelectionType::FULL, false, Value_, Index_ &gt;</td></tr>
<tr class="separator:a6008dbced6de41e5619156b5335f5762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75de1fc78b7d361ea8b59a5379ea4da"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:ae75de1fc78b7d361ea8b59a5379ea4da"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ae75de1fc78b7d361ea8b59a5379ea4da">BlockDenseExtractor</a> = <a class="el" href="namespacetatami.html#ae9f8db5316521603085577d977a6955f">Extractor</a>&lt; DimensionSelectionType::BLOCK, false, Value_, Index_ &gt;</td></tr>
<tr class="separator:ae75de1fc78b7d361ea8b59a5379ea4da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ce406c32c3914c2ecce187e21b6ced"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a47ce406c32c3914c2ecce187e21b6ced"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a47ce406c32c3914c2ecce187e21b6ced">IndexDenseExtractor</a> = <a class="el" href="namespacetatami.html#ae9f8db5316521603085577d977a6955f">Extractor</a>&lt; DimensionSelectionType::INDEX, false, Value_, Index_ &gt;</td></tr>
<tr class="separator:a47ce406c32c3914c2ecce187e21b6ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fbb0624c8e1913a87e8fb5c975400e1"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a0fbb0624c8e1913a87e8fb5c975400e1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a0fbb0624c8e1913a87e8fb5c975400e1">FullSparseExtractor</a> = <a class="el" href="namespacetatami.html#ae9f8db5316521603085577d977a6955f">Extractor</a>&lt; DimensionSelectionType::FULL, true, Value_, Index_ &gt;</td></tr>
<tr class="separator:a0fbb0624c8e1913a87e8fb5c975400e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d0024399a66ce61f6315f5f46ebb63"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:ac8d0024399a66ce61f6315f5f46ebb63"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ac8d0024399a66ce61f6315f5f46ebb63">BlockSparseExtractor</a> = <a class="el" href="namespacetatami.html#ae9f8db5316521603085577d977a6955f">Extractor</a>&lt; DimensionSelectionType::BLOCK, true, Value_, Index_ &gt;</td></tr>
<tr class="separator:ac8d0024399a66ce61f6315f5f46ebb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b67b4d1b6c00cd0bd449703432a5f7b"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a4b67b4d1b6c00cd0bd449703432a5f7b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a4b67b4d1b6c00cd0bd449703432a5f7b">IndexSparseExtractor</a> = <a class="el" href="namespacetatami.html#ae9f8db5316521603085577d977a6955f">Extractor</a>&lt; DimensionSelectionType::INDEX, true, Value_, Index_ &gt;</td></tr>
<tr class="separator:a4b67b4d1b6c00cd0bd449703432a5f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c670894994f1d620abb55953f98441"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a35c670894994f1d620abb55953f98441">NumericMatrix</a> = <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; double, int &gt;</td></tr>
<tr class="separator:a35c670894994f1d620abb55953f98441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18cee3a5d9734f0092b03d023cfe4b6a"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ , class ValueStorage_  = std::vector&lt;Value_&gt;, class IndexStorage_  = std::vector&lt;Index_&gt;, class PointerStorage_  = std::vector&lt;size_t&gt;&gt; </td></tr>
<tr class="memitem:a18cee3a5d9734f0092b03d023cfe4b6a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a18cee3a5d9734f0092b03d023cfe4b6a">CompressedSparseColumnMatrix</a> = <a class="el" href="classtatami_1_1CompressedSparseMatrix.html">CompressedSparseMatrix</a>&lt; false, Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</td></tr>
<tr class="separator:a18cee3a5d9734f0092b03d023cfe4b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0111adeeb583aeb7e24e9e1e25be4aa0"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ , class ValueStorage_  = std::vector&lt;Value_&gt;, class IndexStorage_  = std::vector&lt;Index_&gt;, class PointerStorage_  = std::vector&lt;size_t&gt;&gt; </td></tr>
<tr class="memitem:a0111adeeb583aeb7e24e9e1e25be4aa0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a0111adeeb583aeb7e24e9e1e25be4aa0">CompressedSparseRowMatrix</a> = <a class="el" href="classtatami_1_1CompressedSparseMatrix.html">CompressedSparseMatrix</a>&lt; true, Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</td></tr>
<tr class="separator:a0111adeeb583aeb7e24e9e1e25be4aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f03d0d880bc056e09c2cbb80eb2c2ec"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ , class IndexStorage_  = std::vector&lt;Index_&gt;, class PointerStorage_  = std::vector&lt;size_t&gt;&gt; </td></tr>
<tr class="memitem:a6f03d0d880bc056e09c2cbb80eb2c2ec"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a6f03d0d880bc056e09c2cbb80eb2c2ec">SemiCompressedSparseColumnMatrix</a> = <a class="el" href="classtatami_1_1SemiCompressedSparseMatrix.html">SemiCompressedSparseMatrix</a>&lt; false, Value_, Index_, IndexStorage_, PointerStorage_ &gt;</td></tr>
<tr class="separator:a6f03d0d880bc056e09c2cbb80eb2c2ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412cb6ee12f3ee81d404d6eb0e494e4d"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ , class IndexStorage_  = std::vector&lt;Index_&gt;, class PointerStorage_  = std::vector&lt;size_t&gt;&gt; </td></tr>
<tr class="memitem:a412cb6ee12f3ee81d404d6eb0e494e4d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a412cb6ee12f3ee81d404d6eb0e494e4d">SemiCompressedSparseRowMatrix</a> = <a class="el" href="classtatami_1_1SemiCompressedSparseMatrix.html">SemiCompressedSparseMatrix</a>&lt; true, Value_, Index_, IndexStorage_, PointerStorage_ &gt;</td></tr>
<tr class="separator:a412cb6ee12f3ee81d404d6eb0e494e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b84d6bc16ba8e78d7bebf95d78b6221"><td class="memTemplParams" colspan="2"><a id="a2b84d6bc16ba8e78d7bebf95d78b6221" name="a2b84d6bc16ba8e78d7bebf95d78b6221"></a>
template&lt;class Storage_ &gt; </td></tr>
<tr class="memitem:a2b84d6bc16ba8e78d7bebf95d78b6221"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Stored</b> = typename std::remove_reference&lt; decltype(std::declval&lt; Storage_ &gt;()[0])&gt;::type</td></tr>
<tr class="separator:a2b84d6bc16ba8e78d7bebf95d78b6221"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a0a2ecaf58e2b69bb4a808e814aeb16a1"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a0a2ecaf58e2b69bb4a808e814aeb16a1">DimensionSelectionType</a> : char { <b>FULL</b>
, <b>BLOCK</b>
, <b>INDEX</b>
 }</td></tr>
<tr class="separator:a0a2ecaf58e2b69bb4a808e814aeb16a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af9d13ceaa112d2c091265510d741488d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#a0a2ecaf58e2b69bb4a808e814aeb16a1">DimensionSelectionType</a> selection_, typename Index_ &gt; </td></tr>
<tr class="memitem:af9d13ceaa112d2c091265510d741488d"><td class="memTemplItemLeft" align="right" valign="top">Index_&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#af9d13ceaa112d2c091265510d741488d">extracted_length</a> (const <a class="el" href="namespacetatami.html#a85ed61a4f772a2f7be4a12f739554e6e">ConditionalSelectionExtractor</a>&lt; selection_, Index_ &gt; &amp;ex)</td></tr>
<tr class="separator:af9d13ceaa112d2c091265510d741488d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa82419090e54a4674d971429e93e6af5"><td class="memTemplParams" colspan="2">template&lt;int MARGIN, typename T  = double, class V  = std::vector&lt;T&gt;&gt; </td></tr>
<tr class="memitem:aa82419090e54a4674d971429e93e6af5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedAddVectorHelper.html">DelayedAddVectorHelper</a>&lt; MARGIN, T, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#aa82419090e54a4674d971429e93e6af5">make_DelayedAddVectorHelper</a> (V v)</td></tr>
<tr class="separator:aa82419090e54a4674d971429e93e6af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb68a8d27e821f213965edab7f029c48"><td class="memTemplParams" colspan="2">template&lt;bool RIGHT, int MARGIN, typename T  = double, class V  = std::vector&lt;T&gt;&gt; </td></tr>
<tr class="memitem:abb68a8d27e821f213965edab7f029c48"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedSubtractVectorHelper.html">DelayedSubtractVectorHelper</a>&lt; RIGHT, MARGIN, T, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#abb68a8d27e821f213965edab7f029c48">make_DelayedSubtractVectorHelper</a> (V v)</td></tr>
<tr class="separator:abb68a8d27e821f213965edab7f029c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a316f4cf0ae5a9e83c2dad6ccbbbcfb43"><td class="memTemplParams" colspan="2">template&lt;int MARGIN, typename T  = double, class V  = std::vector&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a316f4cf0ae5a9e83c2dad6ccbbbcfb43"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedMultiplyVectorHelper.html">DelayedMultiplyVectorHelper</a>&lt; MARGIN, T, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a316f4cf0ae5a9e83c2dad6ccbbbcfb43">make_DelayedMultiplyVectorHelper</a> (V v)</td></tr>
<tr class="separator:a316f4cf0ae5a9e83c2dad6ccbbbcfb43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab104e5029db4d09afe0b47a125f457bf"><td class="memTemplParams" colspan="2">template&lt;bool RIGHT, int MARGIN, typename T  = double, class V  = std::vector&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ab104e5029db4d09afe0b47a125f457bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedDivideVectorHelper.html">DelayedDivideVectorHelper</a>&lt; RIGHT, MARGIN, T, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ab104e5029db4d09afe0b47a125f457bf">make_DelayedDivideVectorHelper</a> (V v)</td></tr>
<tr class="separator:ab104e5029db4d09afe0b47a125f457bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e92d6c4eb0b1303b02176aa1d016a0"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ , class Operation_ &gt; </td></tr>
<tr class="memitem:a70e92d6c4eb0b1303b02176aa1d016a0"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a70e92d6c4eb0b1303b02176aa1d016a0">make_DelayedIsometricOp</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; p, Operation_ op)</td></tr>
<tr class="separator:a70e92d6c4eb0b1303b02176aa1d016a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8e0f69139575707aa9314174b415b3"><td class="memTemplParams" colspan="2">template&lt;int margin_, typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a5f8e0f69139575707aa9314174b415b3"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a5f8e0f69139575707aa9314174b415b3">make_DelayedBind</a> (std::vector&lt; std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; &gt; ps)</td></tr>
<tr class="separator:a5f8e0f69139575707aa9314174b415b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca62c3bf751cdd06a08e8e503b0b591a"><td class="memTemplParams" colspan="2">template&lt;typename Value_out_ , typename Index_out_ , typename Value_in_ , typename Index_in_ &gt; </td></tr>
<tr class="memitem:aca62c3bf751cdd06a08e8e503b0b591a"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_out_, Index_out_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#aca62c3bf751cdd06a08e8e503b0b591a">make_DelayedCast</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_in_, Index_in_ &gt; &gt; p)</td></tr>
<tr class="separator:aca62c3bf751cdd06a08e8e503b0b591a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa35d8e9fe286967f327ec0eb6bd5005"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:afa35d8e9fe286967f327ec0eb6bd5005"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#afa35d8e9fe286967f327ec0eb6bd5005">make_DelayedTranspose</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; p)</td></tr>
<tr class="separator:afa35d8e9fe286967f327ec0eb6bd5005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f4aafc0a1fbdc0c31bc122d24122a63"><td class="memTemplParams" colspan="2">template&lt;int margin_, typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a8f4aafc0a1fbdc0c31bc122d24122a63"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a8f4aafc0a1fbdc0c31bc122d24122a63">make_DelayedSubsetBlock</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; p, Index_ f, Index_ l)</td></tr>
<tr class="separator:a8f4aafc0a1fbdc0c31bc122d24122a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc63177b00e6e3e2fa47754b8d87704"><td class="memTemplParams" colspan="2">template&lt;int margin_, typename Value_ , typename Index_ , class IndexStorage_ &gt; </td></tr>
<tr class="memitem:abfc63177b00e6e3e2fa47754b8d87704"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#abfc63177b00e6e3e2fa47754b8d87704">make_DelayedSubset</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; p, IndexStorage_ idx)</td></tr>
<tr class="separator:abfc63177b00e6e3e2fa47754b8d87704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b6638dceda82d82a7579dc88a45709"><td class="memTemplParams" colspan="2">template&lt;bool row_, bool sparse_, typename Value_ , typename Index_ , typename ... Args_&gt; </td></tr>
<tr class="memitem:a95b6638dceda82d82a7579dc88a45709"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a95b6638dceda82d82a7579dc88a45709">new_extractor</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *ptr, Args_ &amp;&amp;... args)</td></tr>
<tr class="separator:a95b6638dceda82d82a7579dc88a45709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44202790861791b1ed9df6d480c69f6a"><td class="memTemplParams" colspan="2">template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a44202790861791b1ed9df6d480c69f6a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Output_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a44202790861791b1ed9df6d480c69f6a">column_medians</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *p, int threads=1)</td></tr>
<tr class="separator:a44202790861791b1ed9df6d480c69f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab877f67694b3fa500f59469f044b1c01"><td class="memTemplParams" colspan="2">template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:ab877f67694b3fa500f59469f044b1c01"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Output_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ab877f67694b3fa500f59469f044b1c01">row_medians</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *p, int threads=1)</td></tr>
<tr class="separator:ab877f67694b3fa500f59469f044b1c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8102a2423efab5e329543f4235ac2290"><td class="memTemplParams" colspan="2">template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a8102a2423efab5e329543f4235ac2290"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Output_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a8102a2423efab5e329543f4235ac2290">column_maxs</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *p, int threads=1)</td></tr>
<tr class="separator:a8102a2423efab5e329543f4235ac2290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47890bfd538f65971f9e5dba5e1ed785"><td class="memTemplParams" colspan="2">template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a47890bfd538f65971f9e5dba5e1ed785"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Output_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a47890bfd538f65971f9e5dba5e1ed785">row_maxs</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *p, int threads=1)</td></tr>
<tr class="separator:a47890bfd538f65971f9e5dba5e1ed785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e44772f82183100c7c25c181479b56"><td class="memTemplParams" colspan="2">template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a60e44772f82183100c7c25c181479b56"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Output_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a60e44772f82183100c7c25c181479b56">column_mins</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *p, int threads=1)</td></tr>
<tr class="separator:a60e44772f82183100c7c25c181479b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bcdcb0499b36b5b844ebd88fc30eefe"><td class="memTemplParams" colspan="2">template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a3bcdcb0499b36b5b844ebd88fc30eefe"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Output_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a3bcdcb0499b36b5b844ebd88fc30eefe">row_mins</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *p, int threads=1)</td></tr>
<tr class="separator:a3bcdcb0499b36b5b844ebd88fc30eefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5eff79824930c458e730d23f640c1ab"><td class="memTemplParams" colspan="2">template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:ab5eff79824930c458e730d23f640c1ab"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; Output_ &gt;, std::vector&lt; Output_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ab5eff79824930c458e730d23f640c1ab">column_ranges</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *p, int threads=1)</td></tr>
<tr class="separator:ab5eff79824930c458e730d23f640c1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2475a166ad744b31b1275e26e562be"><td class="memTemplParams" colspan="2">template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a2b2475a166ad744b31b1275e26e562be"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; Output_ &gt;, std::vector&lt; Output_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a2b2475a166ad744b31b1275e26e562be">row_ranges</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *p, int threads=1)</td></tr>
<tr class="separator:a2b2475a166ad744b31b1275e26e562be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aab6733d637b66abdf45f7300d2e1ba"><td class="memTemplParams" colspan="2">template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a3aab6733d637b66abdf45f7300d2e1ba"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Output_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a3aab6733d637b66abdf45f7300d2e1ba">column_sums</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *p, int threads=1)</td></tr>
<tr class="separator:a3aab6733d637b66abdf45f7300d2e1ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a658059404691856bef57fb85d83d6"><td class="memTemplParams" colspan="2">template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a53a658059404691856bef57fb85d83d6"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Output_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a53a658059404691856bef57fb85d83d6">row_sums</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *p, int threads=1)</td></tr>
<tr class="separator:a53a658059404691856bef57fb85d83d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ce7a2219ea60d45de1aa3d4de66063"><td class="memTemplParams" colspan="2">template&lt;bool parallel_ = true, class Function_ &gt; </td></tr>
<tr class="memitem:a29ce7a2219ea60d45de1aa3d4de66063"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a29ce7a2219ea60d45de1aa3d4de66063">parallelize</a> (Function_ fun, size_t tasks, size_t threads)</td></tr>
<tr class="separator:a29ce7a2219ea60d45de1aa3d4de66063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c6ecf33bcb87e1ed33c0a7d744dd82"><td class="memTemplParams" colspan="2">template&lt;bool row_, bool sparse_, typename Value_ , typename Index_ , typename ... Args_&gt; </td></tr>
<tr class="memitem:a36c6ecf33bcb87e1ed33c0a7d744dd82"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a36c6ecf33bcb87e1ed33c0a7d744dd82">consecutive_extractor</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *mat, Index_ iter_start, Index_ iter_length, Args_ &amp;&amp;... args)</td></tr>
<tr class="separator:a36c6ecf33bcb87e1ed33c0a7d744dd82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac37af9a76d15f08a3634881696a27f65"><td class="memTemplParams" colspan="2">template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:ac37af9a76d15f08a3634881696a27f65"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Output_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ac37af9a76d15f08a3634881696a27f65">column_variances</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *p, int threads=1)</td></tr>
<tr class="separator:ac37af9a76d15f08a3634881696a27f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab806279616e19f6150376a7c07d5b64b"><td class="memTemplParams" colspan="2">template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:ab806279616e19f6150376a7c07d5b64b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Output_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ab806279616e19f6150376a7c07d5b64b">row_variances</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *p, int threads=1)</td></tr>
<tr class="separator:ab806279616e19f6150376a7c07d5b64b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c52cf8a974ad0025550b002d391d39"><td class="memTemplParams" colspan="2">template&lt;int margin, class <a class="el" href="classtatami_1_1Matrix.html">Matrix</a> , typename Id &gt; </td></tr>
<tr class="memitem:a87c52cf8a974ad0025550b002d391d39"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a> &gt;, std::vector&lt; size_t &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a87c52cf8a974ad0025550b002d391d39">bind_intersection</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a> &gt; &gt; &amp;inputs, const std::vector&lt; const Id * &gt; &amp;ids)</td></tr>
<tr class="separator:a87c52cf8a974ad0025550b002d391d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17e92414b0bff60f7b7a6431ac8a330"><td class="memTemplParams" colspan="2">template&lt;bool ROW, class U , class V , class W &gt; </td></tr>
<tr class="memitem:ab17e92414b0bff60f7b7a6431ac8a330"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ab17e92414b0bff60f7b7a6431ac8a330">compress_sparse_triplets</a> (size_t nr, size_t nc, U &amp;values, V &amp;rows, W &amp;cols)</td></tr>
<tr class="separator:ab17e92414b0bff60f7b7a6431ac8a330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaccb18d22f35a4ed6b6a7091342da06"><td class="memTemplParams" colspan="2">template&lt;bool row_, typename StoredValue_ , class Matrix_ &gt; </td></tr>
<tr class="memitem:afaccb18d22f35a4ed6b6a7091342da06"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#afaccb18d22f35a4ed6b6a7091342da06">convert_to_dense</a> (const Matrix_ *incoming, StoredValue_ *store, int threads=1)</td></tr>
<tr class="separator:afaccb18d22f35a4ed6b6a7091342da06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80143ac537339fe8dafd892632e96de"><td class="memTemplParams" colspan="2">template&lt;bool row_, typename Value_  = double, typename Index  = int, typename StoredValue_  = Value_, class Matrix_ &gt; </td></tr>
<tr class="memitem:af80143ac537339fe8dafd892632e96de"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#af80143ac537339fe8dafd892632e96de">convert_to_dense</a> (const Matrix_ *incoming, int threads=1)</td></tr>
<tr class="separator:af80143ac537339fe8dafd892632e96de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e8745f8aaaa5ad93c6ce65a0a6591e"><td class="memTemplParams" colspan="2">template&lt;typename Value_  = double, typename Index_  = int, typename StoredValue_  = Value_, class Matrix_ &gt; </td></tr>
<tr class="memitem:a64e8745f8aaaa5ad93c6ce65a0a6591e"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a64e8745f8aaaa5ad93c6ce65a0a6591e">convert_to_dense</a> (const Matrix_ *incoming, int order, int threads=1)</td></tr>
<tr class="separator:a64e8745f8aaaa5ad93c6ce65a0a6591e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220c47e470b3ade64ede7303e50ca92d"><td class="memTemplParams" colspan="2">template&lt;bool row_, typename Value_  = double, typename Index_  = int, typename StoredValue_  = Value_, typename StoredIndex_  = Index_, class InputMatrix_ &gt; </td></tr>
<tr class="memitem:a220c47e470b3ade64ede7303e50ca92d"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a220c47e470b3ade64ede7303e50ca92d">convert_to_sparse</a> (const InputMatrix_ *incoming, int threads=1)</td></tr>
<tr class="separator:a220c47e470b3ade64ede7303e50ca92d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5847f3cd78ce89170ca43262d7f5f8e3"><td class="memTemplParams" colspan="2">template&lt;typename Value_  = double, typename Index_  = int, typename StoredValue_  = Value_, typename StoredIndex_  = Index_, class InputMatrix_ &gt; </td></tr>
<tr class="memitem:a5847f3cd78ce89170ca43262d7f5f8e3"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a5847f3cd78ce89170ca43262d7f5f8e3">convert_to_sparse</a> (const InputMatrix_ *incoming, int order, int threads=1)</td></tr>
<tr class="separator:a5847f3cd78ce89170ca43262d7f5f8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7518f5e8e09a6f6d7d3955b8ea286689"><td class="memTemplParams" colspan="2">template&lt;typename T , typename IDX &gt; </td></tr>
<tr class="memitem:a7518f5e8e09a6f6d7d3955b8ea286689"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a7518f5e8e09a6f6d7d3955b8ea286689">wrap_shared_ptr</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; *ptr)</td></tr>
<tr class="separator:a7518f5e8e09a6f6d7d3955b8ea286689"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Flexible representations for matrix data. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ac47a769e00660eb7e9b5fcd543bcf2d3" name="ac47a769e00660eb7e9b5fcd543bcf2d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac47a769e00660eb7e9b5fcd543bcf2d3">&#9670;&#160;</a></span>DenseColumnMatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_  = int, class Storage_  = std::vector&lt;Value_&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetatami.html#ac47a769e00660eb7e9b5fcd543bcf2d3">tatami::DenseColumnMatrix</a> = typedef <a class="el" href="classtatami_1_1DenseMatrix.html">DenseMatrix</a>&lt;false, Value_, Index_, Storage_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Column-major matrix. See <code><a class="el" href="classtatami_1_1DenseMatrix.html" title="Dense matrix representation.">tatami::DenseMatrix</a></code> for details on the template parameters. </p>

</div>
</div>
<a id="a51122d20490b377cd3f4609cc044f314" name="a51122d20490b377cd3f4609cc044f314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51122d20490b377cd3f4609cc044f314">&#9670;&#160;</a></span>DenseRowMatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_  = int, class Storage_  = std::vector&lt;Value_&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetatami.html#a51122d20490b377cd3f4609cc044f314">tatami::DenseRowMatrix</a> = typedef <a class="el" href="classtatami_1_1DenseMatrix.html">DenseMatrix</a>&lt;true, Value_, Index_, Storage_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Row-major matrix. See <code><a class="el" href="classtatami_1_1DenseMatrix.html" title="Dense matrix representation.">tatami::DenseMatrix</a></code> for details on the template parameters. </p>

</div>
</div>
<a id="a85ed61a4f772a2f7be4a12f739554e6e" name="a85ed61a4f772a2f7be4a12f739554e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ed61a4f772a2f7be4a12f739554e6e">&#9670;&#160;</a></span>ConditionalSelectionExtractor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#a0a2ecaf58e2b69bb4a808e814aeb16a1">DimensionSelectionType</a> selection_, typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetatami.html#a85ed61a4f772a2f7be4a12f739554e6e">tatami::ConditionalSelectionExtractor</a> = typedef typename std::conditional&lt; selection_ == DimensionSelectionType::FULL, <a class="el" href="structtatami_1_1FullExtractor.html">FullExtractor</a>&lt;Index_&gt;, typename std::conditional&lt; selection_ == DimensionSelectionType::BLOCK, <a class="el" href="structtatami_1_1BlockExtractor.html">BlockExtractor</a>&lt;Index_&gt;, <a class="el" href="structtatami_1_1IndexExtractor.html">IndexExtractor</a>&lt;Index_&gt; &gt;::type &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">selection_</td><td>Type of selection along the extraction dimension. </td></tr>
    <tr><td class="paramname">Index_</td><td>Row/column index type, should be integer.</td></tr>
  </table>
  </dd>
</dl>
<p>Conditional extractor interface that depends on the selection type. </p>

</div>
</div>
<a id="ae9f8db5316521603085577d977a6955f" name="ae9f8db5316521603085577d977a6955f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9f8db5316521603085577d977a6955f">&#9670;&#160;</a></span>Extractor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#a0a2ecaf58e2b69bb4a808e814aeb16a1">DimensionSelectionType</a> selection_, bool sparse_, typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetatami.html#ae9f8db5316521603085577d977a6955f">tatami::Extractor</a> = typedef typename std::conditional&lt;sparse_, <a class="el" href="classtatami_1_1SparseExtractor.html">SparseExtractor</a>&lt;selection_, Value_, Index_&gt;, <a class="el" href="classtatami_1_1DenseExtractor.html">DenseExtractor</a>&lt;selection_, Value_, Index_&gt; &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">selection_</td><td>Type of selection on the extraction dimension. </td></tr>
    <tr><td class="paramname">sparse_</td><td>Whether to perform sparse retrieval. </td></tr>
    <tr><td class="paramname">Value_</td><td>Data value type, should be numeric. </td></tr>
    <tr><td class="paramname">Index_</td><td>Row/column index type, should be integer.</td></tr>
  </table>
  </dd>
</dl>
<p>Conditional extractor interface that depends on the format type. </p>

</div>
</div>
<a id="a6008dbced6de41e5619156b5335f5762" name="a6008dbced6de41e5619156b5335f5762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6008dbced6de41e5619156b5335f5762">&#9670;&#160;</a></span>FullDenseExtractor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetatami.html#a6008dbced6de41e5619156b5335f5762">tatami::FullDenseExtractor</a> = typedef <a class="el" href="namespacetatami.html#ae9f8db5316521603085577d977a6955f">Extractor</a>&lt;DimensionSelectionType::FULL, false, Value_, Index_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extractor for dense extraction of full rows. </p>

</div>
</div>
<a id="ae75de1fc78b7d361ea8b59a5379ea4da" name="ae75de1fc78b7d361ea8b59a5379ea4da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae75de1fc78b7d361ea8b59a5379ea4da">&#9670;&#160;</a></span>BlockDenseExtractor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetatami.html#ae75de1fc78b7d361ea8b59a5379ea4da">tatami::BlockDenseExtractor</a> = typedef <a class="el" href="namespacetatami.html#ae9f8db5316521603085577d977a6955f">Extractor</a>&lt;DimensionSelectionType::BLOCK, false, Value_, Index_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extractor for dense extraction of a block of each row. </p>

</div>
</div>
<a id="a47ce406c32c3914c2ecce187e21b6ced" name="a47ce406c32c3914c2ecce187e21b6ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ce406c32c3914c2ecce187e21b6ced">&#9670;&#160;</a></span>IndexDenseExtractor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetatami.html#a47ce406c32c3914c2ecce187e21b6ced">tatami::IndexDenseExtractor</a> = typedef <a class="el" href="namespacetatami.html#ae9f8db5316521603085577d977a6955f">Extractor</a>&lt;DimensionSelectionType::INDEX, false, Value_, Index_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extractor for dense extraction of an indexed subset of each row. </p>

</div>
</div>
<a id="a0fbb0624c8e1913a87e8fb5c975400e1" name="a0fbb0624c8e1913a87e8fb5c975400e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fbb0624c8e1913a87e8fb5c975400e1">&#9670;&#160;</a></span>FullSparseExtractor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetatami.html#a0fbb0624c8e1913a87e8fb5c975400e1">tatami::FullSparseExtractor</a> = typedef <a class="el" href="namespacetatami.html#ae9f8db5316521603085577d977a6955f">Extractor</a>&lt;DimensionSelectionType::FULL, true, Value_, Index_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extractor for sparse extraction of full rows. </p>

</div>
</div>
<a id="ac8d0024399a66ce61f6315f5f46ebb63" name="ac8d0024399a66ce61f6315f5f46ebb63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8d0024399a66ce61f6315f5f46ebb63">&#9670;&#160;</a></span>BlockSparseExtractor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetatami.html#ac8d0024399a66ce61f6315f5f46ebb63">tatami::BlockSparseExtractor</a> = typedef <a class="el" href="namespacetatami.html#ae9f8db5316521603085577d977a6955f">Extractor</a>&lt;DimensionSelectionType::BLOCK, true, Value_, Index_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extractor for sparse extraction of a block of each column. </p>

</div>
</div>
<a id="a4b67b4d1b6c00cd0bd449703432a5f7b" name="a4b67b4d1b6c00cd0bd449703432a5f7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b67b4d1b6c00cd0bd449703432a5f7b">&#9670;&#160;</a></span>IndexSparseExtractor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetatami.html#a4b67b4d1b6c00cd0bd449703432a5f7b">tatami::IndexSparseExtractor</a> = typedef <a class="el" href="namespacetatami.html#ae9f8db5316521603085577d977a6955f">Extractor</a>&lt;DimensionSelectionType::INDEX, true, Value_, Index_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extractor for sparse extraction of an indexed subset of each column. </p>

</div>
</div>
<a id="a35c670894994f1d620abb55953f98441" name="a35c670894994f1d620abb55953f98441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35c670894994f1d620abb55953f98441">&#9670;&#160;</a></span>NumericMatrix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetatami.html#a35c670894994f1d620abb55953f98441">tatami::NumericMatrix</a> = typedef <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt;double, int&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenient shorthand for the most common use case of double-precision matrices. </p>

</div>
</div>
<a id="a18cee3a5d9734f0092b03d023cfe4b6a" name="a18cee3a5d9734f0092b03d023cfe4b6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18cee3a5d9734f0092b03d023cfe4b6a">&#9670;&#160;</a></span>CompressedSparseColumnMatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ , class ValueStorage_  = std::vector&lt;Value_&gt;, class IndexStorage_  = std::vector&lt;Index_&gt;, class PointerStorage_  = std::vector&lt;size_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetatami.html#a18cee3a5d9734f0092b03d023cfe4b6a">tatami::CompressedSparseColumnMatrix</a> = typedef <a class="el" href="classtatami_1_1CompressedSparseMatrix.html">CompressedSparseMatrix</a>&lt;false, Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compressed sparse column matrix. See <code><a class="el" href="classtatami_1_1CompressedSparseMatrix.html" title="Compressed sparse matrix representation.">tatami::CompressedSparseMatrix</a></code> for details on the template parameters. </p>

</div>
</div>
<a id="a0111adeeb583aeb7e24e9e1e25be4aa0" name="a0111adeeb583aeb7e24e9e1e25be4aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0111adeeb583aeb7e24e9e1e25be4aa0">&#9670;&#160;</a></span>CompressedSparseRowMatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ , class ValueStorage_  = std::vector&lt;Value_&gt;, class IndexStorage_  = std::vector&lt;Index_&gt;, class PointerStorage_  = std::vector&lt;size_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetatami.html#a0111adeeb583aeb7e24e9e1e25be4aa0">tatami::CompressedSparseRowMatrix</a> = typedef <a class="el" href="classtatami_1_1CompressedSparseMatrix.html">CompressedSparseMatrix</a>&lt;true, Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compressed sparse row matrix. See <code><a class="el" href="classtatami_1_1CompressedSparseMatrix.html" title="Compressed sparse matrix representation.">tatami::CompressedSparseMatrix</a></code> for details on the template parameters. </p>

</div>
</div>
<a id="a6f03d0d880bc056e09c2cbb80eb2c2ec" name="a6f03d0d880bc056e09c2cbb80eb2c2ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f03d0d880bc056e09c2cbb80eb2c2ec">&#9670;&#160;</a></span>SemiCompressedSparseColumnMatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ , class IndexStorage_  = std::vector&lt;Index_&gt;, class PointerStorage_  = std::vector&lt;size_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetatami.html#a6f03d0d880bc056e09c2cbb80eb2c2ec">tatami::SemiCompressedSparseColumnMatrix</a> = typedef <a class="el" href="classtatami_1_1SemiCompressedSparseMatrix.html">SemiCompressedSparseMatrix</a>&lt;false, Value_, Index_, IndexStorage_, PointerStorage_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Semi-compressed sparse column matrix. See <code><a class="el" href="classtatami_1_1SemiCompressedSparseMatrix.html" title="Semi-compressed sparse matrix representation.">tatami::SemiCompressedSparseMatrix</a></code> for details on the template parameters. </p>

</div>
</div>
<a id="a412cb6ee12f3ee81d404d6eb0e494e4d" name="a412cb6ee12f3ee81d404d6eb0e494e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a412cb6ee12f3ee81d404d6eb0e494e4d">&#9670;&#160;</a></span>SemiCompressedSparseRowMatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ , class IndexStorage_  = std::vector&lt;Index_&gt;, class PointerStorage_  = std::vector&lt;size_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetatami.html#a412cb6ee12f3ee81d404d6eb0e494e4d">tatami::SemiCompressedSparseRowMatrix</a> = typedef <a class="el" href="classtatami_1_1SemiCompressedSparseMatrix.html">SemiCompressedSparseMatrix</a>&lt;true, Value_, Index_, IndexStorage_, PointerStorage_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Semi-compressed sparse row matrix. See <code><a class="el" href="classtatami_1_1SemiCompressedSparseMatrix.html" title="Semi-compressed sparse matrix representation.">tatami::SemiCompressedSparseMatrix</a></code> for details on the template parameters. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a0a2ecaf58e2b69bb4a808e814aeb16a1" name="a0a2ecaf58e2b69bb4a808e814aeb16a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a2ecaf58e2b69bb4a808e814aeb16a1">&#9670;&#160;</a></span>DimensionSelectionType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacetatami.html#a0a2ecaf58e2b69bb4a808e814aeb16a1">tatami::DimensionSelectionType</a> : char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Type of selection along a dimension, typically the extraction dimension:</p>
<ul>
<li><code>FULL</code>: selects the full extent of the dimension, i.e., all elements in the dimension.</li>
<li><code>BLOCK</code>: selects a contiguous block of elements in the dimension.</li>
<li><code>INDEX</code>: selects a sorted and unique array of indices of dimension elements. </li>
</ul>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="af9d13ceaa112d2c091265510d741488d" name="af9d13ceaa112d2c091265510d741488d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9d13ceaa112d2c091265510d741488d">&#9670;&#160;</a></span>extracted_length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#a0a2ecaf58e2b69bb4a808e814aeb16a1">DimensionSelectionType</a> selection_, typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Index_ tatami::extracted_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetatami.html#a85ed61a4f772a2f7be4a12f739554e6e">ConditionalSelectionExtractor</a>&lt; selection_, Index_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>ex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">selection_</td><td>Type of selection along the extraction dimension. </td></tr>
    <tr><td class="paramname">Index_</td><td>Row/column index type, should be integer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>A <code>ConditionalSelectionExtractor</code> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements extracted from the extraction dimension, conditional on the selection type in <code>selection_</code>. </dd></dl>

</div>
</div>
<a id="aa82419090e54a4674d971429e93e6af5" name="aa82419090e54a4674d971429e93e6af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa82419090e54a4674d971429e93e6af5">&#9670;&#160;</a></span>make_DelayedAddVectorHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int MARGIN, typename T  = double, class V  = std::vector&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedAddVectorHelper.html">DelayedAddVectorHelper</a>&lt; MARGIN, T, V &gt; tatami::make_DelayedAddVectorHelper </td>
          <td>(</td>
          <td class="paramtype">V&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <code>make_*</code> helper function to enable partial template deduction of supplied types. See the <code><a class="el" href="structtatami_1_1DelayedAddVectorHelper.html" title="Add a vector along the rows or columns of a matrix.">tatami::DelayedAddVectorHelper</a></code> documentation for more details on the arguments. </p>

</div>
</div>
<a id="abb68a8d27e821f213965edab7f029c48" name="abb68a8d27e821f213965edab7f029c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb68a8d27e821f213965edab7f029c48">&#9670;&#160;</a></span>make_DelayedSubtractVectorHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool RIGHT, int MARGIN, typename T  = double, class V  = std::vector&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedSubtractVectorHelper.html">DelayedSubtractVectorHelper</a>&lt; RIGHT, MARGIN, T, V &gt; tatami::make_DelayedSubtractVectorHelper </td>
          <td>(</td>
          <td class="paramtype">V&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <code>make_*</code> helper function to enable partial template deduction of supplied types. See the <code><a class="el" href="structtatami_1_1DelayedSubtractVectorHelper.html" title="Subtract a vector from the rows/columns of a matrix, or vice versa.">tatami::DelayedSubtractVectorHelper</a></code> documentation for more details on the arguments. </p>

</div>
</div>
<a id="a316f4cf0ae5a9e83c2dad6ccbbbcfb43" name="a316f4cf0ae5a9e83c2dad6ccbbbcfb43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a316f4cf0ae5a9e83c2dad6ccbbbcfb43">&#9670;&#160;</a></span>make_DelayedMultiplyVectorHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int MARGIN, typename T  = double, class V  = std::vector&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedMultiplyVectorHelper.html">DelayedMultiplyVectorHelper</a>&lt; MARGIN, T, V &gt; tatami::make_DelayedMultiplyVectorHelper </td>
          <td>(</td>
          <td class="paramtype">V&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <code>make_*</code> helper function to enable partial template deduction of supplied types. See the <code><a class="el" href="structtatami_1_1DelayedMultiplyVectorHelper.html" title="Multiply a vector along the rows or columns of a matrix.">tatami::DelayedMultiplyVectorHelper</a></code> documentation for more details on the arguments. </p>

</div>
</div>
<a id="ab104e5029db4d09afe0b47a125f457bf" name="ab104e5029db4d09afe0b47a125f457bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab104e5029db4d09afe0b47a125f457bf">&#9670;&#160;</a></span>make_DelayedDivideVectorHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool RIGHT, int MARGIN, typename T  = double, class V  = std::vector&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedDivideVectorHelper.html">DelayedDivideVectorHelper</a>&lt; RIGHT, MARGIN, T, V &gt; tatami::make_DelayedDivideVectorHelper </td>
          <td>(</td>
          <td class="paramtype">V&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <code>make_*</code> helper function to enable partial template deduction of supplied types. See the <code><a class="el" href="structtatami_1_1DelayedDivideVectorHelper.html" title="Divide the rows/columns of a matrix by a vector, or vice versa.">tatami::DelayedDivideVectorHelper</a></code> documentation for more details on the arguments. </p>

</div>
</div>
<a id="a70e92d6c4eb0b1303b02176aa1d016a0" name="a70e92d6c4eb0b1303b02176aa1d016a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70e92d6c4eb0b1303b02176aa1d016a0">&#9670;&#160;</a></span>make_DelayedIsometricOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ , class Operation_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; tatami::make_DelayedIsometricOp </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Operation_&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <code>make_*</code> helper function to enable partial template deduction of supplied types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of index value. </td></tr>
    <tr><td class="paramname">Operation_</td><td>Helper class defining the operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to a (possibly <code>const</code>) <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code>. </td></tr>
    <tr><td class="paramname">op</td><td>Instance of the operation helper class.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Instance of a <code><a class="el" href="classtatami_1_1DelayedIsometricOp.html" title="Delayed isometric operations on a matrix.">DelayedIsometricOp</a></code> clas. </dd></dl>

</div>
</div>
<a id="a5f8e0f69139575707aa9314174b415b3" name="a5f8e0f69139575707aa9314174b415b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f8e0f69139575707aa9314174b415b3">&#9670;&#160;</a></span>make_DelayedBind()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int margin_, typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; tatami::make_DelayedBind </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; &gt;&#160;</td>
          <td class="paramname"><em>ps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <code>make_*</code> helper function to enable partial template deduction of supplied types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">margin_</td><td>Dimension along which the combining is to occur. If 0, matrices are combined along the rows; if 1, matrices are combined to the columns. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of index value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ps</td><td>Pointers to <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <code><a class="el" href="classtatami_1_1DelayedBind.html" title="Delayed combining of a matrix.">DelayedBind</a></code> instance.</dd></dl>
<p>A <code>make_*</code> helper function to enable partial template deduction of supplied types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">margin_</td><td>Dimension along which the combining is to occur. If 0, matrices are combined along the rows; if 1, matrices are combined to the columns. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of index value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ps</td><td>Pointers to <code>const</code> <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <code><a class="el" href="classtatami_1_1DelayedBind.html" title="Delayed combining of a matrix.">DelayedBind</a></code> instance. </dd></dl>

</div>
</div>
<a id="aca62c3bf751cdd06a08e8e503b0b591a" name="aca62c3bf751cdd06a08e8e503b0b591a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca62c3bf751cdd06a08e8e503b0b591a">&#9670;&#160;</a></span>make_DelayedCast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_out_ , typename Index_out_ , typename Value_in_ , typename Index_in_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_out_, Index_out_ &gt; &gt; tatami::make_DelayedCast </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_in_, Index_in_ &gt; &gt;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recast a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> to a different interface type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_out_</td><td>Data type to cast to. </td></tr>
    <tr><td class="paramname">Index_out_</td><td>Index type to cast to. </td></tr>
    <tr><td class="paramname">Value_in_</td><td>Data type to cast from. </td></tr>
    <tr><td class="paramname">Index_in_</td><td>Index type to cast from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to the (possbly <code>const</code>) <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> instance to cast from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> instance of the desired interface type. </dd></dl>

</div>
</div>
<a id="afa35d8e9fe286967f327ec0eb6bd5005" name="afa35d8e9fe286967f327ec0eb6bd5005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa35d8e9fe286967f327ec0eb6bd5005">&#9670;&#160;</a></span>make_DelayedTranspose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; tatami::make_DelayedTranspose </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <code>make_*</code> helper function to enable partial template deduction of supplied types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of index value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to a (possibly <code>const</code>) <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <code><a class="el" href="classtatami_1_1DelayedTranspose.html" title="Delayed transposition of a matrix.">DelayedTranspose</a></code> instance. </dd></dl>

</div>
</div>
<a id="a8f4aafc0a1fbdc0c31bc122d24122a63" name="a8f4aafc0a1fbdc0c31bc122d24122a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f4aafc0a1fbdc0c31bc122d24122a63">&#9670;&#160;</a></span>make_DelayedSubsetBlock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int margin_, typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; tatami::make_DelayedSubsetBlock </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <code>make_*</code> helper function to enable partial template deduction of supplied types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">margin_</td><td>Dimension along which the addition is to occur. If 0, the subset is applied to the rows; if 1, the subset is applied to the columns. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to the underlying (pre-subset) <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code>. </td></tr>
    <tr><td class="paramname">f</td><td>Index of the start of the block. This should be a row index if <code>margin_ = 0</code> and a column index otherwise. </td></tr>
    <tr><td class="paramname">l</td><td>Index of the one-past-the-end of the block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <code><a class="el" href="classtatami_1_1DelayedSubsetBlock.html" title="Delayed subsetting to a contiguous block.">DelayedSubsetBlock</a></code> instance. </dd></dl>

</div>
</div>
<a id="abfc63177b00e6e3e2fa47754b8d87704" name="abfc63177b00e6e3e2fa47754b8d87704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc63177b00e6e3e2fa47754b8d87704">&#9670;&#160;</a></span>make_DelayedSubset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int margin_, typename Value_ , typename Index_ , class IndexStorage_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; tatami::make_DelayedSubset </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexStorage_&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <code>make_*</code> helper function to enable partial template deduction of supplied types. This will automatically dispatch to <code><a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html" title="Delayed subsetting of a matrix with sorted, unique indices.">DelayedSubsetSortedUnique</a></code>, <code><a class="el" href="classtatami_1_1DelayedSubsetUnique.html" title="Delayed subsetting of a matrix with unique indices.">DelayedSubsetUnique</a></code>, <code><a class="el" href="classtatami_1_1DelayedSubsetSorted.html" title="Delayed subsetting of a matrix with sorted indices.">DelayedSubsetSorted</a></code> or <code><a class="el" href="classtatami_1_1DelayedSubset.html" title="Delayed subsetting of a matrix with general indices.">DelayedSubset</a></code>, depending on the values in <code>idx</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">margin_</td><td>Dimension along which the subsetting is to occur. If 0, the subset is applied to the rows; if 1, the subset is applied to the columns. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type of the row/column indices. </td></tr>
    <tr><td class="paramname">IndexStorage_</td><td>Vector containing the subset indices, to be automatically deduced.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to a (possibly <code>const</code>) <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code>. </td></tr>
    <tr><td class="paramname">idx</td><td>Instance of the index vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <code><a class="el" href="classtatami_1_1DelayedSubset.html" title="Delayed subsetting of a matrix with general indices.">DelayedSubset</a></code> instance. </dd></dl>

</div>
</div>
<a id="a95b6638dceda82d82a7579dc88a45709" name="a95b6638dceda82d82a7579dc88a45709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95b6638dceda82d82a7579dc88a45709">&#9670;&#160;</a></span>new_extractor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool row_, bool sparse_, typename Value_ , typename Index_ , typename ... Args_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto tatami::new_extractor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args_ &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">row_</td><td>Whether to iterate over rows. </td></tr>
    <tr><td class="paramname">sparse_</td><td>Whether to perform sparse retrieval. </td></tr>
    <tr><td class="paramname">Value_</td><td>Data value type, should be numeric. </td></tr>
    <tr><td class="paramname">Index_</td><td>Row/column index type, should be integer. </td></tr>
    <tr><td class="paramname">Args_</td><td>Further arguments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> object to iterate over. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">args</td><td>Zero or more additional arguments to pass to methods like <code><a class="el" href="classtatami_1_1Matrix.html#aa29b9428f53453369256d7febc9ed0fc">Matrix::dense_row()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>Extractor</code> object to access the requested dimension of <code>ptr</code>. </dd></dl>

</div>
</div>
<a id="a44202790861791b1ed9df6d480c69f6a" name="a44202790861791b1ed9df6d480c69f6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44202790861791b1ed9df6d480c69f6a">&#9670;&#160;</a></span>column_medians()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Output_ &gt; tatami::column_medians </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Output_</td><td>Type of the output. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Shared pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of length equal to the number of columns, containing the column medians. </dd></dl>

</div>
</div>
<a id="ab877f67694b3fa500f59469f044b1c01" name="ab877f67694b3fa500f59469f044b1c01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab877f67694b3fa500f59469f044b1c01">&#9670;&#160;</a></span>row_medians()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Output_ &gt; tatami::row_medians </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Output</td><td>Type of the output. </td></tr>
    <tr><td class="paramname">T</td><td>Type of the matrix value. </td></tr>
    <tr><td class="paramname">IDX</td><td>Type of the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Shared pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of length equal to the number of rows, containing the row medians. </dd></dl>

</div>
</div>
<a id="a8102a2423efab5e329543f4235ac2290" name="a8102a2423efab5e329543f4235ac2290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8102a2423efab5e329543f4235ac2290">&#9670;&#160;</a></span>column_maxs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Output_ &gt; tatami::column_maxs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Output</td><td>Type of the output value. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of length equal to the number of columns, containing the maximum value in each column. </dd></dl>

</div>
</div>
<a id="a47890bfd538f65971f9e5dba5e1ed785" name="a47890bfd538f65971f9e5dba5e1ed785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47890bfd538f65971f9e5dba5e1ed785">&#9670;&#160;</a></span>row_maxs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Output_ &gt; tatami::row_maxs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Output</td><td>Type of the output value. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of length equal to the number of rows, containing the maximum value in each row. </dd></dl>

</div>
</div>
<a id="a60e44772f82183100c7c25c181479b56" name="a60e44772f82183100c7c25c181479b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e44772f82183100c7c25c181479b56">&#9670;&#160;</a></span>column_mins()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Output_ &gt; tatami::column_mins </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Output</td><td>Type of the output value. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of length equal to the number of columns, containing the minimum value in each column. </dd></dl>

</div>
</div>
<a id="a3bcdcb0499b36b5b844ebd88fc30eefe" name="a3bcdcb0499b36b5b844ebd88fc30eefe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bcdcb0499b36b5b844ebd88fc30eefe">&#9670;&#160;</a></span>row_mins()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Output_ &gt; tatami::row_mins </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Output</td><td>Type of the output value. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of length equal to the number of rows, containing the minimum value in each row. </dd></dl>

</div>
</div>
<a id="ab5eff79824930c458e730d23f640c1ab" name="ab5eff79824930c458e730d23f640c1ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5eff79824930c458e730d23f640c1ab">&#9670;&#160;</a></span>column_ranges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; Output_ &gt;, std::vector&lt; Output_ &gt; &gt; tatami::column_ranges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Output</td><td>Type of the output value. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of vectors, each of length equal to the number of rows. The first and second vector contains the minimum and maximum value per row, respectively. </dd></dl>

</div>
</div>
<a id="a2b2475a166ad744b31b1275e26e562be" name="a2b2475a166ad744b31b1275e26e562be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b2475a166ad744b31b1275e26e562be">&#9670;&#160;</a></span>row_ranges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; Output_ &gt;, std::vector&lt; Output_ &gt; &gt; tatami::row_ranges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Output</td><td>Type of the output value. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of vectors, each of length equal to the number of rows. The first and second vector contains the minimum and maximum value per row, respectively. </dd></dl>

</div>
</div>
<a id="a3aab6733d637b66abdf45f7300d2e1ba" name="a3aab6733d637b66abdf45f7300d2e1ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aab6733d637b66abdf45f7300d2e1ba">&#9670;&#160;</a></span>column_sums()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Output_ &gt; tatami::column_sums </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Output_</td><td>Type of the output value. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the matrix value, should be summable. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of length equal to the number of columns, containing the column sums. </dd></dl>

</div>
</div>
<a id="a53a658059404691856bef57fb85d83d6" name="a53a658059404691856bef57fb85d83d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53a658059404691856bef57fb85d83d6">&#9670;&#160;</a></span>row_sums()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Output_ &gt; tatami::row_sums </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Output_</td><td>Type of the output value. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the matrix value, should be summable. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of length equal to the number of rows, containing the row sums. </dd></dl>

</div>
</div>
<a id="a29ce7a2219ea60d45de1aa3d4de66063" name="a29ce7a2219ea60d45de1aa3d4de66063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29ce7a2219ea60d45de1aa3d4de66063">&#9670;&#160;</a></span>parallelize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool parallel_ = true, class Function_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tatami::parallelize </td>
          <td>(</td>
          <td class="paramtype">Function_&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tasks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>threads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply a function to a set of tasks, distributing them to threads via OpenMP if enabled. Callers can specify a custom parallelization scheme by defining a <code>TATAMI_CUSTOM_PARALLEL</code> function-like macro, which should accept the <code>fun</code>, <code>tasks</code> and <code>threads</code> arguments as below.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">parallel_</td><td>Whether the tasks should be run in parallel. If <code>false</code>, no parallelization is performed and all tasks are run on the current thread. </td></tr>
    <tr><td class="paramname">Function_</td><td>Function to be applied for a contiguous range of tasks. This should accept three arguments:<ul>
<li><code>thread</code>, the thread number executing this task range.</li>
<li><code>task_start</code>, the start index of the task range.</li>
<li><code>task_length</code>, the number of tasks in the task range.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fun</td><td>Function that executes a contiguous range of tasks. </td></tr>
    <tr><td class="paramname">tasks</td><td>Number of tasks. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36c6ecf33bcb87e1ed33c0a7d744dd82" name="a36c6ecf33bcb87e1ed33c0a7d744dd82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36c6ecf33bcb87e1ed33c0a7d744dd82">&#9670;&#160;</a></span>consecutive_extractor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool row_, bool sparse_, typename Value_ , typename Index_ , typename ... Args_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto tatami::consecutive_extractor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_&#160;</td>
          <td class="paramname"><em>iter_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_&#160;</td>
          <td class="paramname"><em>iter_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args_ &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">row_</td><td>Whether to perform extraction on rows. </td></tr>
    <tr><td class="paramname">sparse_</td><td>Whether to perform sparse retrieval. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of the row/column index. </td></tr>
    <tr><td class="paramname">Args_</td><td>Types of further arguments to pass to <code><a class="el" href="classtatami_1_1Matrix.html#aa29b9428f53453369256d7febc9ed0fc">Matrix::dense_row</a></code> or <code><a class="el" href="classtatami_1_1Matrix.html#a9f6c3453a5c0c28a764f300f45bf860f">Matrix::dense_column</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a> to iterate over. </td></tr>
    <tr><td class="paramname">iter_start</td><td>Index of the first row/column of the iteration range. </td></tr>
    <tr><td class="paramname">iter_length</td><td>Number of rows/columns in the iteration range. </td></tr>
    <tr><td class="paramname">args</td><td>Further arguments to pass to <code><a class="el" href="classtatami_1_1Matrix.html#aa29b9428f53453369256d7febc9ed0fc">Matrix::dense_row</a></code> or <code><a class="el" href="classtatami_1_1Matrix.html#a9f6c3453a5c0c28a764f300f45bf860f">Matrix::dense_column</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <code>Extractor</code> object for iteration over consecutive rows/columns in <code>[iter_start, iter_start + iter_length)</code>.</dd></dl>
<p>This function is equivalent to <code><a class="el" href="namespacetatami.html#a95b6638dceda82d82a7579dc88a45709">new_extractor()</a></code> but additionally calls <code>Extractor::set_oracle()</code> with a <code><a class="el" href="structtatami_1_1ConsecutiveOracle.html" title="Predict future accesses of a consecutive sequence.">ConsecutiveOracle</a></code> instance. <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> implementations that are oracle-aware can then perform pre-fetching of future accesses for greater performance. Of course, this assumes that the iteration over the target dimension does actually involve consecutive elements from <code>iter_start</code> to <code>iter_start + iter_length</code>. </p>

</div>
</div>
<a id="ac37af9a76d15f08a3634881696a27f65" name="ac37af9a76d15f08a3634881696a27f65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac37af9a76d15f08a3634881696a27f65">&#9670;&#160;</a></span>column_variances()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Output_ &gt; tatami::column_variances </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This uses the usual algorithm for matrices where <code><a class="el" href="classtatami_1_1Matrix.html#a69382d2a4e66cda1a9eb48dc25ab113a">tatami::Matrix::prefer_rows()</a></code> is false, otherwise it uses Welford's algorithm. As a result, the computed variances will be slightly different (within numerical precision) for row- and column-major matrices.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Output</td><td>Type of the output value. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the matrix value, should be numeric. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of length equal to the number of columns, containing the column variances. </dd></dl>

</div>
</div>
<a id="ab806279616e19f6150376a7c07d5b64b" name="ab806279616e19f6150376a7c07d5b64b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab806279616e19f6150376a7c07d5b64b">&#9670;&#160;</a></span>row_variances()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Output_ &gt; tatami::row_variances </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This uses the usual algorithm for matrices where <code><a class="el" href="classtatami_1_1Matrix.html#a69382d2a4e66cda1a9eb48dc25ab113a">tatami::Matrix::prefer_rows()</a></code> is true, otherwise it uses Welford's algorithm. As a result, the computed variances will be slightly different (within numerical precision) for row- and column-major matrices.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Output</td><td>Type of the output value. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the matrix value, should be numeric. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of length equal to the number of rows, containing the row variances. </dd></dl>

</div>
</div>
<a id="a87c52cf8a974ad0025550b002d391d39" name="a87c52cf8a974ad0025550b002d391d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87c52cf8a974ad0025550b002d391d39">&#9670;&#160;</a></span>bind_intersection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int margin, class <a class="el" href="classtatami_1_1Matrix.html">Matrix</a> , typename Id &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a> &gt;, std::vector&lt; size_t &gt; &gt; tatami::bind_intersection </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const Id * &gt; &amp;&#160;</td>
          <td class="paramname"><em>ids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Combine multiple matrices along the specified dimension while accounting for non-identical IDs along the other dimension. This function will identify the intersection of common identifiers across all matrices, subset each individual matrix to the intersection in the other dimension, and then combine them along the specified dimension.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">margin</td><td>The dimension to combine along - by rows (0) or columns (1). </td></tr>
    <tr><td class="paramname"><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></td><td>The <b>tatami</b> matrix class. </td></tr>
    <tr><td class="paramname">Id</td><td>Integer type representing the identifiers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputs</td><td>Vector of pointers to matrices to be combined along the dimension specified by <code>margin</code>. </td></tr>
    <tr><td class="paramname">ids</td><td>Vector of length equal to that of <code>inputs</code>, containing pointers to the identifiers for the matrices. Each pointer should refer to an array equal to the number of columns (if <code>margin = 0</code>) or rows (if <code>margin = 1</code>) in the corresponding entry of <code>inputs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair containing the combined matrix (first) and a vector of indices for the intersection (second). In the combined matrix, each column (if <code>margin = 0</code>) or row (if <code>margin = 1</code>) will correspond to an entry in the intersection vector. Indices in the intersection vector should be applied to <code>ids[0]</code> to obtain the actual identifiers of the rows/columns. </dd></dl>

</div>
</div>
<a id="ab17e92414b0bff60f7b7a6431ac8a330" name="ab17e92414b0bff60f7b7a6431ac8a330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab17e92414b0bff60f7b7a6431ac8a330">&#9670;&#160;</a></span>compress_sparse_triplets()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool ROW, class U , class V , class W &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; size_t &gt; tatami::compress_sparse_triplets </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">W &amp;&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ROW</td><td>Whether to create a compressed sparse row format. If <code>false</code>, the compressed sparse column format is used instead. </td></tr>
    <tr><td class="paramname">U</td><td>Random-access container for the values. </td></tr>
    <tr><td class="paramname">V</td><td>Random access container for the row indices. </td></tr>
    <tr><td class="paramname">W</td><td>Random access container for the column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nr</td><td>Number of rows. </td></tr>
    <tr><td class="paramname">nc</td><td>Number of columns. </td></tr>
    <tr><td class="paramname">rows</td><td>Row indices. Values must be non-negative integers less than <code>nr</code>. </td></tr>
    <tr><td class="paramname">cols</td><td>Column indices. Values must be non-negative integers less than <code>nc</code>. </td></tr>
    <tr><td class="paramname">values</td><td>Non-zero values.</td></tr>
  </table>
  </dd>
</dl>
<p><code>rows</code>, <code>cols</code> and <code>values</code> must be of the same length. Corresponding entries across these vectors are assumed to contain data for a single non-zero element.</p>
<dl class="section return"><dt>Returns</dt><dd><code>rows</code>, <code>cols</code> and <code>values</code> are sorted in-place by the row and column indices (if <code>ROW = true</code>) or by the column and row indices (if <code>ROW = false</code>). A vector of index pointers is returned with length <code>nr + 1</code> (if <code>ROW = true</code>) or <code>nc + 1</code> (if <code>ROW = false</code>). </dd></dl>

</div>
</div>
<a id="afaccb18d22f35a4ed6b6a7091342da06" name="afaccb18d22f35a4ed6b6a7091342da06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaccb18d22f35a4ed6b6a7091342da06">&#9670;&#160;</a></span>convert_to_dense() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool row_, typename StoredValue_ , class Matrix_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tatami::convert_to_dense </td>
          <td>(</td>
          <td class="paramtype">const Matrix_ *&#160;</td>
          <td class="paramname"><em>incoming</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StoredValue_ *&#160;</td>
          <td class="paramname"><em>store</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">row_</td><td>Whether to return a row-major matrix. </td></tr>
    <tr><td class="paramname">StoredValue_</td><td>Type of data values to be stored in the output. </td></tr>
    <tr><td class="paramname">Matrix_</td><td>Input matrix class, most typically a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">incoming</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">store</td><td>Pointer to an array of length equal to the product of the dimensions of <code>incoming</code>. On output, this is filled with values from <code>incoming</code> in row- or column-major format depending on <code>row_</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">threads</td><td>Number of threads to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af80143ac537339fe8dafd892632e96de" name="af80143ac537339fe8dafd892632e96de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af80143ac537339fe8dafd892632e96de">&#9670;&#160;</a></span>convert_to_dense() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool row_, typename Value_  = double, typename Index  = int, typename StoredValue_  = Value_, class Matrix_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index &gt; &gt; tatami::convert_to_dense </td>
          <td>(</td>
          <td class="paramtype">const Matrix_ *&#160;</td>
          <td class="paramname"><em>incoming</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">row</td><td>Whether to return a row-major matrix. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of data values in the output interface. </td></tr>
    <tr><td class="paramname">Index</td><td>Integer type for the indices in the output interface. </td></tr>
    <tr><td class="paramname">StoredValue_</td><td>Type of data values to be stored in the output. </td></tr>
    <tr><td class="paramname">Matrix_</td><td>Input matrix class, most typically a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">incoming</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a new <code><a class="el" href="classtatami_1_1DenseMatrix.html" title="Dense matrix representation.">tatami::DenseMatrix</a></code> with the same dimensions and type as the matrix referenced by <code>incoming</code>. If <code>row = true</code>, the matrix is row-major, otherwise it is column-major. </dd></dl>

</div>
</div>
<a id="a64e8745f8aaaa5ad93c6ce65a0a6591e" name="a64e8745f8aaaa5ad93c6ce65a0a6591e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64e8745f8aaaa5ad93c6ce65a0a6591e">&#9670;&#160;</a></span>convert_to_dense() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_  = double, typename Index_  = int, typename StoredValue_  = Value_, class Matrix_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; tatami::convert_to_dense </td>
          <td>(</td>
          <td class="paramtype">const Matrix_ *&#160;</td>
          <td class="paramname"><em>incoming</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This overload makes it easier to control the desired output order when it is not known at compile time.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of data values in the output interface. </td></tr>
    <tr><td class="paramname">Index</td><td>Integer type for the indices in the output interface. </td></tr>
    <tr><td class="paramname">StoredValue_</td><td>Type of data values to be stored in the output. </td></tr>
    <tr><td class="paramname">Matrix_</td><td>Input matrix class, most typically a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">incoming</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">order</td><td>Ordering of values in the output dense matrix - row-major (0) or column-major (1). If set to -1, the ordering is chosen based on <code><a class="el" href="classtatami_1_1Matrix.html#a69382d2a4e66cda1a9eb48dc25ab113a">tatami::Matrix::prefer_rows()</a></code>. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a new <code><a class="el" href="classtatami_1_1DenseMatrix.html" title="Dense matrix representation.">tatami::DenseMatrix</a></code> with the same dimensions and type as the matrix referenced by <code>incoming</code>. </dd></dl>

</div>
</div>
<a id="a220c47e470b3ade64ede7303e50ca92d" name="a220c47e470b3ade64ede7303e50ca92d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a220c47e470b3ade64ede7303e50ca92d">&#9670;&#160;</a></span>convert_to_sparse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool row_, typename Value_  = double, typename Index_  = int, typename StoredValue_  = Value_, typename StoredIndex_  = Index_, class InputMatrix_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; tatami::convert_to_sparse </td>
          <td>(</td>
          <td class="paramtype">const InputMatrix_ *&#160;</td>
          <td class="paramname"><em>incoming</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">row_</td><td>Whether to return a compressed sparse row matrix. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of data values in the output interface. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the indices in the output interface. </td></tr>
    <tr><td class="paramname">StoredValue_</td><td>Type of data values to be stored in the output. </td></tr>
    <tr><td class="paramname">StoredIndex_</td><td>Integer type for storing the indices in the output. </td></tr>
    <tr><td class="paramname">InputMatrix_</td><td>Input matrix class, most typically a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">incoming</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>, possibly containing delayed operations. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a new <code><a class="el" href="classtatami_1_1CompressedSparseMatrix.html" title="Compressed sparse matrix representation.">tatami::CompressedSparseMatrix</a></code>, with the same dimensions and type as the matrix referenced by <code>incoming</code>. If <code>row_ = true</code>, the matrix is compressed sparse row, otherwise it is compressed sparse column. </dd></dl>

</div>
</div>
<a id="a5847f3cd78ce89170ca43262d7f5f8e3" name="a5847f3cd78ce89170ca43262d7f5f8e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5847f3cd78ce89170ca43262d7f5f8e3">&#9670;&#160;</a></span>convert_to_sparse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_  = double, typename Index_  = int, typename StoredValue_  = Value_, typename StoredIndex_  = Index_, class InputMatrix_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; tatami::convert_to_sparse </td>
          <td>(</td>
          <td class="paramtype">const InputMatrix_ *&#160;</td>
          <td class="paramname"><em>incoming</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This overload makes it easier to control the desired output order when it is not known at compile time.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of data values in the output interface. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the indices in the output interface. </td></tr>
    <tr><td class="paramname">StoredValue_</td><td>Type of data values to be stored in the output. </td></tr>
    <tr><td class="paramname">StoredIndex_</td><td>Integer type for storing the indices in the output. </td></tr>
    <tr><td class="paramname">InputMatrix_</td><td>Input matrix class, most typically a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">incoming</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">order</td><td>Ordering of values in the output matrix - compressed sparse row (0) or column (1). If set to -1, the ordering is chosen based on <code><a class="el" href="classtatami_1_1Matrix.html#a69382d2a4e66cda1a9eb48dc25ab113a">tatami::Matrix::prefer_rows()</a></code>. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a new <code><a class="el" href="classtatami_1_1CompressedSparseMatrix.html" title="Compressed sparse matrix representation.">tatami::CompressedSparseMatrix</a></code>, with the same dimensions and type as the matrix referenced by <code>incoming</code>. </dd></dl>

</div>
</div>
<a id="a7518f5e8e09a6f6d7d3955b8ea286689" name="a7518f5e8e09a6f6d7d3955b8ea286689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7518f5e8e09a6f6d7d3955b8ea286689">&#9670;&#160;</a></span>wrap_shared_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; &gt; tatami::wrap_shared_ptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrap a raw pointer inside a <code>shared_ptr</code>, typically to enable use of a raw <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code> pointer with delayed operation wrappers. This enables use of delayed operations inside functions that accept a raw pointer to an externally owned <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to the same object addressed by <code>ptr</code>. The assumption is that <code>ptr</code> will always outlive the returned pointer. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
