<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tatami: tatami Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tatami
   </div>
   <div id="projectbrief">C++ API for different matrix representations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">tatami Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Flexible representations for matrix data.  
<a href="namespacetatami.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacetatami_1_1MatrixMarket"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami_1_1MatrixMarket.html">MatrixMarket</a></td></tr>
<tr class="memdesc:namespacetatami_1_1MatrixMarket"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classes and utilites to handle <a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a> Market files. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1ArrayView.html">ArrayView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">View into a pre-allocated array.  <a href="classtatami_1_1ArrayView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1BlockExtractor.html">BlockExtractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual base class for block access.  <a href="structtatami_1_1BlockExtractor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1CompressedSparseMatrix.html">CompressedSparseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compressed sparse matrix representation.  <a href="classtatami_1_1CompressedSparseMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1ConsecutiveOracle.html">ConsecutiveOracle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predict future accesses of a consecutive sequence.  <a href="structtatami_1_1ConsecutiveOracle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedAbsHelper.html">DelayedAbsHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the absolute value of a matrix entry.  <a href="structtatami_1_1DelayedAbsHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedAcosHelper.html">DelayedAcosHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the arc cosine of a matrix entry.  <a href="structtatami_1_1DelayedAcosHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedAcoshHelper.html">DelayedAcoshHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the inverse hyperbolic cosine of a matrix entry.  <a href="structtatami_1_1DelayedAcoshHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedArithScalarHelper.html">DelayedArithScalarHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed scalar arithmetic.  <a href="structtatami_1_1DelayedArithScalarHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedArithVectorHelper.html">DelayedArithVectorHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed vector arithmetic.  <a href="structtatami_1_1DelayedArithVectorHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedAsinHelper.html">DelayedAsinHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the arc sine of a matrix entry.  <a href="structtatami_1_1DelayedAsinHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedAsinhHelper.html">DelayedAsinhHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the inverse hyperbolic sine of a matrix entry.  <a href="structtatami_1_1DelayedAsinhHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedAtanHelper.html">DelayedAtanHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the arc tangent of a matrix entry.  <a href="structtatami_1_1DelayedAtanHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedAtanhHelper.html">DelayedAtanhHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the inverse hyperbolic tangent of a matrix entry.  <a href="structtatami_1_1DelayedAtanhHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedBinaryArithHelper.html">DelayedBinaryArithHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed binary arithmetic.  <a href="structtatami_1_1DelayedBinaryArithHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedBinaryBooleanHelper.html">DelayedBinaryBooleanHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed binary boolean operations.  <a href="structtatami_1_1DelayedBinaryBooleanHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedBinaryCompareHelper.html">DelayedBinaryCompareHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed binary comparison.  <a href="structtatami_1_1DelayedBinaryCompareHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedBinaryIsometricOp.html">DelayedBinaryIsometricOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed isometric operations on two matrices.  <a href="classtatami_1_1DelayedBinaryIsometricOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedBind.html">DelayedBind</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed combining of a matrix.  <a href="classtatami_1_1DelayedBind.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedBooleanNotHelper.html">DelayedBooleanNotHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed boolean NOT operation.  <a href="structtatami_1_1DelayedBooleanNotHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedBooleanScalarHelper.html">DelayedBooleanScalarHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed scalar boolean operation.  <a href="structtatami_1_1DelayedBooleanScalarHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedBooleanVectorHelper.html">DelayedBooleanVectorHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed vector boolean operations.  <a href="structtatami_1_1DelayedBooleanVectorHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedCast.html">DelayedCast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recast a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> to a different interface type.  <a href="classtatami_1_1DelayedCast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedCeilingHelper.html">DelayedCeilingHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the ceiling of a matrix entry.  <a href="structtatami_1_1DelayedCeilingHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedCompareScalarHelper.html">DelayedCompareScalarHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed scalar comparison.  <a href="structtatami_1_1DelayedCompareScalarHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedCompareVectorHelper.html">DelayedCompareVectorHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed vector comparisons.  <a href="structtatami_1_1DelayedCompareVectorHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedCosHelper.html">DelayedCosHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the cosine of a matrix entry.  <a href="structtatami_1_1DelayedCosHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedCoshHelper.html">DelayedCoshHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the hyperbolic cosine of a matrix entry.  <a href="structtatami_1_1DelayedCoshHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedExpHelper.html">DelayedExpHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a matrix entry as an exponent.  <a href="structtatami_1_1DelayedExpHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedExpm1Helper.html">DelayedExpm1Helper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a matrix entry as an exponent minus 1.  <a href="structtatami_1_1DelayedExpm1Helper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedFloorHelper.html">DelayedFloorHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the floor of a matrix entry.  <a href="structtatami_1_1DelayedFloorHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedGammaHelper.html">DelayedGammaHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the gamma of a matrix entry.  <a href="structtatami_1_1DelayedGammaHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedLgammaHelper.html">DelayedLgammaHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the logarithm of the gamma of a matrix entry.  <a href="structtatami_1_1DelayedLgammaHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedLog1pHelper.html">DelayedLog1pHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the logarithm of a matrix entry plus 1.  <a href="structtatami_1_1DelayedLog1pHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedLogHelper.html">DelayedLogHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the logarithm of a matrix entry.  <a href="structtatami_1_1DelayedLogHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedRoundHelper.html">DelayedRoundHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round a matrix entry to the nearest integer.  <a href="structtatami_1_1DelayedRoundHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedSignHelper.html">DelayedSignHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the sign of a matrix entry.  <a href="structtatami_1_1DelayedSignHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedSinHelper.html">DelayedSinHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the sine of a matrix entry.  <a href="structtatami_1_1DelayedSinHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedSinhHelper.html">DelayedSinhHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the hyperbolic sine of a matrix entry.  <a href="structtatami_1_1DelayedSinhHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedSqrtHelper.html">DelayedSqrtHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the square root of a matrix entry.  <a href="structtatami_1_1DelayedSqrtHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedSubset.html">DelayedSubset</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed subsetting of a matrix with general indices.  <a href="classtatami_1_1DelayedSubset.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedSubsetBlock.html">DelayedSubsetBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed subsetting to a contiguous block.  <a href="classtatami_1_1DelayedSubsetBlock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedSubsetSorted.html">DelayedSubsetSorted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed subsetting of a matrix with sorted indices.  <a href="classtatami_1_1DelayedSubsetSorted.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html">DelayedSubsetSortedUnique</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed subsetting of a matrix with sorted, unique indices.  <a href="classtatami_1_1DelayedSubsetSortedUnique.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedSubsetUnique.html">DelayedSubsetUnique</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed subsetting of a matrix with unique indices.  <a href="classtatami_1_1DelayedSubsetUnique.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedTanHelper.html">DelayedTanHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the tangent of a matrix entry.  <a href="structtatami_1_1DelayedTanHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedTanhHelper.html">DelayedTanhHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the hyperbolic tangent of a matrix entry.  <a href="structtatami_1_1DelayedTanhHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedTranspose.html">DelayedTranspose</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed transposition of a matrix.  <a href="classtatami_1_1DelayedTranspose.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedTruncHelper.html">DelayedTruncHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the trunc of a matrix entry.  <a href="structtatami_1_1DelayedTruncHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricOp.html">DelayedUnaryIsometricOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed isometric operations on a single matrix.  <a href="classtatami_1_1DelayedUnaryIsometricOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DenseExtractor.html">DenseExtractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual base class for dense extraction.  <a href="classtatami_1_1DenseExtractor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DenseMatrix.html">DenseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dense matrix representation.  <a href="classtatami_1_1DenseMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1ExtractorBase.html">ExtractorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual base extractor class.  <a href="structtatami_1_1ExtractorBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1FixedOracle.html">FixedOracle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predict future accesses from a known sequence.  <a href="structtatami_1_1FixedOracle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1FragmentedSparseMatrix.html">FragmentedSparseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fragmented sparse matrix representation.  <a href="classtatami_1_1FragmentedSparseMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1FullExtractor.html">FullExtractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual base class for full access.  <a href="structtatami_1_1FullExtractor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1IndexExtractor.html">IndexExtractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual base class for indexed access.  <a href="structtatami_1_1IndexExtractor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1LayeredMatrixData.html">LayeredMatrixData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer and permutations for a layered sparse matrix.  <a href="structtatami_1_1LayeredMatrixData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1LruChunkCache.html">LruChunkCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">LRU cache for chunks.  <a href="classtatami_1_1LruChunkCache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html">Matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual class for a matrix with a defined type.  <a href="classtatami_1_1Matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1Options.html">Options</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structtatami_1_1Options.html" title="Options for iteration and extraction.">Options</a> for iteration and extraction.  <a href="structtatami_1_1Options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1Oracle.html">Oracle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predict future access requests.  <a href="structtatami_1_1Oracle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1OracleChunkCache.html">OracleChunkCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Oracle-aware cache for chunks.  <a href="classtatami_1_1OracleChunkCache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1OracleStream.html">OracleStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream predictions from the oracle.  <a href="structtatami_1_1OracleStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1SemiCompressedSparseMatrix.html">SemiCompressedSparseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Semi-compressed sparse matrix representation.  <a href="classtatami_1_1SemiCompressedSparseMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1SomeNumericArray.html">SomeNumericArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of some numeric type, determined at runtime.  <a href="structtatami_1_1SomeNumericArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1SparseExtractor.html">SparseExtractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual base class for sparse extraction.  <a href="classtatami_1_1SparseExtractor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A range of a sparse vector.  <a href="structtatami_1_1SparseRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1SparseRangeCopy.html">SparseRangeCopy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A range of a sparse vector with copying.  <a href="structtatami_1_1SparseRangeCopy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1VirtualDenseMatrix.html">VirtualDenseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual class for a dense matrix with a defined type.  <a href="classtatami_1_1VirtualDenseMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac47a769e00660eb7e9b5fcd543bcf2d3"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_  = int, class Storage_  = std::vector&lt;Value_&gt;&gt; </td></tr>
<tr class="memitem:ac47a769e00660eb7e9b5fcd543bcf2d3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ac47a769e00660eb7e9b5fcd543bcf2d3">DenseColumnMatrix</a> = <a class="el" href="classtatami_1_1DenseMatrix.html">DenseMatrix</a>&lt; false, Value_, Index_, Storage_ &gt;</td></tr>
<tr class="separator:ac47a769e00660eb7e9b5fcd543bcf2d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51122d20490b377cd3f4609cc044f314"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_  = int, class Storage_  = std::vector&lt;Value_&gt;&gt; </td></tr>
<tr class="memitem:a51122d20490b377cd3f4609cc044f314"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a51122d20490b377cd3f4609cc044f314">DenseRowMatrix</a> = <a class="el" href="classtatami_1_1DenseMatrix.html">DenseMatrix</a>&lt; true, Value_, Index_, Storage_ &gt;</td></tr>
<tr class="separator:a51122d20490b377cd3f4609cc044f314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ed61a4f772a2f7be4a12f739554e6e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#a0a2ecaf58e2b69bb4a808e814aeb16a1">DimensionSelectionType</a> selection_, typename Index_ &gt; </td></tr>
<tr class="memitem:a85ed61a4f772a2f7be4a12f739554e6e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a85ed61a4f772a2f7be4a12f739554e6e">ConditionalSelectionExtractor</a> = typename std::conditional&lt; selection_==DimensionSelectionType::FULL, <a class="el" href="structtatami_1_1FullExtractor.html">FullExtractor</a>&lt; Index_ &gt;, typename std::conditional&lt; selection_==DimensionSelectionType::BLOCK, <a class="el" href="structtatami_1_1BlockExtractor.html">BlockExtractor</a>&lt; Index_ &gt;, <a class="el" href="structtatami_1_1IndexExtractor.html">IndexExtractor</a>&lt; Index_ &gt; &gt;::type &gt;::type</td></tr>
<tr class="separator:a85ed61a4f772a2f7be4a12f739554e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f8db5316521603085577d977a6955f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#a0a2ecaf58e2b69bb4a808e814aeb16a1">DimensionSelectionType</a> selection_, bool sparse_, typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:ae9f8db5316521603085577d977a6955f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ae9f8db5316521603085577d977a6955f">Extractor</a> = typename std::conditional&lt; sparse_, <a class="el" href="classtatami_1_1SparseExtractor.html">SparseExtractor</a>&lt; selection_, Value_, Index_ &gt;, <a class="el" href="classtatami_1_1DenseExtractor.html">DenseExtractor</a>&lt; selection_, Value_, Index_ &gt; &gt;::type</td></tr>
<tr class="separator:ae9f8db5316521603085577d977a6955f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6008dbced6de41e5619156b5335f5762"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a6008dbced6de41e5619156b5335f5762"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a6008dbced6de41e5619156b5335f5762">FullDenseExtractor</a> = <a class="el" href="namespacetatami.html#ae9f8db5316521603085577d977a6955f">Extractor</a>&lt; DimensionSelectionType::FULL, false, Value_, Index_ &gt;</td></tr>
<tr class="separator:a6008dbced6de41e5619156b5335f5762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75de1fc78b7d361ea8b59a5379ea4da"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:ae75de1fc78b7d361ea8b59a5379ea4da"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ae75de1fc78b7d361ea8b59a5379ea4da">BlockDenseExtractor</a> = <a class="el" href="namespacetatami.html#ae9f8db5316521603085577d977a6955f">Extractor</a>&lt; DimensionSelectionType::BLOCK, false, Value_, Index_ &gt;</td></tr>
<tr class="separator:ae75de1fc78b7d361ea8b59a5379ea4da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ce406c32c3914c2ecce187e21b6ced"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a47ce406c32c3914c2ecce187e21b6ced"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a47ce406c32c3914c2ecce187e21b6ced">IndexDenseExtractor</a> = <a class="el" href="namespacetatami.html#ae9f8db5316521603085577d977a6955f">Extractor</a>&lt; DimensionSelectionType::INDEX, false, Value_, Index_ &gt;</td></tr>
<tr class="separator:a47ce406c32c3914c2ecce187e21b6ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fbb0624c8e1913a87e8fb5c975400e1"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a0fbb0624c8e1913a87e8fb5c975400e1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a0fbb0624c8e1913a87e8fb5c975400e1">FullSparseExtractor</a> = <a class="el" href="namespacetatami.html#ae9f8db5316521603085577d977a6955f">Extractor</a>&lt; DimensionSelectionType::FULL, true, Value_, Index_ &gt;</td></tr>
<tr class="separator:a0fbb0624c8e1913a87e8fb5c975400e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d0024399a66ce61f6315f5f46ebb63"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:ac8d0024399a66ce61f6315f5f46ebb63"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ac8d0024399a66ce61f6315f5f46ebb63">BlockSparseExtractor</a> = <a class="el" href="namespacetatami.html#ae9f8db5316521603085577d977a6955f">Extractor</a>&lt; DimensionSelectionType::BLOCK, true, Value_, Index_ &gt;</td></tr>
<tr class="separator:ac8d0024399a66ce61f6315f5f46ebb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b67b4d1b6c00cd0bd449703432a5f7b"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a4b67b4d1b6c00cd0bd449703432a5f7b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a4b67b4d1b6c00cd0bd449703432a5f7b">IndexSparseExtractor</a> = <a class="el" href="namespacetatami.html#ae9f8db5316521603085577d977a6955f">Extractor</a>&lt; DimensionSelectionType::INDEX, true, Value_, Index_ &gt;</td></tr>
<tr class="separator:a4b67b4d1b6c00cd0bd449703432a5f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c670894994f1d620abb55953f98441"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a35c670894994f1d620abb55953f98441">NumericMatrix</a> = <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; double, int &gt;</td></tr>
<tr class="separator:a35c670894994f1d620abb55953f98441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18cee3a5d9734f0092b03d023cfe4b6a"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ , class ValueStorage_  = std::vector&lt;Value_&gt;, class IndexStorage_  = std::vector&lt;Index_&gt;, class PointerStorage_  = std::vector&lt;size_t&gt;&gt; </td></tr>
<tr class="memitem:a18cee3a5d9734f0092b03d023cfe4b6a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a18cee3a5d9734f0092b03d023cfe4b6a">CompressedSparseColumnMatrix</a> = <a class="el" href="classtatami_1_1CompressedSparseMatrix.html">CompressedSparseMatrix</a>&lt; false, Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</td></tr>
<tr class="separator:a18cee3a5d9734f0092b03d023cfe4b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0111adeeb583aeb7e24e9e1e25be4aa0"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ , class ValueStorage_  = std::vector&lt;Value_&gt;, class IndexStorage_  = std::vector&lt;Index_&gt;, class PointerStorage_  = std::vector&lt;size_t&gt;&gt; </td></tr>
<tr class="memitem:a0111adeeb583aeb7e24e9e1e25be4aa0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a0111adeeb583aeb7e24e9e1e25be4aa0">CompressedSparseRowMatrix</a> = <a class="el" href="classtatami_1_1CompressedSparseMatrix.html">CompressedSparseMatrix</a>&lt; true, Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</td></tr>
<tr class="separator:a0111adeeb583aeb7e24e9e1e25be4aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9735bdc6e0a2856cd4747efbbf9f3c"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ , class ValueVectorStorage_  = std::vector&lt;std::vector&lt;Value_&gt; &gt;, class IndexVectorStorage_  = std::vector&lt;std::vector&lt;Index_&gt; &gt;&gt; </td></tr>
<tr class="memitem:a6b9735bdc6e0a2856cd4747efbbf9f3c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a6b9735bdc6e0a2856cd4747efbbf9f3c">FragmentedSparseColumnMatrix</a> = <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html">FragmentedSparseMatrix</a>&lt; false, Value_, Index_, ValueVectorStorage_, IndexVectorStorage_ &gt;</td></tr>
<tr class="separator:a6b9735bdc6e0a2856cd4747efbbf9f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d97fc9bd75052a79bb643d0fb5a0b98"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ , class ValueVectorStorage_  = std::vector&lt;std::vector&lt;Value_&gt; &gt;, class IndexVectorStorage_  = std::vector&lt;std::vector&lt;Index_&gt; &gt;&gt; </td></tr>
<tr class="memitem:a3d97fc9bd75052a79bb643d0fb5a0b98"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a3d97fc9bd75052a79bb643d0fb5a0b98">FragmentedSparseRowMatrix</a> = <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html">FragmentedSparseMatrix</a>&lt; true, Value_, Index_, ValueVectorStorage_, IndexVectorStorage_ &gt;</td></tr>
<tr class="separator:a3d97fc9bd75052a79bb643d0fb5a0b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f03d0d880bc056e09c2cbb80eb2c2ec"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ , class IndexStorage_  = std::vector&lt;Index_&gt;, class PointerStorage_  = std::vector&lt;size_t&gt;&gt; </td></tr>
<tr class="memitem:a6f03d0d880bc056e09c2cbb80eb2c2ec"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a6f03d0d880bc056e09c2cbb80eb2c2ec">SemiCompressedSparseColumnMatrix</a> = <a class="el" href="classtatami_1_1SemiCompressedSparseMatrix.html">SemiCompressedSparseMatrix</a>&lt; false, Value_, Index_, IndexStorage_, PointerStorage_ &gt;</td></tr>
<tr class="separator:a6f03d0d880bc056e09c2cbb80eb2c2ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412cb6ee12f3ee81d404d6eb0e494e4d"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ , class IndexStorage_  = std::vector&lt;Index_&gt;, class PointerStorage_  = std::vector&lt;size_t&gt;&gt; </td></tr>
<tr class="memitem:a412cb6ee12f3ee81d404d6eb0e494e4d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a412cb6ee12f3ee81d404d6eb0e494e4d">SemiCompressedSparseRowMatrix</a> = <a class="el" href="classtatami_1_1SemiCompressedSparseMatrix.html">SemiCompressedSparseMatrix</a>&lt; true, Value_, Index_, IndexStorage_, PointerStorage_ &gt;</td></tr>
<tr class="separator:a412cb6ee12f3ee81d404d6eb0e494e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b84d6bc16ba8e78d7bebf95d78b6221"><td class="memTemplParams" colspan="2"><a id="a2b84d6bc16ba8e78d7bebf95d78b6221" name="a2b84d6bc16ba8e78d7bebf95d78b6221"></a>
template&lt;class Storage_ &gt; </td></tr>
<tr class="memitem:a2b84d6bc16ba8e78d7bebf95d78b6221"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Stored</b> = typename std::remove_reference&lt; decltype(std::declval&lt; Storage_ &gt;()[0])&gt;::type</td></tr>
<tr class="separator:a2b84d6bc16ba8e78d7bebf95d78b6221"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a0a2ecaf58e2b69bb4a808e814aeb16a1"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a0a2ecaf58e2b69bb4a808e814aeb16a1">DimensionSelectionType</a> : char { <b>FULL</b>
, <b>BLOCK</b>
, <b>INDEX</b>
 }</td></tr>
<tr class="separator:a0a2ecaf58e2b69bb4a808e814aeb16a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab44a37b3762de0c5b1ffbfceb25fa0f"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#aab44a37b3762de0c5b1ffbfceb25fa0f">DelayedArithOp</a> : char { <b>ADD</b>
, <b>SUBTRACT</b>
, <b>MULTIPLY</b>
, <b>DIVIDE</b>
 }</td></tr>
<tr class="separator:aab44a37b3762de0c5b1ffbfceb25fa0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2104862d4068933ea4cc805c92f82d07"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a2104862d4068933ea4cc805c92f82d07">DelayedBooleanOp</a> : char { <b>AND</b>
, <b>OR</b>
, <b>XOR</b>
, <b>EQUAL</b>
 }</td></tr>
<tr class="separator:a2104862d4068933ea4cc805c92f82d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4fc175a57ace709941b5ca7ddb19708"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ac4fc175a57ace709941b5ca7ddb19708">DelayedCompareOp</a> : char { <br />
&#160;&#160;<b>EQUAL</b>
, <b>GREATER_THAN</b>
, <b>LESS_THAN</b>
, <b>GREATER_THAN_OR_EQUAL</b>
, <br />
&#160;&#160;<b>LESS_THAN_OR_EQUAL</b>
, <b>NOT_EQUAL</b>
<br />
 }</td></tr>
<tr class="separator:ac4fc175a57ace709941b5ca7ddb19708"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af9d13ceaa112d2c091265510d741488d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#a0a2ecaf58e2b69bb4a808e814aeb16a1">DimensionSelectionType</a> selection_, typename Index_ &gt; </td></tr>
<tr class="memitem:af9d13ceaa112d2c091265510d741488d"><td class="memTemplItemLeft" align="right" valign="top">Index_&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#af9d13ceaa112d2c091265510d741488d">extracted_length</a> (const <a class="el" href="namespacetatami.html#a85ed61a4f772a2f7be4a12f739554e6e">ConditionalSelectionExtractor</a>&lt; selection_, Index_ &gt; &amp;ex)</td></tr>
<tr class="separator:af9d13ceaa112d2c091265510d741488d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8e0f69139575707aa9314174b415b3"><td class="memTemplParams" colspan="2">template&lt;int margin_, typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a5f8e0f69139575707aa9314174b415b3"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a5f8e0f69139575707aa9314174b415b3">make_DelayedBind</a> (std::vector&lt; std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; &gt; ps)</td></tr>
<tr class="separator:a5f8e0f69139575707aa9314174b415b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca62c3bf751cdd06a08e8e503b0b591a"><td class="memTemplParams" colspan="2">template&lt;typename Value_out_ , typename Index_out_ , typename Value_in_ , typename Index_in_ &gt; </td></tr>
<tr class="memitem:aca62c3bf751cdd06a08e8e503b0b591a"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_out_, Index_out_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#aca62c3bf751cdd06a08e8e503b0b591a">make_DelayedCast</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_in_, Index_in_ &gt; &gt; p)</td></tr>
<tr class="separator:aca62c3bf751cdd06a08e8e503b0b591a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa35d8e9fe286967f327ec0eb6bd5005"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:afa35d8e9fe286967f327ec0eb6bd5005"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#afa35d8e9fe286967f327ec0eb6bd5005">make_DelayedTranspose</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; p)</td></tr>
<tr class="separator:afa35d8e9fe286967f327ec0eb6bd5005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f4aafc0a1fbdc0c31bc122d24122a63"><td class="memTemplParams" colspan="2">template&lt;int margin_, typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a8f4aafc0a1fbdc0c31bc122d24122a63"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a8f4aafc0a1fbdc0c31bc122d24122a63">make_DelayedSubsetBlock</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; p, Index_ f, Index_ l)</td></tr>
<tr class="separator:a8f4aafc0a1fbdc0c31bc122d24122a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc63177b00e6e3e2fa47754b8d87704"><td class="memTemplParams" colspan="2">template&lt;int margin_, typename Value_ , typename Index_ , class IndexStorage_ &gt; </td></tr>
<tr class="memitem:abfc63177b00e6e3e2fa47754b8d87704"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#abfc63177b00e6e3e2fa47754b8d87704">make_DelayedSubset</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; p, IndexStorage_ idx)</td></tr>
<tr class="separator:abfc63177b00e6e3e2fa47754b8d87704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b6638dceda82d82a7579dc88a45709"><td class="memTemplParams" colspan="2">template&lt;bool row_, bool sparse_, typename Value_ , typename Index_ , typename ... Args_&gt; </td></tr>
<tr class="memitem:a95b6638dceda82d82a7579dc88a45709"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a95b6638dceda82d82a7579dc88a45709">new_extractor</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *ptr, Args_ &amp;&amp;... args)</td></tr>
<tr class="separator:a95b6638dceda82d82a7579dc88a45709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d138b1e7f6a26f814c025363cc3db80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBinaryArithHelper.html">DelayedBinaryArithHelper</a>&lt; DelayedArithOp::ADD &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a1d138b1e7f6a26f814c025363cc3db80">make_DelayedBinaryAddHelper</a> ()</td></tr>
<tr class="separator:a1d138b1e7f6a26f814c025363cc3db80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c951d489cb0f2bb0e90f2cf4a25862"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBinaryArithHelper.html">DelayedBinaryArithHelper</a>&lt; DelayedArithOp::SUBTRACT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ac4c951d489cb0f2bb0e90f2cf4a25862">make_DelayedBinarySubtractHelper</a> ()</td></tr>
<tr class="separator:ac4c951d489cb0f2bb0e90f2cf4a25862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2569c540083a24f92af8140358e1e9c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBinaryArithHelper.html">DelayedBinaryArithHelper</a>&lt; DelayedArithOp::MULTIPLY &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a2569c540083a24f92af8140358e1e9c4">make_DelayedBinaryMultiplyHelper</a> ()</td></tr>
<tr class="separator:a2569c540083a24f92af8140358e1e9c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4cf766f850766b966f7121728a6af8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBinaryArithHelper.html">DelayedBinaryArithHelper</a>&lt; DelayedArithOp::DIVIDE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#aeb4cf766f850766b966f7121728a6af8">make_DelayedBinaryDivideHelper</a> ()</td></tr>
<tr class="separator:aeb4cf766f850766b966f7121728a6af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1063aea86897ef76e17b1772320b8f7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBinaryBooleanHelper.html">DelayedBinaryBooleanHelper</a>&lt; DelayedBooleanOp::EQUAL &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a1063aea86897ef76e17b1772320b8f7d">make_DelayedBinaryBooleanEqualHelper</a> ()</td></tr>
<tr class="separator:a1063aea86897ef76e17b1772320b8f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31625dbb50d420fe1b0da406f19ef33d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBinaryBooleanHelper.html">DelayedBinaryBooleanHelper</a>&lt; DelayedBooleanOp::AND &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a31625dbb50d420fe1b0da406f19ef33d">make_DelayedBinaryBooleanAndHelper</a> ()</td></tr>
<tr class="separator:a31625dbb50d420fe1b0da406f19ef33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65bad100b39d9372fbeb23d16dae6588"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBinaryBooleanHelper.html">DelayedBinaryBooleanHelper</a>&lt; DelayedBooleanOp::OR &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a65bad100b39d9372fbeb23d16dae6588">make_DelayedBinaryBooleanOrHelper</a> ()</td></tr>
<tr class="separator:a65bad100b39d9372fbeb23d16dae6588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb091953ab0f55406935a52b7ecb7350"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBinaryBooleanHelper.html">DelayedBinaryBooleanHelper</a>&lt; DelayedBooleanOp::XOR &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#aeb091953ab0f55406935a52b7ecb7350">make_DelayedBinaryBooleanXorHelper</a> ()</td></tr>
<tr class="separator:aeb091953ab0f55406935a52b7ecb7350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3599db8f6d19fc9172da45a3b6244fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBinaryCompareHelper.html">DelayedBinaryCompareHelper</a>&lt; DelayedCompareOp::EQUAL &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ac3599db8f6d19fc9172da45a3b6244fc">make_DelayedBinaryEqualHelper</a> ()</td></tr>
<tr class="separator:ac3599db8f6d19fc9172da45a3b6244fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4fb79c5a2cddab2f5c9cf0bd9fe3d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBinaryCompareHelper.html">DelayedBinaryCompareHelper</a>&lt; DelayedCompareOp::GREATER_THAN &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#abe4fb79c5a2cddab2f5c9cf0bd9fe3d0">make_DelayedBinaryGreaterThanHelper</a> ()</td></tr>
<tr class="separator:abe4fb79c5a2cddab2f5c9cf0bd9fe3d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a24f5bf2c2c61382aef43f2c8d3362"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBinaryCompareHelper.html">DelayedBinaryCompareHelper</a>&lt; DelayedCompareOp::LESS_THAN &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ae6a24f5bf2c2c61382aef43f2c8d3362">make_DelayedBinaryLessThanHelper</a> ()</td></tr>
<tr class="separator:ae6a24f5bf2c2c61382aef43f2c8d3362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31cd299427d73538dc00dcbffa9cd2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBinaryCompareHelper.html">DelayedBinaryCompareHelper</a>&lt; DelayedCompareOp::GREATER_THAN_OR_EQUAL &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ad31cd299427d73538dc00dcbffa9cd2b">make_DelayedBinaryGreaterThanOrEqualHelper</a> ()</td></tr>
<tr class="separator:ad31cd299427d73538dc00dcbffa9cd2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c7cc26409e5c995b7264164b148f4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBinaryCompareHelper.html">DelayedBinaryCompareHelper</a>&lt; DelayedCompareOp::LESS_THAN_OR_EQUAL &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a38c7cc26409e5c995b7264164b148f4c">make_DelayedBinaryLessThanOrEqualHelper</a> ()</td></tr>
<tr class="separator:a38c7cc26409e5c995b7264164b148f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3073c4e33dcf89416af292399ba55c29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBinaryCompareHelper.html">DelayedBinaryCompareHelper</a>&lt; DelayedCompareOp::NOT_EQUAL &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a3073c4e33dcf89416af292399ba55c29">make_DelayedBinaryNotEqualHelper</a> ()</td></tr>
<tr class="separator:a3073c4e33dcf89416af292399ba55c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39c0767d23c6bdc5f4267f062ef2e17"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ , class Operation_ &gt; </td></tr>
<tr class="memitem:af39c0767d23c6bdc5f4267f062ef2e17"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#af39c0767d23c6bdc5f4267f062ef2e17">make_DelayedBinaryIsometricOp</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; left, std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; right, Operation_ op)</td></tr>
<tr class="separator:af39c0767d23c6bdc5f4267f062ef2e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d637bdfb7f4126ded39f6e06b04d3a"><td class="memTemplParams" colspan="2">template&lt;typename Scalar_ &gt; </td></tr>
<tr class="memitem:ac0d637bdfb7f4126ded39f6e06b04d3a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedArithScalarHelper.html">DelayedArithScalarHelper</a>&lt; DelayedArithOp::ADD, true, Scalar_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ac0d637bdfb7f4126ded39f6e06b04d3a">make_DelayedAddScalarHelper</a> (Scalar_ s)</td></tr>
<tr class="separator:ac0d637bdfb7f4126ded39f6e06b04d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f42d3fa38192c46b1fbd89ffbc96ef"><td class="memTemplParams" colspan="2">template&lt;bool right_, typename Scalar_ &gt; </td></tr>
<tr class="memitem:a54f42d3fa38192c46b1fbd89ffbc96ef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedArithScalarHelper.html">DelayedArithScalarHelper</a>&lt; DelayedArithOp::SUBTRACT, right_, Scalar_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a54f42d3fa38192c46b1fbd89ffbc96ef">make_DelayedSubtractScalarHelper</a> (Scalar_ s)</td></tr>
<tr class="separator:a54f42d3fa38192c46b1fbd89ffbc96ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ae6b934c10ef1ba28be1bc0f3316db"><td class="memTemplParams" colspan="2">template&lt;typename Scalar_ &gt; </td></tr>
<tr class="memitem:ab2ae6b934c10ef1ba28be1bc0f3316db"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedArithScalarHelper.html">DelayedArithScalarHelper</a>&lt; DelayedArithOp::MULTIPLY, true, Scalar_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ab2ae6b934c10ef1ba28be1bc0f3316db">make_DelayedMultiplyScalarHelper</a> (Scalar_ s)</td></tr>
<tr class="separator:ab2ae6b934c10ef1ba28be1bc0f3316db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37bafee11663e77fd079b7df8c542b41"><td class="memTemplParams" colspan="2">template&lt;bool right_, typename Scalar_ &gt; </td></tr>
<tr class="memitem:a37bafee11663e77fd079b7df8c542b41"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedArithScalarHelper.html">DelayedArithScalarHelper</a>&lt; DelayedArithOp::DIVIDE, right_, Scalar_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a37bafee11663e77fd079b7df8c542b41">make_DelayedDivideScalarHelper</a> (Scalar_ s)</td></tr>
<tr class="separator:a37bafee11663e77fd079b7df8c542b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d82c78f9847f7f3d7b1924736dc08a"><td class="memTemplParams" colspan="2">template&lt;int margin_, typename Vector_ &gt; </td></tr>
<tr class="memitem:a18d82c78f9847f7f3d7b1924736dc08a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedArithVectorHelper.html">DelayedArithVectorHelper</a>&lt; DelayedArithOp::ADD, true, margin_, Vector_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a18d82c78f9847f7f3d7b1924736dc08a">make_DelayedAddVectorHelper</a> (Vector_ v)</td></tr>
<tr class="separator:a18d82c78f9847f7f3d7b1924736dc08a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10ad8ba2f67e03997a70bcf344cd0b5"><td class="memTemplParams" colspan="2">template&lt;bool right_, int margin_, typename Vector_ &gt; </td></tr>
<tr class="memitem:ae10ad8ba2f67e03997a70bcf344cd0b5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedArithVectorHelper.html">DelayedArithVectorHelper</a>&lt; DelayedArithOp::SUBTRACT, right_, margin_, Vector_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ae10ad8ba2f67e03997a70bcf344cd0b5">make_DelayedSubtractVectorHelper</a> (Vector_ v)</td></tr>
<tr class="separator:ae10ad8ba2f67e03997a70bcf344cd0b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5028a7b69c08ecec87064d7b3d83b41"><td class="memTemplParams" colspan="2">template&lt;int margin_, typename Vector_ &gt; </td></tr>
<tr class="memitem:ab5028a7b69c08ecec87064d7b3d83b41"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedArithVectorHelper.html">DelayedArithVectorHelper</a>&lt; DelayedArithOp::MULTIPLY, true, margin_, Vector_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ab5028a7b69c08ecec87064d7b3d83b41">make_DelayedMultiplyVectorHelper</a> (Vector_ v)</td></tr>
<tr class="separator:ab5028a7b69c08ecec87064d7b3d83b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214dedde7eb472684ce66ec4ba26e77c"><td class="memTemplParams" colspan="2">template&lt;bool right_, int margin_, typename Vector_ &gt; </td></tr>
<tr class="memitem:a214dedde7eb472684ce66ec4ba26e77c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedArithVectorHelper.html">DelayedArithVectorHelper</a>&lt; DelayedArithOp::DIVIDE, right_, margin_, Vector_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a214dedde7eb472684ce66ec4ba26e77c">make_DelayedDivideVectorHelper</a> (Vector_ v)</td></tr>
<tr class="separator:a214dedde7eb472684ce66ec4ba26e77c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1eab4687167d073231e35c032f61275"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBooleanNotHelper.html">DelayedBooleanNotHelper</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ac1eab4687167d073231e35c032f61275">make_DelayedBooleanNotHelper</a> ()</td></tr>
<tr class="separator:ac1eab4687167d073231e35c032f61275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f2492704a466130db315a980f3cdd47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBooleanScalarHelper.html">DelayedBooleanScalarHelper</a>&lt; DelayedBooleanOp::AND &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a3f2492704a466130db315a980f3cdd47">make_DelayedBooleanAndScalarHelper</a> (bool s)</td></tr>
<tr class="separator:a3f2492704a466130db315a980f3cdd47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c9fc77d5cdbf54dfac07da1e3bfd38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBooleanScalarHelper.html">DelayedBooleanScalarHelper</a>&lt; DelayedBooleanOp::OR &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a90c9fc77d5cdbf54dfac07da1e3bfd38">make_DelayedBooleanOrScalarHelper</a> (bool s)</td></tr>
<tr class="separator:a90c9fc77d5cdbf54dfac07da1e3bfd38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53fbda6886dc05059a1517d6932da7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBooleanScalarHelper.html">DelayedBooleanScalarHelper</a>&lt; DelayedBooleanOp::XOR &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ad53fbda6886dc05059a1517d6932da7f">make_DelayedBooleanXorScalarHelper</a> (bool s)</td></tr>
<tr class="separator:ad53fbda6886dc05059a1517d6932da7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf1862b291e7f537a0e7745666fa8303"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBooleanScalarHelper.html">DelayedBooleanScalarHelper</a>&lt; DelayedBooleanOp::EQUAL &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#abf1862b291e7f537a0e7745666fa8303">make_DelayedBooleanEqualScalarHelper</a> (bool s)</td></tr>
<tr class="separator:abf1862b291e7f537a0e7745666fa8303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df2f96c32ef81f513f571c4bb24dbab"><td class="memTemplParams" colspan="2">template&lt;int margin_, typename Vector_ &gt; </td></tr>
<tr class="memitem:a5df2f96c32ef81f513f571c4bb24dbab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBooleanVectorHelper.html">DelayedBooleanVectorHelper</a>&lt; DelayedBooleanOp::AND, margin_, Vector_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a5df2f96c32ef81f513f571c4bb24dbab">make_DelayedBooleanAndVectorHelper</a> (Vector_ v)</td></tr>
<tr class="separator:a5df2f96c32ef81f513f571c4bb24dbab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae774f806fbfb728cde3f3d23c9da36de"><td class="memTemplParams" colspan="2">template&lt;int margin_, typename Vector_ &gt; </td></tr>
<tr class="memitem:ae774f806fbfb728cde3f3d23c9da36de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBooleanVectorHelper.html">DelayedBooleanVectorHelper</a>&lt; DelayedBooleanOp::OR, margin_, Vector_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ae774f806fbfb728cde3f3d23c9da36de">make_DelayedBooleanOrVectorHelper</a> (Vector_ v)</td></tr>
<tr class="separator:ae774f806fbfb728cde3f3d23c9da36de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca166576eae6f35fc987340bbef9310c"><td class="memTemplParams" colspan="2">template&lt;int margin_, typename Vector_ &gt; </td></tr>
<tr class="memitem:aca166576eae6f35fc987340bbef9310c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBooleanVectorHelper.html">DelayedBooleanVectorHelper</a>&lt; DelayedBooleanOp::XOR, margin_, Vector_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#aca166576eae6f35fc987340bbef9310c">make_DelayedBooleanXorVectorHelper</a> (Vector_ v)</td></tr>
<tr class="separator:aca166576eae6f35fc987340bbef9310c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a1f4e7fec3b8b57aed9b02f06bbab5"><td class="memTemplParams" colspan="2">template&lt;int margin_, typename Vector_ &gt; </td></tr>
<tr class="memitem:a94a1f4e7fec3b8b57aed9b02f06bbab5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBooleanVectorHelper.html">DelayedBooleanVectorHelper</a>&lt; DelayedBooleanOp::EQUAL, margin_, Vector_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a94a1f4e7fec3b8b57aed9b02f06bbab5">make_DelayedBooleanEqualVectorHelper</a> (Vector_ v)</td></tr>
<tr class="separator:a94a1f4e7fec3b8b57aed9b02f06bbab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac33adddd59d925a091b66c75b22b8eca"><td class="memTemplParams" colspan="2">template&lt;typename Scalar_ &gt; </td></tr>
<tr class="memitem:ac33adddd59d925a091b66c75b22b8eca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedCompareScalarHelper.html">DelayedCompareScalarHelper</a>&lt; DelayedCompareOp::EQUAL, Scalar_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ac33adddd59d925a091b66c75b22b8eca">make_DelayedEqualScalarHelper</a> (Scalar_ s)</td></tr>
<tr class="separator:ac33adddd59d925a091b66c75b22b8eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f548d89e93cbeaf155df8307a08fc00"><td class="memTemplParams" colspan="2">template&lt;typename Scalar_ &gt; </td></tr>
<tr class="memitem:a6f548d89e93cbeaf155df8307a08fc00"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedCompareScalarHelper.html">DelayedCompareScalarHelper</a>&lt; DelayedCompareOp::GREATER_THAN, Scalar_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a6f548d89e93cbeaf155df8307a08fc00">make_DelayedGreaterThanScalarHelper</a> (Scalar_ s)</td></tr>
<tr class="separator:a6f548d89e93cbeaf155df8307a08fc00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b7349067d32a27deff236ca230be92"><td class="memTemplParams" colspan="2">template&lt;typename Scalar_ &gt; </td></tr>
<tr class="memitem:a16b7349067d32a27deff236ca230be92"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedCompareScalarHelper.html">DelayedCompareScalarHelper</a>&lt; DelayedCompareOp::LESS_THAN, Scalar_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a16b7349067d32a27deff236ca230be92">make_DelayedLessThanScalarHelper</a> (Scalar_ s)</td></tr>
<tr class="separator:a16b7349067d32a27deff236ca230be92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83dd57b5347e89cf434582059254e09e"><td class="memTemplParams" colspan="2">template&lt;typename Scalar_ &gt; </td></tr>
<tr class="memitem:a83dd57b5347e89cf434582059254e09e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedCompareScalarHelper.html">DelayedCompareScalarHelper</a>&lt; DelayedCompareOp::GREATER_THAN_OR_EQUAL, Scalar_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a83dd57b5347e89cf434582059254e09e">make_DelayedGreaterThanOrEqualScalarHelper</a> (Scalar_ s)</td></tr>
<tr class="separator:a83dd57b5347e89cf434582059254e09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d6a0a320c318c4c3cf4874965562ce"><td class="memTemplParams" colspan="2">template&lt;typename Scalar_ &gt; </td></tr>
<tr class="memitem:a92d6a0a320c318c4c3cf4874965562ce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedCompareScalarHelper.html">DelayedCompareScalarHelper</a>&lt; DelayedCompareOp::LESS_THAN_OR_EQUAL, Scalar_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a92d6a0a320c318c4c3cf4874965562ce">make_DelayedLessThanOrEqualScalarHelper</a> (Scalar_ s)</td></tr>
<tr class="separator:a92d6a0a320c318c4c3cf4874965562ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b9934b71e5f6d28b8c7f87a8216972"><td class="memTemplParams" colspan="2">template&lt;typename Scalar_ &gt; </td></tr>
<tr class="memitem:a27b9934b71e5f6d28b8c7f87a8216972"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedCompareScalarHelper.html">DelayedCompareScalarHelper</a>&lt; DelayedCompareOp::NOT_EQUAL, Scalar_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a27b9934b71e5f6d28b8c7f87a8216972">make_DelayedNotEqualScalarHelper</a> (Scalar_ s)</td></tr>
<tr class="separator:a27b9934b71e5f6d28b8c7f87a8216972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258d8a40e2107e890ed9729d8134702a"><td class="memTemplParams" colspan="2">template&lt;int margin_, typename Vector_ &gt; </td></tr>
<tr class="memitem:a258d8a40e2107e890ed9729d8134702a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedCompareVectorHelper.html">DelayedCompareVectorHelper</a>&lt; DelayedCompareOp::EQUAL, margin_, Vector_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a258d8a40e2107e890ed9729d8134702a">make_DelayedEqualVectorHelper</a> (Vector_ v)</td></tr>
<tr class="separator:a258d8a40e2107e890ed9729d8134702a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8830d636d91bd512aca9c5afb8a10226"><td class="memTemplParams" colspan="2">template&lt;int margin_, typename Vector_ &gt; </td></tr>
<tr class="memitem:a8830d636d91bd512aca9c5afb8a10226"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedCompareVectorHelper.html">DelayedCompareVectorHelper</a>&lt; DelayedCompareOp::GREATER_THAN, margin_, Vector_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a8830d636d91bd512aca9c5afb8a10226">make_DelayedGreaterThanVectorHelper</a> (Vector_ v)</td></tr>
<tr class="separator:a8830d636d91bd512aca9c5afb8a10226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0dac7e0b22aa6d2d5cf1291d57ca5c"><td class="memTemplParams" colspan="2">template&lt;int margin_, typename Vector_ &gt; </td></tr>
<tr class="memitem:a0e0dac7e0b22aa6d2d5cf1291d57ca5c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedCompareVectorHelper.html">DelayedCompareVectorHelper</a>&lt; DelayedCompareOp::LESS_THAN, margin_, Vector_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a0e0dac7e0b22aa6d2d5cf1291d57ca5c">make_DelayedLessThanVectorHelper</a> (Vector_ v)</td></tr>
<tr class="separator:a0e0dac7e0b22aa6d2d5cf1291d57ca5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4342079e4437b82cfdb80e9ad6aba34e"><td class="memTemplParams" colspan="2">template&lt;int margin_, typename Vector_ &gt; </td></tr>
<tr class="memitem:a4342079e4437b82cfdb80e9ad6aba34e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedCompareVectorHelper.html">DelayedCompareVectorHelper</a>&lt; DelayedCompareOp::GREATER_THAN_OR_EQUAL, margin_, Vector_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a4342079e4437b82cfdb80e9ad6aba34e">make_DelayedGreaterThanOrEqualVectorHelper</a> (Vector_ v)</td></tr>
<tr class="separator:a4342079e4437b82cfdb80e9ad6aba34e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3e3ef7cd498ae62b383f8c34b0b43b"><td class="memTemplParams" colspan="2">template&lt;int margin_, typename Vector_ &gt; </td></tr>
<tr class="memitem:a8a3e3ef7cd498ae62b383f8c34b0b43b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedCompareVectorHelper.html">DelayedCompareVectorHelper</a>&lt; DelayedCompareOp::LESS_THAN_OR_EQUAL, margin_, Vector_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a8a3e3ef7cd498ae62b383f8c34b0b43b">make_DelayedLessThanOrEqualVectorHelper</a> (Vector_ v)</td></tr>
<tr class="separator:a8a3e3ef7cd498ae62b383f8c34b0b43b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6cdc6ca323706821899c20f00e42c52"><td class="memTemplParams" colspan="2">template&lt;int margin_, typename Vector_ &gt; </td></tr>
<tr class="memitem:ab6cdc6ca323706821899c20f00e42c52"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedCompareVectorHelper.html">DelayedCompareVectorHelper</a>&lt; DelayedCompareOp::NOT_EQUAL, margin_, Vector_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ab6cdc6ca323706821899c20f00e42c52">make_DelayedNotEqualVectorHelper</a> (Vector_ v)</td></tr>
<tr class="separator:ab6cdc6ca323706821899c20f00e42c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b072944c766d85dc4ce4dc734e0b75"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ , class Operation_ &gt; </td></tr>
<tr class="memitem:a07b072944c766d85dc4ce4dc734e0b75"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a07b072944c766d85dc4ce4dc734e0b75">make_DelayedUnaryIsometricOp</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; p, Operation_ op)</td></tr>
<tr class="separator:a07b072944c766d85dc4ce4dc734e0b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44202790861791b1ed9df6d480c69f6a"><td class="memTemplParams" colspan="2">template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a44202790861791b1ed9df6d480c69f6a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Output_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a44202790861791b1ed9df6d480c69f6a">column_medians</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *p, int threads=1)</td></tr>
<tr class="separator:a44202790861791b1ed9df6d480c69f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab877f67694b3fa500f59469f044b1c01"><td class="memTemplParams" colspan="2">template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:ab877f67694b3fa500f59469f044b1c01"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Output_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ab877f67694b3fa500f59469f044b1c01">row_medians</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *p, int threads=1)</td></tr>
<tr class="separator:ab877f67694b3fa500f59469f044b1c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8102a2423efab5e329543f4235ac2290"><td class="memTemplParams" colspan="2">template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a8102a2423efab5e329543f4235ac2290"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Output_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a8102a2423efab5e329543f4235ac2290">column_maxs</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *p, int threads=1)</td></tr>
<tr class="separator:a8102a2423efab5e329543f4235ac2290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47890bfd538f65971f9e5dba5e1ed785"><td class="memTemplParams" colspan="2">template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a47890bfd538f65971f9e5dba5e1ed785"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Output_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a47890bfd538f65971f9e5dba5e1ed785">row_maxs</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *p, int threads=1)</td></tr>
<tr class="separator:a47890bfd538f65971f9e5dba5e1ed785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e44772f82183100c7c25c181479b56"><td class="memTemplParams" colspan="2">template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a60e44772f82183100c7c25c181479b56"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Output_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a60e44772f82183100c7c25c181479b56">column_mins</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *p, int threads=1)</td></tr>
<tr class="separator:a60e44772f82183100c7c25c181479b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bcdcb0499b36b5b844ebd88fc30eefe"><td class="memTemplParams" colspan="2">template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a3bcdcb0499b36b5b844ebd88fc30eefe"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Output_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a3bcdcb0499b36b5b844ebd88fc30eefe">row_mins</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *p, int threads=1)</td></tr>
<tr class="separator:a3bcdcb0499b36b5b844ebd88fc30eefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5eff79824930c458e730d23f640c1ab"><td class="memTemplParams" colspan="2">template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:ab5eff79824930c458e730d23f640c1ab"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; Output_ &gt;, std::vector&lt; Output_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ab5eff79824930c458e730d23f640c1ab">column_ranges</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *p, int threads=1)</td></tr>
<tr class="separator:ab5eff79824930c458e730d23f640c1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2475a166ad744b31b1275e26e562be"><td class="memTemplParams" colspan="2">template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a2b2475a166ad744b31b1275e26e562be"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; Output_ &gt;, std::vector&lt; Output_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a2b2475a166ad744b31b1275e26e562be">row_ranges</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *p, int threads=1)</td></tr>
<tr class="separator:a2b2475a166ad744b31b1275e26e562be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aab6733d637b66abdf45f7300d2e1ba"><td class="memTemplParams" colspan="2">template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a3aab6733d637b66abdf45f7300d2e1ba"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Output_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a3aab6733d637b66abdf45f7300d2e1ba">column_sums</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *p, int threads=1)</td></tr>
<tr class="separator:a3aab6733d637b66abdf45f7300d2e1ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a658059404691856bef57fb85d83d6"><td class="memTemplParams" colspan="2">template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a53a658059404691856bef57fb85d83d6"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Output_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a53a658059404691856bef57fb85d83d6">row_sums</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *p, int threads=1)</td></tr>
<tr class="separator:a53a658059404691856bef57fb85d83d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ce7a2219ea60d45de1aa3d4de66063"><td class="memTemplParams" colspan="2">template&lt;bool parallel_ = true, class Function_ &gt; </td></tr>
<tr class="memitem:a29ce7a2219ea60d45de1aa3d4de66063"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a29ce7a2219ea60d45de1aa3d4de66063">parallelize</a> (Function_ fun, size_t tasks, size_t threads)</td></tr>
<tr class="separator:a29ce7a2219ea60d45de1aa3d4de66063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c6ecf33bcb87e1ed33c0a7d744dd82"><td class="memTemplParams" colspan="2">template&lt;bool row_, bool sparse_, typename Value_ , typename Index_ , typename ... Args_&gt; </td></tr>
<tr class="memitem:a36c6ecf33bcb87e1ed33c0a7d744dd82"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a36c6ecf33bcb87e1ed33c0a7d744dd82">consecutive_extractor</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *mat, Index_ iter_start, Index_ iter_length, Args_ &amp;&amp;... args)</td></tr>
<tr class="separator:a36c6ecf33bcb87e1ed33c0a7d744dd82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac37af9a76d15f08a3634881696a27f65"><td class="memTemplParams" colspan="2">template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:ac37af9a76d15f08a3634881696a27f65"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Output_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ac37af9a76d15f08a3634881696a27f65">column_variances</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *p, int threads=1)</td></tr>
<tr class="separator:ac37af9a76d15f08a3634881696a27f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab806279616e19f6150376a7c07d5b64b"><td class="memTemplParams" colspan="2">template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:ab806279616e19f6150376a7c07d5b64b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Output_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ab806279616e19f6150376a7c07d5b64b">row_variances</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *p, int threads=1)</td></tr>
<tr class="separator:ab806279616e19f6150376a7c07d5b64b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c52cf8a974ad0025550b002d391d39"><td class="memTemplParams" colspan="2">template&lt;int margin, class <a class="el" href="classtatami_1_1Matrix.html">Matrix</a> , typename Id &gt; </td></tr>
<tr class="memitem:a87c52cf8a974ad0025550b002d391d39"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a> &gt;, std::vector&lt; size_t &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a87c52cf8a974ad0025550b002d391d39">bind_intersection</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a> &gt; &gt; &amp;inputs, const std::vector&lt; const Id * &gt; &amp;ids)</td></tr>
<tr class="separator:a87c52cf8a974ad0025550b002d391d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17e92414b0bff60f7b7a6431ac8a330"><td class="memTemplParams" colspan="2">template&lt;bool ROW, class U , class V , class W &gt; </td></tr>
<tr class="memitem:ab17e92414b0bff60f7b7a6431ac8a330"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ab17e92414b0bff60f7b7a6431ac8a330">compress_sparse_triplets</a> (size_t nr, size_t nc, U &amp;values, V &amp;rows, W &amp;cols)</td></tr>
<tr class="separator:ab17e92414b0bff60f7b7a6431ac8a330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaccb18d22f35a4ed6b6a7091342da06"><td class="memTemplParams" colspan="2">template&lt;bool row_, typename StoredValue_ , class Matrix_ &gt; </td></tr>
<tr class="memitem:afaccb18d22f35a4ed6b6a7091342da06"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#afaccb18d22f35a4ed6b6a7091342da06">convert_to_dense</a> (const Matrix_ *incoming, StoredValue_ *store, int threads=1)</td></tr>
<tr class="separator:afaccb18d22f35a4ed6b6a7091342da06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80143ac537339fe8dafd892632e96de"><td class="memTemplParams" colspan="2">template&lt;bool row_, typename Value_  = double, typename Index  = int, typename StoredValue_  = Value_, class Matrix_ &gt; </td></tr>
<tr class="memitem:af80143ac537339fe8dafd892632e96de"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#af80143ac537339fe8dafd892632e96de">convert_to_dense</a> (const Matrix_ *incoming, int threads=1)</td></tr>
<tr class="separator:af80143ac537339fe8dafd892632e96de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e8745f8aaaa5ad93c6ce65a0a6591e"><td class="memTemplParams" colspan="2">template&lt;typename Value_  = double, typename Index_  = int, typename StoredValue_  = Value_, class Matrix_ &gt; </td></tr>
<tr class="memitem:a64e8745f8aaaa5ad93c6ce65a0a6591e"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a64e8745f8aaaa5ad93c6ce65a0a6591e">convert_to_dense</a> (const Matrix_ *incoming, int order, int threads=1)</td></tr>
<tr class="separator:a64e8745f8aaaa5ad93c6ce65a0a6591e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220c47e470b3ade64ede7303e50ca92d"><td class="memTemplParams" colspan="2">template&lt;bool row_, typename Value_  = double, typename Index_  = int, typename StoredValue_  = Value_, typename StoredIndex_  = Index_, class InputMatrix_ &gt; </td></tr>
<tr class="memitem:a220c47e470b3ade64ede7303e50ca92d"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a220c47e470b3ade64ede7303e50ca92d">convert_to_sparse</a> (const InputMatrix_ *incoming, int threads=1)</td></tr>
<tr class="separator:a220c47e470b3ade64ede7303e50ca92d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5847f3cd78ce89170ca43262d7f5f8e3"><td class="memTemplParams" colspan="2">template&lt;typename Value_  = double, typename Index_  = int, typename StoredValue_  = Value_, typename StoredIndex_  = Index_, class InputMatrix_ &gt; </td></tr>
<tr class="memitem:a5847f3cd78ce89170ca43262d7f5f8e3"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a5847f3cd78ce89170ca43262d7f5f8e3">convert_to_sparse</a> (const InputMatrix_ *incoming, int order, int threads=1)</td></tr>
<tr class="separator:a5847f3cd78ce89170ca43262d7f5f8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01c93a616eb99f6a17861a8b19f7ee0"><td class="memTemplParams" colspan="2">template&lt;typename Index_ , class Function_ &gt; </td></tr>
<tr class="memitem:af01c93a616eb99f6a17861a8b19f7ee0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#af01c93a616eb99f6a17861a8b19f7ee0">process_consecutive_indices</a> (const Index_ *indices, Index_ length, Function_ fun)</td></tr>
<tr class="separator:af01c93a616eb99f6a17861a8b19f7ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7518f5e8e09a6f6d7d3955b8ea286689"><td class="memTemplParams" colspan="2">template&lt;typename T , typename IDX &gt; </td></tr>
<tr class="memitem:a7518f5e8e09a6f6d7d3955b8ea286689"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a7518f5e8e09a6f6d7d3955b8ea286689">wrap_shared_ptr</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; *ptr)</td></tr>
<tr class="separator:a7518f5e8e09a6f6d7d3955b8ea286689"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Flexible representations for matrix data. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ac47a769e00660eb7e9b5fcd543bcf2d3" name="ac47a769e00660eb7e9b5fcd543bcf2d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac47a769e00660eb7e9b5fcd543bcf2d3">&#9670;&#160;</a></span>DenseColumnMatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_  = int, class Storage_  = std::vector&lt;Value_&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetatami.html#ac47a769e00660eb7e9b5fcd543bcf2d3">tatami::DenseColumnMatrix</a> = typedef <a class="el" href="classtatami_1_1DenseMatrix.html">DenseMatrix</a>&lt;false, Value_, Index_, Storage_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Column-major matrix. See <code><a class="el" href="classtatami_1_1DenseMatrix.html" title="Dense matrix representation.">tatami::DenseMatrix</a></code> for details on the template parameters. </p>

</div>
</div>
<a id="a51122d20490b377cd3f4609cc044f314" name="a51122d20490b377cd3f4609cc044f314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51122d20490b377cd3f4609cc044f314">&#9670;&#160;</a></span>DenseRowMatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_  = int, class Storage_  = std::vector&lt;Value_&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetatami.html#a51122d20490b377cd3f4609cc044f314">tatami::DenseRowMatrix</a> = typedef <a class="el" href="classtatami_1_1DenseMatrix.html">DenseMatrix</a>&lt;true, Value_, Index_, Storage_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Row-major matrix. See <code><a class="el" href="classtatami_1_1DenseMatrix.html" title="Dense matrix representation.">tatami::DenseMatrix</a></code> for details on the template parameters. </p>

</div>
</div>
<a id="a85ed61a4f772a2f7be4a12f739554e6e" name="a85ed61a4f772a2f7be4a12f739554e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ed61a4f772a2f7be4a12f739554e6e">&#9670;&#160;</a></span>ConditionalSelectionExtractor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#a0a2ecaf58e2b69bb4a808e814aeb16a1">DimensionSelectionType</a> selection_, typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetatami.html#a85ed61a4f772a2f7be4a12f739554e6e">tatami::ConditionalSelectionExtractor</a> = typedef typename std::conditional&lt; selection_ == DimensionSelectionType::FULL, <a class="el" href="structtatami_1_1FullExtractor.html">FullExtractor</a>&lt;Index_&gt;, typename std::conditional&lt; selection_ == DimensionSelectionType::BLOCK, <a class="el" href="structtatami_1_1BlockExtractor.html">BlockExtractor</a>&lt;Index_&gt;, <a class="el" href="structtatami_1_1IndexExtractor.html">IndexExtractor</a>&lt;Index_&gt; &gt;::type &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">selection_</td><td>Type of selection along the extraction dimension. </td></tr>
    <tr><td class="paramname">Index_</td><td>Row/column index type, should be integer.</td></tr>
  </table>
  </dd>
</dl>
<p>Conditional extractor interface that depends on the selection type. </p>

</div>
</div>
<a id="ae9f8db5316521603085577d977a6955f" name="ae9f8db5316521603085577d977a6955f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9f8db5316521603085577d977a6955f">&#9670;&#160;</a></span>Extractor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#a0a2ecaf58e2b69bb4a808e814aeb16a1">DimensionSelectionType</a> selection_, bool sparse_, typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetatami.html#ae9f8db5316521603085577d977a6955f">tatami::Extractor</a> = typedef typename std::conditional&lt;sparse_, <a class="el" href="classtatami_1_1SparseExtractor.html">SparseExtractor</a>&lt;selection_, Value_, Index_&gt;, <a class="el" href="classtatami_1_1DenseExtractor.html">DenseExtractor</a>&lt;selection_, Value_, Index_&gt; &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">selection_</td><td>Type of selection on the extraction dimension. </td></tr>
    <tr><td class="paramname">sparse_</td><td>Whether to perform sparse retrieval. </td></tr>
    <tr><td class="paramname">Value_</td><td>Data value type, should be numeric. </td></tr>
    <tr><td class="paramname">Index_</td><td>Row/column index type, should be integer.</td></tr>
  </table>
  </dd>
</dl>
<p>Conditional extractor interface that depends on the format type. </p>

</div>
</div>
<a id="a6008dbced6de41e5619156b5335f5762" name="a6008dbced6de41e5619156b5335f5762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6008dbced6de41e5619156b5335f5762">&#9670;&#160;</a></span>FullDenseExtractor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetatami.html#a6008dbced6de41e5619156b5335f5762">tatami::FullDenseExtractor</a> = typedef <a class="el" href="namespacetatami.html#ae9f8db5316521603085577d977a6955f">Extractor</a>&lt;DimensionSelectionType::FULL, false, Value_, Index_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extractor for dense extraction of full rows. </p>

</div>
</div>
<a id="ae75de1fc78b7d361ea8b59a5379ea4da" name="ae75de1fc78b7d361ea8b59a5379ea4da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae75de1fc78b7d361ea8b59a5379ea4da">&#9670;&#160;</a></span>BlockDenseExtractor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetatami.html#ae75de1fc78b7d361ea8b59a5379ea4da">tatami::BlockDenseExtractor</a> = typedef <a class="el" href="namespacetatami.html#ae9f8db5316521603085577d977a6955f">Extractor</a>&lt;DimensionSelectionType::BLOCK, false, Value_, Index_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extractor for dense extraction of a block of each row. </p>

</div>
</div>
<a id="a47ce406c32c3914c2ecce187e21b6ced" name="a47ce406c32c3914c2ecce187e21b6ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ce406c32c3914c2ecce187e21b6ced">&#9670;&#160;</a></span>IndexDenseExtractor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetatami.html#a47ce406c32c3914c2ecce187e21b6ced">tatami::IndexDenseExtractor</a> = typedef <a class="el" href="namespacetatami.html#ae9f8db5316521603085577d977a6955f">Extractor</a>&lt;DimensionSelectionType::INDEX, false, Value_, Index_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extractor for dense extraction of an indexed subset of each row. </p>

</div>
</div>
<a id="a0fbb0624c8e1913a87e8fb5c975400e1" name="a0fbb0624c8e1913a87e8fb5c975400e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fbb0624c8e1913a87e8fb5c975400e1">&#9670;&#160;</a></span>FullSparseExtractor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetatami.html#a0fbb0624c8e1913a87e8fb5c975400e1">tatami::FullSparseExtractor</a> = typedef <a class="el" href="namespacetatami.html#ae9f8db5316521603085577d977a6955f">Extractor</a>&lt;DimensionSelectionType::FULL, true, Value_, Index_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extractor for sparse extraction of full rows. </p>

</div>
</div>
<a id="ac8d0024399a66ce61f6315f5f46ebb63" name="ac8d0024399a66ce61f6315f5f46ebb63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8d0024399a66ce61f6315f5f46ebb63">&#9670;&#160;</a></span>BlockSparseExtractor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetatami.html#ac8d0024399a66ce61f6315f5f46ebb63">tatami::BlockSparseExtractor</a> = typedef <a class="el" href="namespacetatami.html#ae9f8db5316521603085577d977a6955f">Extractor</a>&lt;DimensionSelectionType::BLOCK, true, Value_, Index_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extractor for sparse extraction of a block of each column. </p>

</div>
</div>
<a id="a4b67b4d1b6c00cd0bd449703432a5f7b" name="a4b67b4d1b6c00cd0bd449703432a5f7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b67b4d1b6c00cd0bd449703432a5f7b">&#9670;&#160;</a></span>IndexSparseExtractor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetatami.html#a4b67b4d1b6c00cd0bd449703432a5f7b">tatami::IndexSparseExtractor</a> = typedef <a class="el" href="namespacetatami.html#ae9f8db5316521603085577d977a6955f">Extractor</a>&lt;DimensionSelectionType::INDEX, true, Value_, Index_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extractor for sparse extraction of an indexed subset of each column. </p>

</div>
</div>
<a id="a35c670894994f1d620abb55953f98441" name="a35c670894994f1d620abb55953f98441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35c670894994f1d620abb55953f98441">&#9670;&#160;</a></span>NumericMatrix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetatami.html#a35c670894994f1d620abb55953f98441">tatami::NumericMatrix</a> = typedef <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt;double, int&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenient shorthand for the most common use case of double-precision matrices. </p>

</div>
</div>
<a id="a18cee3a5d9734f0092b03d023cfe4b6a" name="a18cee3a5d9734f0092b03d023cfe4b6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18cee3a5d9734f0092b03d023cfe4b6a">&#9670;&#160;</a></span>CompressedSparseColumnMatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ , class ValueStorage_  = std::vector&lt;Value_&gt;, class IndexStorage_  = std::vector&lt;Index_&gt;, class PointerStorage_  = std::vector&lt;size_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetatami.html#a18cee3a5d9734f0092b03d023cfe4b6a">tatami::CompressedSparseColumnMatrix</a> = typedef <a class="el" href="classtatami_1_1CompressedSparseMatrix.html">CompressedSparseMatrix</a>&lt;false, Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compressed sparse column matrix. See <code><a class="el" href="classtatami_1_1CompressedSparseMatrix.html" title="Compressed sparse matrix representation.">tatami::CompressedSparseMatrix</a></code> for details on the template parameters. </p>

</div>
</div>
<a id="a0111adeeb583aeb7e24e9e1e25be4aa0" name="a0111adeeb583aeb7e24e9e1e25be4aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0111adeeb583aeb7e24e9e1e25be4aa0">&#9670;&#160;</a></span>CompressedSparseRowMatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ , class ValueStorage_  = std::vector&lt;Value_&gt;, class IndexStorage_  = std::vector&lt;Index_&gt;, class PointerStorage_  = std::vector&lt;size_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetatami.html#a0111adeeb583aeb7e24e9e1e25be4aa0">tatami::CompressedSparseRowMatrix</a> = typedef <a class="el" href="classtatami_1_1CompressedSparseMatrix.html">CompressedSparseMatrix</a>&lt;true, Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compressed sparse row matrix. See <code><a class="el" href="classtatami_1_1CompressedSparseMatrix.html" title="Compressed sparse matrix representation.">tatami::CompressedSparseMatrix</a></code> for details on the template parameters. </p>

</div>
</div>
<a id="a6b9735bdc6e0a2856cd4747efbbf9f3c" name="a6b9735bdc6e0a2856cd4747efbbf9f3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b9735bdc6e0a2856cd4747efbbf9f3c">&#9670;&#160;</a></span>FragmentedSparseColumnMatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ , class ValueVectorStorage_  = std::vector&lt;std::vector&lt;Value_&gt; &gt;, class IndexVectorStorage_  = std::vector&lt;std::vector&lt;Index_&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetatami.html#a6b9735bdc6e0a2856cd4747efbbf9f3c">tatami::FragmentedSparseColumnMatrix</a> = typedef <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html">FragmentedSparseMatrix</a>&lt;false, Value_, Index_, ValueVectorStorage_, IndexVectorStorage_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fragmented sparse column matrix. See <code><a class="el" href="classtatami_1_1FragmentedSparseMatrix.html" title="Fragmented sparse matrix representation.">tatami::FragmentedSparseMatrix</a></code> for details on the template parameters. </p>

</div>
</div>
<a id="a3d97fc9bd75052a79bb643d0fb5a0b98" name="a3d97fc9bd75052a79bb643d0fb5a0b98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d97fc9bd75052a79bb643d0fb5a0b98">&#9670;&#160;</a></span>FragmentedSparseRowMatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ , class ValueVectorStorage_  = std::vector&lt;std::vector&lt;Value_&gt; &gt;, class IndexVectorStorage_  = std::vector&lt;std::vector&lt;Index_&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetatami.html#a3d97fc9bd75052a79bb643d0fb5a0b98">tatami::FragmentedSparseRowMatrix</a> = typedef <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html">FragmentedSparseMatrix</a>&lt;true, Value_, Index_, ValueVectorStorage_, IndexVectorStorage_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fragmented sparse row matrix. See <code><a class="el" href="classtatami_1_1FragmentedSparseMatrix.html" title="Fragmented sparse matrix representation.">tatami::FragmentedSparseMatrix</a></code> for details on the template parameters. </p>

</div>
</div>
<a id="a6f03d0d880bc056e09c2cbb80eb2c2ec" name="a6f03d0d880bc056e09c2cbb80eb2c2ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f03d0d880bc056e09c2cbb80eb2c2ec">&#9670;&#160;</a></span>SemiCompressedSparseColumnMatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ , class IndexStorage_  = std::vector&lt;Index_&gt;, class PointerStorage_  = std::vector&lt;size_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetatami.html#a6f03d0d880bc056e09c2cbb80eb2c2ec">tatami::SemiCompressedSparseColumnMatrix</a> = typedef <a class="el" href="classtatami_1_1SemiCompressedSparseMatrix.html">SemiCompressedSparseMatrix</a>&lt;false, Value_, Index_, IndexStorage_, PointerStorage_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Semi-compressed sparse column matrix. See <code><a class="el" href="classtatami_1_1SemiCompressedSparseMatrix.html" title="Semi-compressed sparse matrix representation.">tatami::SemiCompressedSparseMatrix</a></code> for details on the template parameters. </p>

</div>
</div>
<a id="a412cb6ee12f3ee81d404d6eb0e494e4d" name="a412cb6ee12f3ee81d404d6eb0e494e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a412cb6ee12f3ee81d404d6eb0e494e4d">&#9670;&#160;</a></span>SemiCompressedSparseRowMatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ , class IndexStorage_  = std::vector&lt;Index_&gt;, class PointerStorage_  = std::vector&lt;size_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetatami.html#a412cb6ee12f3ee81d404d6eb0e494e4d">tatami::SemiCompressedSparseRowMatrix</a> = typedef <a class="el" href="classtatami_1_1SemiCompressedSparseMatrix.html">SemiCompressedSparseMatrix</a>&lt;true, Value_, Index_, IndexStorage_, PointerStorage_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Semi-compressed sparse row matrix. See <code><a class="el" href="classtatami_1_1SemiCompressedSparseMatrix.html" title="Semi-compressed sparse matrix representation.">tatami::SemiCompressedSparseMatrix</a></code> for details on the template parameters. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a0a2ecaf58e2b69bb4a808e814aeb16a1" name="a0a2ecaf58e2b69bb4a808e814aeb16a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a2ecaf58e2b69bb4a808e814aeb16a1">&#9670;&#160;</a></span>DimensionSelectionType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacetatami.html#a0a2ecaf58e2b69bb4a808e814aeb16a1">tatami::DimensionSelectionType</a> : char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Type of selection along a dimension, typically the extraction dimension:</p>
<ul>
<li><code>FULL</code>: selects the full extent of the dimension, i.e., all elements in the dimension.</li>
<li><code>BLOCK</code>: selects a contiguous block of elements in the dimension.</li>
<li><code>INDEX</code>: selects a sorted and unique array of indices of dimension elements. </li>
</ul>

</div>
</div>
<a id="aab44a37b3762de0c5b1ffbfceb25fa0f" name="aab44a37b3762de0c5b1ffbfceb25fa0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab44a37b3762de0c5b1ffbfceb25fa0f">&#9670;&#160;</a></span>DelayedArithOp</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacetatami.html#aab44a37b3762de0c5b1ffbfceb25fa0f">tatami::DelayedArithOp</a> : char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Type of the delayed arithmetic operation. </p>

</div>
</div>
<a id="a2104862d4068933ea4cc805c92f82d07" name="a2104862d4068933ea4cc805c92f82d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2104862d4068933ea4cc805c92f82d07">&#9670;&#160;</a></span>DelayedBooleanOp</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacetatami.html#a2104862d4068933ea4cc805c92f82d07">tatami::DelayedBooleanOp</a> : char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Type of the delayed boolean operation. </p>

</div>
</div>
<a id="ac4fc175a57ace709941b5ca7ddb19708" name="ac4fc175a57ace709941b5ca7ddb19708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4fc175a57ace709941b5ca7ddb19708">&#9670;&#160;</a></span>DelayedCompareOp</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacetatami.html#ac4fc175a57ace709941b5ca7ddb19708">tatami::DelayedCompareOp</a> : char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Type of the delayed comparison operation. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="af9d13ceaa112d2c091265510d741488d" name="af9d13ceaa112d2c091265510d741488d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9d13ceaa112d2c091265510d741488d">&#9670;&#160;</a></span>extracted_length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#a0a2ecaf58e2b69bb4a808e814aeb16a1">DimensionSelectionType</a> selection_, typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Index_ tatami::extracted_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetatami.html#a85ed61a4f772a2f7be4a12f739554e6e">ConditionalSelectionExtractor</a>&lt; selection_, Index_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>ex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">selection_</td><td>Type of selection along the extraction dimension. </td></tr>
    <tr><td class="paramname">Index_</td><td>Row/column index type, should be integer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>A <code>ConditionalSelectionExtractor</code> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements extracted from the extraction dimension, conditional on the selection type in <code>selection_</code>. </dd></dl>

</div>
</div>
<a id="a5f8e0f69139575707aa9314174b415b3" name="a5f8e0f69139575707aa9314174b415b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f8e0f69139575707aa9314174b415b3">&#9670;&#160;</a></span>make_DelayedBind()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int margin_, typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; tatami::make_DelayedBind </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; &gt;&#160;</td>
          <td class="paramname"><em>ps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <code>make_*</code> helper function to enable partial template deduction of supplied types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">margin_</td><td>Dimension along which the combining is to occur. If 0, matrices are combined along the rows; if 1, matrices are combined to the columns. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of index value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ps</td><td>Pointers to <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <code><a class="el" href="classtatami_1_1DelayedBind.html" title="Delayed combining of a matrix.">DelayedBind</a></code> instance.</dd></dl>
<p>A <code>make_*</code> helper function to enable partial template deduction of supplied types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">margin_</td><td>Dimension along which the combining is to occur. If 0, matrices are combined along the rows; if 1, matrices are combined to the columns. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of index value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ps</td><td>Pointers to <code>const</code> <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <code><a class="el" href="classtatami_1_1DelayedBind.html" title="Delayed combining of a matrix.">DelayedBind</a></code> instance. </dd></dl>

</div>
</div>
<a id="aca62c3bf751cdd06a08e8e503b0b591a" name="aca62c3bf751cdd06a08e8e503b0b591a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca62c3bf751cdd06a08e8e503b0b591a">&#9670;&#160;</a></span>make_DelayedCast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_out_ , typename Index_out_ , typename Value_in_ , typename Index_in_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_out_, Index_out_ &gt; &gt; tatami::make_DelayedCast </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_in_, Index_in_ &gt; &gt;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recast a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> to a different interface type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_out_</td><td>Data type to cast to. </td></tr>
    <tr><td class="paramname">Index_out_</td><td>Index type to cast to. </td></tr>
    <tr><td class="paramname">Value_in_</td><td>Data type to cast from. </td></tr>
    <tr><td class="paramname">Index_in_</td><td>Index type to cast from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to the (possbly <code>const</code>) <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> instance to cast from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> instance of the desired interface type. </dd></dl>

</div>
</div>
<a id="afa35d8e9fe286967f327ec0eb6bd5005" name="afa35d8e9fe286967f327ec0eb6bd5005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa35d8e9fe286967f327ec0eb6bd5005">&#9670;&#160;</a></span>make_DelayedTranspose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; tatami::make_DelayedTranspose </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <code>make_*</code> helper function to enable partial template deduction of supplied types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of index value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to a (possibly <code>const</code>) <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <code><a class="el" href="classtatami_1_1DelayedTranspose.html" title="Delayed transposition of a matrix.">DelayedTranspose</a></code> instance. </dd></dl>

</div>
</div>
<a id="a8f4aafc0a1fbdc0c31bc122d24122a63" name="a8f4aafc0a1fbdc0c31bc122d24122a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f4aafc0a1fbdc0c31bc122d24122a63">&#9670;&#160;</a></span>make_DelayedSubsetBlock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int margin_, typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; tatami::make_DelayedSubsetBlock </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <code>make_*</code> helper function to enable partial template deduction of supplied types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">margin_</td><td>Dimension along which the addition is to occur. If 0, the subset is applied to the rows; if 1, the subset is applied to the columns. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to the underlying (pre-subset) <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code>. </td></tr>
    <tr><td class="paramname">f</td><td>Index of the start of the block. This should be a row index if <code>margin_ = 0</code> and a column index otherwise. </td></tr>
    <tr><td class="paramname">l</td><td>Index of the one-past-the-end of the block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <code><a class="el" href="classtatami_1_1DelayedSubsetBlock.html" title="Delayed subsetting to a contiguous block.">DelayedSubsetBlock</a></code> instance. </dd></dl>

</div>
</div>
<a id="abfc63177b00e6e3e2fa47754b8d87704" name="abfc63177b00e6e3e2fa47754b8d87704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc63177b00e6e3e2fa47754b8d87704">&#9670;&#160;</a></span>make_DelayedSubset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int margin_, typename Value_ , typename Index_ , class IndexStorage_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; tatami::make_DelayedSubset </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexStorage_&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <code>make_*</code> helper function to enable partial template deduction of supplied types. This will automatically dispatch to <code><a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html" title="Delayed subsetting of a matrix with sorted, unique indices.">DelayedSubsetSortedUnique</a></code>, <code><a class="el" href="classtatami_1_1DelayedSubsetUnique.html" title="Delayed subsetting of a matrix with unique indices.">DelayedSubsetUnique</a></code>, <code><a class="el" href="classtatami_1_1DelayedSubsetSorted.html" title="Delayed subsetting of a matrix with sorted indices.">DelayedSubsetSorted</a></code> or <code><a class="el" href="classtatami_1_1DelayedSubset.html" title="Delayed subsetting of a matrix with general indices.">DelayedSubset</a></code>, depending on the values in <code>idx</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">margin_</td><td>Dimension along which the subsetting is to occur. If 0, the subset is applied to the rows; if 1, the subset is applied to the columns. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type of the row/column indices. </td></tr>
    <tr><td class="paramname">IndexStorage_</td><td>Vector containing the subset indices, to be automatically deduced.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to a (possibly <code>const</code>) <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code>. </td></tr>
    <tr><td class="paramname">idx</td><td>Instance of the index vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <code><a class="el" href="classtatami_1_1DelayedSubset.html" title="Delayed subsetting of a matrix with general indices.">DelayedSubset</a></code> instance. </dd></dl>

</div>
</div>
<a id="a95b6638dceda82d82a7579dc88a45709" name="a95b6638dceda82d82a7579dc88a45709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95b6638dceda82d82a7579dc88a45709">&#9670;&#160;</a></span>new_extractor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool row_, bool sparse_, typename Value_ , typename Index_ , typename ... Args_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto tatami::new_extractor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args_ &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">row_</td><td>Whether to iterate over rows. </td></tr>
    <tr><td class="paramname">sparse_</td><td>Whether to perform sparse retrieval. </td></tr>
    <tr><td class="paramname">Value_</td><td>Data value type, should be numeric. </td></tr>
    <tr><td class="paramname">Index_</td><td>Row/column index type, should be integer. </td></tr>
    <tr><td class="paramname">Args_</td><td>Further arguments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> object to iterate over. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">args</td><td>Zero or more additional arguments to pass to methods like <code><a class="el" href="classtatami_1_1Matrix.html#aa29b9428f53453369256d7febc9ed0fc">Matrix::dense_row()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>Extractor</code> object to access the requested dimension of <code>ptr</code>. </dd></dl>

</div>
</div>
<a id="a1d138b1e7f6a26f814c025363cc3db80" name="a1d138b1e7f6a26f814c025363cc3db80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d138b1e7f6a26f814c025363cc3db80">&#9670;&#160;</a></span>make_DelayedBinaryAddHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBinaryArithHelper.html">DelayedBinaryArithHelper</a>&lt; DelayedArithOp::ADD &gt; tatami::make_DelayedBinaryAddHelper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed binary addition. </dd></dl>

</div>
</div>
<a id="ac4c951d489cb0f2bb0e90f2cf4a25862" name="ac4c951d489cb0f2bb0e90f2cf4a25862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4c951d489cb0f2bb0e90f2cf4a25862">&#9670;&#160;</a></span>make_DelayedBinarySubtractHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBinaryArithHelper.html">DelayedBinaryArithHelper</a>&lt; DelayedArithOp::SUBTRACT &gt; tatami::make_DelayedBinarySubtractHelper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed binary subtraction. </dd></dl>

</div>
</div>
<a id="a2569c540083a24f92af8140358e1e9c4" name="a2569c540083a24f92af8140358e1e9c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2569c540083a24f92af8140358e1e9c4">&#9670;&#160;</a></span>make_DelayedBinaryMultiplyHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBinaryArithHelper.html">DelayedBinaryArithHelper</a>&lt; DelayedArithOp::MULTIPLY &gt; tatami::make_DelayedBinaryMultiplyHelper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed binary multiplication. </dd></dl>

</div>
</div>
<a id="aeb4cf766f850766b966f7121728a6af8" name="aeb4cf766f850766b966f7121728a6af8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb4cf766f850766b966f7121728a6af8">&#9670;&#160;</a></span>make_DelayedBinaryDivideHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBinaryArithHelper.html">DelayedBinaryArithHelper</a>&lt; DelayedArithOp::DIVIDE &gt; tatami::make_DelayedBinaryDivideHelper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed binary division. </dd></dl>

</div>
</div>
<a id="a1063aea86897ef76e17b1772320b8f7d" name="a1063aea86897ef76e17b1772320b8f7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1063aea86897ef76e17b1772320b8f7d">&#9670;&#160;</a></span>make_DelayedBinaryBooleanEqualHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBinaryBooleanHelper.html">DelayedBinaryBooleanHelper</a>&lt; DelayedBooleanOp::EQUAL &gt; tatami::make_DelayedBinaryBooleanEqualHelper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed binary boolean equivalence operation. </dd></dl>

</div>
</div>
<a id="a31625dbb50d420fe1b0da406f19ef33d" name="a31625dbb50d420fe1b0da406f19ef33d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31625dbb50d420fe1b0da406f19ef33d">&#9670;&#160;</a></span>make_DelayedBinaryBooleanAndHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBinaryBooleanHelper.html">DelayedBinaryBooleanHelper</a>&lt; DelayedBooleanOp::AND &gt; tatami::make_DelayedBinaryBooleanAndHelper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed binary AND comparison. </dd></dl>

</div>
</div>
<a id="a65bad100b39d9372fbeb23d16dae6588" name="a65bad100b39d9372fbeb23d16dae6588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65bad100b39d9372fbeb23d16dae6588">&#9670;&#160;</a></span>make_DelayedBinaryBooleanOrHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBinaryBooleanHelper.html">DelayedBinaryBooleanHelper</a>&lt; DelayedBooleanOp::OR &gt; tatami::make_DelayedBinaryBooleanOrHelper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed binary OR comparison. </dd></dl>

</div>
</div>
<a id="aeb091953ab0f55406935a52b7ecb7350" name="aeb091953ab0f55406935a52b7ecb7350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb091953ab0f55406935a52b7ecb7350">&#9670;&#160;</a></span>make_DelayedBinaryBooleanXorHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBinaryBooleanHelper.html">DelayedBinaryBooleanHelper</a>&lt; DelayedBooleanOp::XOR &gt; tatami::make_DelayedBinaryBooleanXorHelper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed binary XOR comparison. </dd></dl>

</div>
</div>
<a id="ac3599db8f6d19fc9172da45a3b6244fc" name="ac3599db8f6d19fc9172da45a3b6244fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3599db8f6d19fc9172da45a3b6244fc">&#9670;&#160;</a></span>make_DelayedBinaryEqualHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBinaryCompareHelper.html">DelayedBinaryCompareHelper</a>&lt; DelayedCompareOp::EQUAL &gt; tatami::make_DelayedBinaryEqualHelper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed binary equality comparison. </dd></dl>

</div>
</div>
<a id="abe4fb79c5a2cddab2f5c9cf0bd9fe3d0" name="abe4fb79c5a2cddab2f5c9cf0bd9fe3d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe4fb79c5a2cddab2f5c9cf0bd9fe3d0">&#9670;&#160;</a></span>make_DelayedBinaryGreaterThanHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBinaryCompareHelper.html">DelayedBinaryCompareHelper</a>&lt; DelayedCompareOp::GREATER_THAN &gt; tatami::make_DelayedBinaryGreaterThanHelper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed binary greater-than comparison. </dd></dl>

</div>
</div>
<a id="ae6a24f5bf2c2c61382aef43f2c8d3362" name="ae6a24f5bf2c2c61382aef43f2c8d3362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a24f5bf2c2c61382aef43f2c8d3362">&#9670;&#160;</a></span>make_DelayedBinaryLessThanHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBinaryCompareHelper.html">DelayedBinaryCompareHelper</a>&lt; DelayedCompareOp::LESS_THAN &gt; tatami::make_DelayedBinaryLessThanHelper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed binary less-than comparison. </dd></dl>

</div>
</div>
<a id="ad31cd299427d73538dc00dcbffa9cd2b" name="ad31cd299427d73538dc00dcbffa9cd2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad31cd299427d73538dc00dcbffa9cd2b">&#9670;&#160;</a></span>make_DelayedBinaryGreaterThanOrEqualHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBinaryCompareHelper.html">DelayedBinaryCompareHelper</a>&lt; DelayedCompareOp::GREATER_THAN_OR_EQUAL &gt; tatami::make_DelayedBinaryGreaterThanOrEqualHelper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed binary greater-than-or-equal comparison. </dd></dl>

</div>
</div>
<a id="a38c7cc26409e5c995b7264164b148f4c" name="a38c7cc26409e5c995b7264164b148f4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38c7cc26409e5c995b7264164b148f4c">&#9670;&#160;</a></span>make_DelayedBinaryLessThanOrEqualHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBinaryCompareHelper.html">DelayedBinaryCompareHelper</a>&lt; DelayedCompareOp::LESS_THAN_OR_EQUAL &gt; tatami::make_DelayedBinaryLessThanOrEqualHelper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed binary less-than-or-equal comparison. </dd></dl>

</div>
</div>
<a id="a3073c4e33dcf89416af292399ba55c29" name="a3073c4e33dcf89416af292399ba55c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3073c4e33dcf89416af292399ba55c29">&#9670;&#160;</a></span>make_DelayedBinaryNotEqualHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBinaryCompareHelper.html">DelayedBinaryCompareHelper</a>&lt; DelayedCompareOp::NOT_EQUAL &gt; tatami::make_DelayedBinaryNotEqualHelper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed binary non-equality comparison to a scalar. </dd></dl>

</div>
</div>
<a id="af39c0767d23c6bdc5f4267f062ef2e17" name="af39c0767d23c6bdc5f4267f062ef2e17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af39c0767d23c6bdc5f4267f062ef2e17">&#9670;&#160;</a></span>make_DelayedBinaryIsometricOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ , class Operation_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; tatami::make_DelayedBinaryIsometricOp </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Operation_&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <code>make_*</code> helper function to enable partial template deduction of supplied types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of index value. </td></tr>
    <tr><td class="paramname">Operation_</td><td>Helper class defining the operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>Pointer to a (possibly <code>const</code>) <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code>. </td></tr>
    <tr><td class="paramname">right</td><td>Pointer to a (possibly <code>const</code>) <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code>. </td></tr>
    <tr><td class="paramname">op</td><td>Instance of the operation helper class.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Instance of a <code><a class="el" href="classtatami_1_1DelayedBinaryIsometricOp.html" title="Delayed isometric operations on two matrices.">DelayedBinaryIsometricOp</a></code> clas. </dd></dl>

</div>
</div>
<a id="ac0d637bdfb7f4126ded39f6e06b04d3a" name="ac0d637bdfb7f4126ded39f6e06b04d3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0d637bdfb7f4126ded39f6e06b04d3a">&#9670;&#160;</a></span>make_DelayedAddScalarHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedArithScalarHelper.html">DelayedArithScalarHelper</a>&lt; DelayedArithOp::ADD, true, Scalar_ &gt; tatami::make_DelayedAddScalarHelper </td>
          <td>(</td>
          <td class="paramtype">Scalar_&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Scalar value to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed scalar addition. </dd></dl>

</div>
</div>
<a id="a54f42d3fa38192c46b1fbd89ffbc96ef" name="a54f42d3fa38192c46b1fbd89ffbc96ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54f42d3fa38192c46b1fbd89ffbc96ef">&#9670;&#160;</a></span>make_DelayedSubtractScalarHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool right_, typename Scalar_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedArithScalarHelper.html">DelayedArithScalarHelper</a>&lt; DelayedArithOp::SUBTRACT, right_, Scalar_ &gt; tatami::make_DelayedSubtractScalarHelper </td>
          <td>(</td>
          <td class="paramtype">Scalar_&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">right_</td><td>Whether the scalar should be on the right hand side of the subtraction. </td></tr>
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Scalar value to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed scalar subtraction. </dd></dl>

</div>
</div>
<a id="ab2ae6b934c10ef1ba28be1bc0f3316db" name="ab2ae6b934c10ef1ba28be1bc0f3316db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2ae6b934c10ef1ba28be1bc0f3316db">&#9670;&#160;</a></span>make_DelayedMultiplyScalarHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedArithScalarHelper.html">DelayedArithScalarHelper</a>&lt; DelayedArithOp::MULTIPLY, true, Scalar_ &gt; tatami::make_DelayedMultiplyScalarHelper </td>
          <td>(</td>
          <td class="paramtype">Scalar_&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Scalar value to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed scalar multiplication. </dd></dl>

</div>
</div>
<a id="a37bafee11663e77fd079b7df8c542b41" name="a37bafee11663e77fd079b7df8c542b41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37bafee11663e77fd079b7df8c542b41">&#9670;&#160;</a></span>make_DelayedDivideScalarHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool right_, typename Scalar_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedArithScalarHelper.html">DelayedArithScalarHelper</a>&lt; DelayedArithOp::DIVIDE, right_, Scalar_ &gt; tatami::make_DelayedDivideScalarHelper </td>
          <td>(</td>
          <td class="paramtype">Scalar_&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">right_</td><td>Whether the scalar should be on the right hand side of the division. </td></tr>
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Scalar value to be divided. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed scalar division. </dd></dl>

</div>
</div>
<a id="a18d82c78f9847f7f3d7b1924736dc08a" name="a18d82c78f9847f7f3d7b1924736dc08a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18d82c78f9847f7f3d7b1924736dc08a">&#9670;&#160;</a></span>make_DelayedAddVectorHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int margin_, typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedArithVectorHelper.html">DelayedArithVectorHelper</a>&lt; DelayedArithOp::ADD, true, margin_, Vector_ &gt; tatami::make_DelayedAddVectorHelper </td>
          <td>(</td>
          <td class="paramtype">Vector_&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">margin_</td><td><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a> dimension along which the addition is to occur, see <code><a class="el" href="structtatami_1_1DelayedArithVectorHelper.html" title="Delayed vector arithmetic.">DelayedArithVectorHelper</a></code>. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector to be added to the rows/columns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed vector addition. </dd></dl>

</div>
</div>
<a id="ae10ad8ba2f67e03997a70bcf344cd0b5" name="ae10ad8ba2f67e03997a70bcf344cd0b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae10ad8ba2f67e03997a70bcf344cd0b5">&#9670;&#160;</a></span>make_DelayedSubtractVectorHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool right_, int margin_, typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedArithVectorHelper.html">DelayedArithVectorHelper</a>&lt; DelayedArithOp::SUBTRACT, right_, margin_, Vector_ &gt; tatami::make_DelayedSubtractVectorHelper </td>
          <td>(</td>
          <td class="paramtype">Vector_&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">right_</td><td>Whether the scalar should be on the right hand side of the subtraction. </td></tr>
    <tr><td class="paramname">margin_</td><td><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a> dimension along which the subtraction is to occur, see <code><a class="el" href="structtatami_1_1DelayedArithVectorHelper.html" title="Delayed vector arithmetic.">DelayedArithVectorHelper</a></code>. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector to subtract from (or be subtracted by) the rows/columns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed vector subtraction. </dd></dl>

</div>
</div>
<a id="ab5028a7b69c08ecec87064d7b3d83b41" name="ab5028a7b69c08ecec87064d7b3d83b41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5028a7b69c08ecec87064d7b3d83b41">&#9670;&#160;</a></span>make_DelayedMultiplyVectorHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int margin_, typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedArithVectorHelper.html">DelayedArithVectorHelper</a>&lt; DelayedArithOp::MULTIPLY, true, margin_, Vector_ &gt; tatami::make_DelayedMultiplyVectorHelper </td>
          <td>(</td>
          <td class="paramtype">Vector_&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">margin_</td><td><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a> dimension along which the multiplication is to occur, see <code><a class="el" href="structtatami_1_1DelayedArithVectorHelper.html" title="Delayed vector arithmetic.">DelayedArithVectorHelper</a></code>. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector to multiply the rows/columns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed vector multiplication. </dd></dl>

</div>
</div>
<a id="a214dedde7eb472684ce66ec4ba26e77c" name="a214dedde7eb472684ce66ec4ba26e77c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a214dedde7eb472684ce66ec4ba26e77c">&#9670;&#160;</a></span>make_DelayedDivideVectorHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool right_, int margin_, typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedArithVectorHelper.html">DelayedArithVectorHelper</a>&lt; DelayedArithOp::DIVIDE, right_, margin_, Vector_ &gt; tatami::make_DelayedDivideVectorHelper </td>
          <td>(</td>
          <td class="paramtype">Vector_&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">right_</td><td>Whether the scalar should be on the right hand side of the division. </td></tr>
    <tr><td class="paramname">margin_</td><td><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a> dimension along which the division is to occur, see <code><a class="el" href="structtatami_1_1DelayedArithVectorHelper.html" title="Delayed vector arithmetic.">DelayedArithVectorHelper</a></code>. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector to divide (or be divided by) the rows/columns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed vector division. </dd></dl>

</div>
</div>
<a id="ac1eab4687167d073231e35c032f61275" name="ac1eab4687167d073231e35c032f61275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1eab4687167d073231e35c032f61275">&#9670;&#160;</a></span>make_DelayedBooleanNotHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBooleanNotHelper.html">DelayedBooleanNotHelper</a> tatami::make_DelayedBooleanNotHelper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed NOT operation. </dd></dl>

</div>
</div>
<a id="a3f2492704a466130db315a980f3cdd47" name="a3f2492704a466130db315a980f3cdd47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f2492704a466130db315a980f3cdd47">&#9670;&#160;</a></span>make_DelayedBooleanAndScalarHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBooleanScalarHelper.html">DelayedBooleanScalarHelper</a>&lt; DelayedBooleanOp::AND &gt; tatami::make_DelayedBooleanAndScalarHelper </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Scalar value to use in the operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed AND operation with a scalar. </dd></dl>

</div>
</div>
<a id="a90c9fc77d5cdbf54dfac07da1e3bfd38" name="a90c9fc77d5cdbf54dfac07da1e3bfd38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90c9fc77d5cdbf54dfac07da1e3bfd38">&#9670;&#160;</a></span>make_DelayedBooleanOrScalarHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBooleanScalarHelper.html">DelayedBooleanScalarHelper</a>&lt; DelayedBooleanOp::OR &gt; tatami::make_DelayedBooleanOrScalarHelper </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Scalar value to use in the operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed OR operation with a scalar. </dd></dl>

</div>
</div>
<a id="ad53fbda6886dc05059a1517d6932da7f" name="ad53fbda6886dc05059a1517d6932da7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad53fbda6886dc05059a1517d6932da7f">&#9670;&#160;</a></span>make_DelayedBooleanXorScalarHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBooleanScalarHelper.html">DelayedBooleanScalarHelper</a>&lt; DelayedBooleanOp::XOR &gt; tatami::make_DelayedBooleanXorScalarHelper </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Scalar value to be used in the operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed XOR operation with a scalar. </dd></dl>

</div>
</div>
<a id="abf1862b291e7f537a0e7745666fa8303" name="abf1862b291e7f537a0e7745666fa8303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf1862b291e7f537a0e7745666fa8303">&#9670;&#160;</a></span>make_DelayedBooleanEqualScalarHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBooleanScalarHelper.html">DelayedBooleanScalarHelper</a>&lt; DelayedBooleanOp::EQUAL &gt; tatami::make_DelayedBooleanEqualScalarHelper </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Scalar value to be used in the operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed boolean equality operation with a scalar. </dd></dl>

</div>
</div>
<a id="a5df2f96c32ef81f513f571c4bb24dbab" name="a5df2f96c32ef81f513f571c4bb24dbab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df2f96c32ef81f513f571c4bb24dbab">&#9670;&#160;</a></span>make_DelayedBooleanAndVectorHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int margin_, typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBooleanVectorHelper.html">DelayedBooleanVectorHelper</a>&lt; DelayedBooleanOp::AND, margin_, Vector_ &gt; tatami::make_DelayedBooleanAndVectorHelper </td>
          <td>(</td>
          <td class="paramtype">Vector_&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
    <tr><td class="paramname">margin_</td><td><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a> dimension along which the comparison is to occur, see <code><a class="el" href="structtatami_1_1DelayedBooleanVectorHelper.html" title="Delayed vector boolean operations.">DelayedBooleanVectorHelper</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector of values to be used in the operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed AND operation with a vector. </dd></dl>

</div>
</div>
<a id="ae774f806fbfb728cde3f3d23c9da36de" name="ae774f806fbfb728cde3f3d23c9da36de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae774f806fbfb728cde3f3d23c9da36de">&#9670;&#160;</a></span>make_DelayedBooleanOrVectorHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int margin_, typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBooleanVectorHelper.html">DelayedBooleanVectorHelper</a>&lt; DelayedBooleanOp::OR, margin_, Vector_ &gt; tatami::make_DelayedBooleanOrVectorHelper </td>
          <td>(</td>
          <td class="paramtype">Vector_&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
    <tr><td class="paramname">margin_</td><td><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a> dimension along which the comparison is to occur, see <code><a class="el" href="structtatami_1_1DelayedBooleanVectorHelper.html" title="Delayed vector boolean operations.">DelayedBooleanVectorHelper</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector of values to be used in the operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed OR operation with a vector. </dd></dl>

</div>
</div>
<a id="aca166576eae6f35fc987340bbef9310c" name="aca166576eae6f35fc987340bbef9310c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca166576eae6f35fc987340bbef9310c">&#9670;&#160;</a></span>make_DelayedBooleanXorVectorHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int margin_, typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBooleanVectorHelper.html">DelayedBooleanVectorHelper</a>&lt; DelayedBooleanOp::XOR, margin_, Vector_ &gt; tatami::make_DelayedBooleanXorVectorHelper </td>
          <td>(</td>
          <td class="paramtype">Vector_&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
    <tr><td class="paramname">margin_</td><td><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a> dimension along which the comparison is to occur, see <code><a class="el" href="structtatami_1_1DelayedBooleanVectorHelper.html" title="Delayed vector boolean operations.">DelayedBooleanVectorHelper</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector of values to be used in the operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed XOR operation with a vector. </dd></dl>

</div>
</div>
<a id="a94a1f4e7fec3b8b57aed9b02f06bbab5" name="a94a1f4e7fec3b8b57aed9b02f06bbab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94a1f4e7fec3b8b57aed9b02f06bbab5">&#9670;&#160;</a></span>make_DelayedBooleanEqualVectorHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int margin_, typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBooleanVectorHelper.html">DelayedBooleanVectorHelper</a>&lt; DelayedBooleanOp::EQUAL, margin_, Vector_ &gt; tatami::make_DelayedBooleanEqualVectorHelper </td>
          <td>(</td>
          <td class="paramtype">Vector_&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
    <tr><td class="paramname">margin_</td><td><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a> dimension along which the comparison is to occur, see <code><a class="el" href="structtatami_1_1DelayedBooleanVectorHelper.html" title="Delayed vector boolean operations.">DelayedBooleanVectorHelper</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector of values to be used in the operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed boolean equality operation with a vector. </dd></dl>

</div>
</div>
<a id="ac33adddd59d925a091b66c75b22b8eca" name="ac33adddd59d925a091b66c75b22b8eca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac33adddd59d925a091b66c75b22b8eca">&#9670;&#160;</a></span>make_DelayedEqualScalarHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedCompareScalarHelper.html">DelayedCompareScalarHelper</a>&lt; DelayedCompareOp::EQUAL, Scalar_ &gt; tatami::make_DelayedEqualScalarHelper </td>
          <td>(</td>
          <td class="paramtype">Scalar_&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Scalar value to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed equality comparison to a scalar. </dd></dl>

</div>
</div>
<a id="a6f548d89e93cbeaf155df8307a08fc00" name="a6f548d89e93cbeaf155df8307a08fc00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f548d89e93cbeaf155df8307a08fc00">&#9670;&#160;</a></span>make_DelayedGreaterThanScalarHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedCompareScalarHelper.html">DelayedCompareScalarHelper</a>&lt; DelayedCompareOp::GREATER_THAN, Scalar_ &gt; tatami::make_DelayedGreaterThanScalarHelper </td>
          <td>(</td>
          <td class="paramtype">Scalar_&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Scalar value to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed greater-than comparison to a scalar. </dd></dl>

</div>
</div>
<a id="a16b7349067d32a27deff236ca230be92" name="a16b7349067d32a27deff236ca230be92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b7349067d32a27deff236ca230be92">&#9670;&#160;</a></span>make_DelayedLessThanScalarHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedCompareScalarHelper.html">DelayedCompareScalarHelper</a>&lt; DelayedCompareOp::LESS_THAN, Scalar_ &gt; tatami::make_DelayedLessThanScalarHelper </td>
          <td>(</td>
          <td class="paramtype">Scalar_&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Scalar value to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed less-than comparison to a scalar. </dd></dl>

</div>
</div>
<a id="a83dd57b5347e89cf434582059254e09e" name="a83dd57b5347e89cf434582059254e09e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83dd57b5347e89cf434582059254e09e">&#9670;&#160;</a></span>make_DelayedGreaterThanOrEqualScalarHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedCompareScalarHelper.html">DelayedCompareScalarHelper</a>&lt; DelayedCompareOp::GREATER_THAN_OR_EQUAL, Scalar_ &gt; tatami::make_DelayedGreaterThanOrEqualScalarHelper </td>
          <td>(</td>
          <td class="paramtype">Scalar_&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Scalar value to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed greater-than-or-equal comparison to a scalar. </dd></dl>

</div>
</div>
<a id="a92d6a0a320c318c4c3cf4874965562ce" name="a92d6a0a320c318c4c3cf4874965562ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92d6a0a320c318c4c3cf4874965562ce">&#9670;&#160;</a></span>make_DelayedLessThanOrEqualScalarHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedCompareScalarHelper.html">DelayedCompareScalarHelper</a>&lt; DelayedCompareOp::LESS_THAN_OR_EQUAL, Scalar_ &gt; tatami::make_DelayedLessThanOrEqualScalarHelper </td>
          <td>(</td>
          <td class="paramtype">Scalar_&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Scalar value to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed less-than-or-equal comparison to a scalar. </dd></dl>

</div>
</div>
<a id="a27b9934b71e5f6d28b8c7f87a8216972" name="a27b9934b71e5f6d28b8c7f87a8216972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27b9934b71e5f6d28b8c7f87a8216972">&#9670;&#160;</a></span>make_DelayedNotEqualScalarHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedCompareScalarHelper.html">DelayedCompareScalarHelper</a>&lt; DelayedCompareOp::NOT_EQUAL, Scalar_ &gt; tatami::make_DelayedNotEqualScalarHelper </td>
          <td>(</td>
          <td class="paramtype">Scalar_&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Scalar value to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed non-equality comparison to a scalar. </dd></dl>

</div>
</div>
<a id="a258d8a40e2107e890ed9729d8134702a" name="a258d8a40e2107e890ed9729d8134702a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a258d8a40e2107e890ed9729d8134702a">&#9670;&#160;</a></span>make_DelayedEqualVectorHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int margin_, typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedCompareVectorHelper.html">DelayedCompareVectorHelper</a>&lt; DelayedCompareOp::EQUAL, margin_, Vector_ &gt; tatami::make_DelayedEqualVectorHelper </td>
          <td>(</td>
          <td class="paramtype">Vector_&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
    <tr><td class="paramname">margin_</td><td><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a> dimension along which the comparison is to occur, see <code><a class="el" href="structtatami_1_1DelayedCompareVectorHelper.html" title="Delayed vector comparisons.">DelayedCompareVectorHelper</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector of values to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed equality comparison to a vector. </dd></dl>

</div>
</div>
<a id="a8830d636d91bd512aca9c5afb8a10226" name="a8830d636d91bd512aca9c5afb8a10226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8830d636d91bd512aca9c5afb8a10226">&#9670;&#160;</a></span>make_DelayedGreaterThanVectorHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int margin_, typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedCompareVectorHelper.html">DelayedCompareVectorHelper</a>&lt; DelayedCompareOp::GREATER_THAN, margin_, Vector_ &gt; tatami::make_DelayedGreaterThanVectorHelper </td>
          <td>(</td>
          <td class="paramtype">Vector_&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
    <tr><td class="paramname">margin_</td><td><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a> dimension along which the comparison is to occur, see <code><a class="el" href="structtatami_1_1DelayedCompareVectorHelper.html" title="Delayed vector comparisons.">DelayedCompareVectorHelper</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector of values to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed greater-than comparison to a vector. </dd></dl>

</div>
</div>
<a id="a0e0dac7e0b22aa6d2d5cf1291d57ca5c" name="a0e0dac7e0b22aa6d2d5cf1291d57ca5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e0dac7e0b22aa6d2d5cf1291d57ca5c">&#9670;&#160;</a></span>make_DelayedLessThanVectorHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int margin_, typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedCompareVectorHelper.html">DelayedCompareVectorHelper</a>&lt; DelayedCompareOp::LESS_THAN, margin_, Vector_ &gt; tatami::make_DelayedLessThanVectorHelper </td>
          <td>(</td>
          <td class="paramtype">Vector_&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
    <tr><td class="paramname">margin_</td><td><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a> dimension along which the comparison is to occur, see <code><a class="el" href="structtatami_1_1DelayedCompareVectorHelper.html" title="Delayed vector comparisons.">DelayedCompareVectorHelper</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector of values to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed less-than comparison to a vector. </dd></dl>

</div>
</div>
<a id="a4342079e4437b82cfdb80e9ad6aba34e" name="a4342079e4437b82cfdb80e9ad6aba34e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4342079e4437b82cfdb80e9ad6aba34e">&#9670;&#160;</a></span>make_DelayedGreaterThanOrEqualVectorHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int margin_, typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedCompareVectorHelper.html">DelayedCompareVectorHelper</a>&lt; DelayedCompareOp::GREATER_THAN_OR_EQUAL, margin_, Vector_ &gt; tatami::make_DelayedGreaterThanOrEqualVectorHelper </td>
          <td>(</td>
          <td class="paramtype">Vector_&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
    <tr><td class="paramname">margin_</td><td><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a> dimension along which the comparison is to occur, see <code><a class="el" href="structtatami_1_1DelayedCompareVectorHelper.html" title="Delayed vector comparisons.">DelayedCompareVectorHelper</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector of values to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed greater-than-or-equal comparison to a vector. </dd></dl>

</div>
</div>
<a id="a8a3e3ef7cd498ae62b383f8c34b0b43b" name="a8a3e3ef7cd498ae62b383f8c34b0b43b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a3e3ef7cd498ae62b383f8c34b0b43b">&#9670;&#160;</a></span>make_DelayedLessThanOrEqualVectorHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int margin_, typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedCompareVectorHelper.html">DelayedCompareVectorHelper</a>&lt; DelayedCompareOp::LESS_THAN_OR_EQUAL, margin_, Vector_ &gt; tatami::make_DelayedLessThanOrEqualVectorHelper </td>
          <td>(</td>
          <td class="paramtype">Vector_&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
    <tr><td class="paramname">margin_</td><td><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a> dimension along which the comparison is to occur, see <code><a class="el" href="structtatami_1_1DelayedCompareVectorHelper.html" title="Delayed vector comparisons.">DelayedCompareVectorHelper</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector of values to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed less-than-or-equal comparison to a vector. </dd></dl>

</div>
</div>
<a id="ab6cdc6ca323706821899c20f00e42c52" name="ab6cdc6ca323706821899c20f00e42c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6cdc6ca323706821899c20f00e42c52">&#9670;&#160;</a></span>make_DelayedNotEqualVectorHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int margin_, typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedCompareVectorHelper.html">DelayedCompareVectorHelper</a>&lt; DelayedCompareOp::NOT_EQUAL, margin_, Vector_ &gt; tatami::make_DelayedNotEqualVectorHelper </td>
          <td>(</td>
          <td class="paramtype">Vector_&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
    <tr><td class="paramname">margin_</td><td><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a> dimension along which the comparison is to occur, see <code><a class="el" href="structtatami_1_1DelayedCompareVectorHelper.html" title="Delayed vector comparisons.">DelayedCompareVectorHelper</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector of values to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed non-equality comparison to a vector. </dd></dl>

</div>
</div>
<a id="a07b072944c766d85dc4ce4dc734e0b75" name="a07b072944c766d85dc4ce4dc734e0b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b072944c766d85dc4ce4dc734e0b75">&#9670;&#160;</a></span>make_DelayedUnaryIsometricOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ , class Operation_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; tatami::make_DelayedUnaryIsometricOp </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Operation_&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <code>make_*</code> helper function to enable partial template deduction of supplied types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of index value. </td></tr>
    <tr><td class="paramname">Operation_</td><td>Helper class defining the operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to a (possibly <code>const</code>) <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code>. </td></tr>
    <tr><td class="paramname">op</td><td>Instance of the operation helper class.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Instance of a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOp.html" title="Delayed isometric operations on a single matrix.">DelayedUnaryIsometricOp</a></code> clas. </dd></dl>

</div>
</div>
<a id="a44202790861791b1ed9df6d480c69f6a" name="a44202790861791b1ed9df6d480c69f6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44202790861791b1ed9df6d480c69f6a">&#9670;&#160;</a></span>column_medians()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Output_ &gt; tatami::column_medians </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Output_</td><td>Type of the output. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Shared pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of length equal to the number of columns, containing the column medians. </dd></dl>

</div>
</div>
<a id="ab877f67694b3fa500f59469f044b1c01" name="ab877f67694b3fa500f59469f044b1c01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab877f67694b3fa500f59469f044b1c01">&#9670;&#160;</a></span>row_medians()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Output_ &gt; tatami::row_medians </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Output</td><td>Type of the output. </td></tr>
    <tr><td class="paramname">T</td><td>Type of the matrix value. </td></tr>
    <tr><td class="paramname">IDX</td><td>Type of the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Shared pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of length equal to the number of rows, containing the row medians. </dd></dl>

</div>
</div>
<a id="a8102a2423efab5e329543f4235ac2290" name="a8102a2423efab5e329543f4235ac2290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8102a2423efab5e329543f4235ac2290">&#9670;&#160;</a></span>column_maxs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Output_ &gt; tatami::column_maxs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Output</td><td>Type of the output value. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of length equal to the number of columns, containing the maximum value in each column. </dd></dl>

</div>
</div>
<a id="a47890bfd538f65971f9e5dba5e1ed785" name="a47890bfd538f65971f9e5dba5e1ed785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47890bfd538f65971f9e5dba5e1ed785">&#9670;&#160;</a></span>row_maxs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Output_ &gt; tatami::row_maxs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Output</td><td>Type of the output value. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of length equal to the number of rows, containing the maximum value in each row. </dd></dl>

</div>
</div>
<a id="a60e44772f82183100c7c25c181479b56" name="a60e44772f82183100c7c25c181479b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e44772f82183100c7c25c181479b56">&#9670;&#160;</a></span>column_mins()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Output_ &gt; tatami::column_mins </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Output</td><td>Type of the output value. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of length equal to the number of columns, containing the minimum value in each column. </dd></dl>

</div>
</div>
<a id="a3bcdcb0499b36b5b844ebd88fc30eefe" name="a3bcdcb0499b36b5b844ebd88fc30eefe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bcdcb0499b36b5b844ebd88fc30eefe">&#9670;&#160;</a></span>row_mins()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Output_ &gt; tatami::row_mins </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Output</td><td>Type of the output value. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of length equal to the number of rows, containing the minimum value in each row. </dd></dl>

</div>
</div>
<a id="ab5eff79824930c458e730d23f640c1ab" name="ab5eff79824930c458e730d23f640c1ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5eff79824930c458e730d23f640c1ab">&#9670;&#160;</a></span>column_ranges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; Output_ &gt;, std::vector&lt; Output_ &gt; &gt; tatami::column_ranges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Output</td><td>Type of the output value. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of vectors, each of length equal to the number of rows. The first and second vector contains the minimum and maximum value per row, respectively. </dd></dl>

</div>
</div>
<a id="a2b2475a166ad744b31b1275e26e562be" name="a2b2475a166ad744b31b1275e26e562be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b2475a166ad744b31b1275e26e562be">&#9670;&#160;</a></span>row_ranges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; Output_ &gt;, std::vector&lt; Output_ &gt; &gt; tatami::row_ranges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Output</td><td>Type of the output value. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of vectors, each of length equal to the number of rows. The first and second vector contains the minimum and maximum value per row, respectively. </dd></dl>

</div>
</div>
<a id="a3aab6733d637b66abdf45f7300d2e1ba" name="a3aab6733d637b66abdf45f7300d2e1ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aab6733d637b66abdf45f7300d2e1ba">&#9670;&#160;</a></span>column_sums()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Output_ &gt; tatami::column_sums </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Output_</td><td>Type of the output value. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the matrix value, should be summable. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of length equal to the number of columns, containing the column sums. </dd></dl>

</div>
</div>
<a id="a53a658059404691856bef57fb85d83d6" name="a53a658059404691856bef57fb85d83d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53a658059404691856bef57fb85d83d6">&#9670;&#160;</a></span>row_sums()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Output_ &gt; tatami::row_sums </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Output_</td><td>Type of the output value. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the matrix value, should be summable. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of length equal to the number of rows, containing the row sums. </dd></dl>

</div>
</div>
<a id="a29ce7a2219ea60d45de1aa3d4de66063" name="a29ce7a2219ea60d45de1aa3d4de66063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29ce7a2219ea60d45de1aa3d4de66063">&#9670;&#160;</a></span>parallelize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool parallel_ = true, class Function_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tatami::parallelize </td>
          <td>(</td>
          <td class="paramtype">Function_&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tasks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>threads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply a function to a set of tasks, distributing them to threads via OpenMP if enabled. Callers can specify a custom parallelization scheme by defining a <code>TATAMI_CUSTOM_PARALLEL</code> function-like macro, which should accept the <code>fun</code>, <code>tasks</code> and <code>threads</code> arguments as below.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">parallel_</td><td>Whether the tasks should be run in parallel. If <code>false</code>, no parallelization is performed and all tasks are run on the current thread. </td></tr>
    <tr><td class="paramname">Function_</td><td>Function to be applied for a contiguous range of tasks. This should accept three arguments:<ul>
<li><code>thread</code>, the thread number executing this task range.</li>
<li><code>task_start</code>, the start index of the task range.</li>
<li><code>task_length</code>, the number of tasks in the task range.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fun</td><td>Function that executes a contiguous range of tasks. </td></tr>
    <tr><td class="paramname">tasks</td><td>Number of tasks. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36c6ecf33bcb87e1ed33c0a7d744dd82" name="a36c6ecf33bcb87e1ed33c0a7d744dd82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36c6ecf33bcb87e1ed33c0a7d744dd82">&#9670;&#160;</a></span>consecutive_extractor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool row_, bool sparse_, typename Value_ , typename Index_ , typename ... Args_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto tatami::consecutive_extractor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_&#160;</td>
          <td class="paramname"><em>iter_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_&#160;</td>
          <td class="paramname"><em>iter_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args_ &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">row_</td><td>Whether to perform extraction on rows. </td></tr>
    <tr><td class="paramname">sparse_</td><td>Whether to perform sparse retrieval. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of the row/column index. </td></tr>
    <tr><td class="paramname">Args_</td><td>Types of further arguments to pass to <code><a class="el" href="classtatami_1_1Matrix.html#aa29b9428f53453369256d7febc9ed0fc">Matrix::dense_row</a></code> or <code><a class="el" href="classtatami_1_1Matrix.html#a9f6c3453a5c0c28a764f300f45bf860f">Matrix::dense_column</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a> to iterate over. </td></tr>
    <tr><td class="paramname">iter_start</td><td>Index of the first row/column of the iteration range. </td></tr>
    <tr><td class="paramname">iter_length</td><td>Number of rows/columns in the iteration range. </td></tr>
    <tr><td class="paramname">args</td><td>Further arguments to pass to <code><a class="el" href="classtatami_1_1Matrix.html#aa29b9428f53453369256d7febc9ed0fc">Matrix::dense_row</a></code> or <code><a class="el" href="classtatami_1_1Matrix.html#a9f6c3453a5c0c28a764f300f45bf860f">Matrix::dense_column</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <code>Extractor</code> object for iteration over consecutive rows/columns in <code>[iter_start, iter_start + iter_length)</code>.</dd></dl>
<p>This function is equivalent to <code><a class="el" href="namespacetatami.html#a95b6638dceda82d82a7579dc88a45709">new_extractor()</a></code> but additionally calls <code>Extractor::set_oracle()</code> with a <code><a class="el" href="structtatami_1_1ConsecutiveOracle.html" title="Predict future accesses of a consecutive sequence.">ConsecutiveOracle</a></code> instance. <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> implementations that are oracle-aware can then perform pre-fetching of future accesses for greater performance. Of course, this assumes that the iteration over the target dimension does actually involve consecutive elements from <code>iter_start</code> to <code>iter_start + iter_length</code>. </p>

</div>
</div>
<a id="ac37af9a76d15f08a3634881696a27f65" name="ac37af9a76d15f08a3634881696a27f65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac37af9a76d15f08a3634881696a27f65">&#9670;&#160;</a></span>column_variances()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Output_ &gt; tatami::column_variances </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This uses the usual algorithm for matrices where <code><a class="el" href="classtatami_1_1Matrix.html#a69382d2a4e66cda1a9eb48dc25ab113a">tatami::Matrix::prefer_rows()</a></code> is false, otherwise it uses Welford's algorithm. As a result, the computed variances will be slightly different (within numerical precision) for row- and column-major matrices.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Output</td><td>Type of the output value. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the matrix value, should be numeric. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of length equal to the number of columns, containing the column variances. </dd></dl>

</div>
</div>
<a id="ab806279616e19f6150376a7c07d5b64b" name="ab806279616e19f6150376a7c07d5b64b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab806279616e19f6150376a7c07d5b64b">&#9670;&#160;</a></span>row_variances()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output_  = double, typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Output_ &gt; tatami::row_variances </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This uses the usual algorithm for matrices where <code><a class="el" href="classtatami_1_1Matrix.html#a69382d2a4e66cda1a9eb48dc25ab113a">tatami::Matrix::prefer_rows()</a></code> is true, otherwise it uses Welford's algorithm. As a result, the computed variances will be slightly different (within numerical precision) for row- and column-major matrices.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Output</td><td>Type of the output value. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the matrix value, should be numeric. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of length equal to the number of rows, containing the row variances. </dd></dl>

</div>
</div>
<a id="a87c52cf8a974ad0025550b002d391d39" name="a87c52cf8a974ad0025550b002d391d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87c52cf8a974ad0025550b002d391d39">&#9670;&#160;</a></span>bind_intersection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int margin, class <a class="el" href="classtatami_1_1Matrix.html">Matrix</a> , typename Id &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a> &gt;, std::vector&lt; size_t &gt; &gt; tatami::bind_intersection </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const Id * &gt; &amp;&#160;</td>
          <td class="paramname"><em>ids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Combine multiple matrices along the specified dimension while accounting for non-identical IDs along the other dimension. This function will identify the intersection of common identifiers across all matrices, subset each individual matrix to the intersection in the other dimension, and then combine them along the specified dimension.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">margin</td><td>The dimension to combine along - by rows (0) or columns (1). </td></tr>
    <tr><td class="paramname"><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></td><td>The <b>tatami</b> matrix class. </td></tr>
    <tr><td class="paramname">Id</td><td>Integer type representing the identifiers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputs</td><td>Vector of pointers to matrices to be combined along the dimension specified by <code>margin</code>. </td></tr>
    <tr><td class="paramname">ids</td><td>Vector of length equal to that of <code>inputs</code>, containing pointers to the identifiers for the matrices. Each pointer should refer to an array equal to the number of columns (if <code>margin = 0</code>) or rows (if <code>margin = 1</code>) in the corresponding entry of <code>inputs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair containing the combined matrix (first) and a vector of indices for the intersection (second). In the combined matrix, each column (if <code>margin = 0</code>) or row (if <code>margin = 1</code>) will correspond to an entry in the intersection vector. Indices in the intersection vector should be applied to <code>ids[0]</code> to obtain the actual identifiers of the rows/columns. </dd></dl>

</div>
</div>
<a id="ab17e92414b0bff60f7b7a6431ac8a330" name="ab17e92414b0bff60f7b7a6431ac8a330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab17e92414b0bff60f7b7a6431ac8a330">&#9670;&#160;</a></span>compress_sparse_triplets()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool ROW, class U , class V , class W &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; size_t &gt; tatami::compress_sparse_triplets </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">W &amp;&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ROW</td><td>Whether to create a compressed sparse row format. If <code>false</code>, the compressed sparse column format is used instead. </td></tr>
    <tr><td class="paramname">U</td><td>Random-access container for the values. </td></tr>
    <tr><td class="paramname">V</td><td>Random access container for the row indices. </td></tr>
    <tr><td class="paramname">W</td><td>Random access container for the column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nr</td><td>Number of rows. </td></tr>
    <tr><td class="paramname">nc</td><td>Number of columns. </td></tr>
    <tr><td class="paramname">rows</td><td>Row indices. Values must be non-negative integers less than <code>nr</code>. </td></tr>
    <tr><td class="paramname">cols</td><td>Column indices. Values must be non-negative integers less than <code>nc</code>. </td></tr>
    <tr><td class="paramname">values</td><td>Non-zero values.</td></tr>
  </table>
  </dd>
</dl>
<p><code>rows</code>, <code>cols</code> and <code>values</code> must be of the same length. Corresponding entries across these vectors are assumed to contain data for a single non-zero element.</p>
<dl class="section return"><dt>Returns</dt><dd><code>rows</code>, <code>cols</code> and <code>values</code> are sorted in-place by the row and column indices (if <code>ROW = true</code>) or by the column and row indices (if <code>ROW = false</code>). A vector of index pointers is returned with length <code>nr + 1</code> (if <code>ROW = true</code>) or <code>nc + 1</code> (if <code>ROW = false</code>). </dd></dl>

</div>
</div>
<a id="afaccb18d22f35a4ed6b6a7091342da06" name="afaccb18d22f35a4ed6b6a7091342da06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaccb18d22f35a4ed6b6a7091342da06">&#9670;&#160;</a></span>convert_to_dense() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool row_, typename StoredValue_ , class Matrix_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tatami::convert_to_dense </td>
          <td>(</td>
          <td class="paramtype">const Matrix_ *&#160;</td>
          <td class="paramname"><em>incoming</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StoredValue_ *&#160;</td>
          <td class="paramname"><em>store</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">row_</td><td>Whether to return a row-major matrix. </td></tr>
    <tr><td class="paramname">StoredValue_</td><td>Type of data values to be stored in the output. </td></tr>
    <tr><td class="paramname">Matrix_</td><td>Input matrix class, most typically a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">incoming</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">store</td><td>Pointer to an array of length equal to the product of the dimensions of <code>incoming</code>. On output, this is filled with values from <code>incoming</code> in row- or column-major format depending on <code>row_</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">threads</td><td>Number of threads to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af80143ac537339fe8dafd892632e96de" name="af80143ac537339fe8dafd892632e96de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af80143ac537339fe8dafd892632e96de">&#9670;&#160;</a></span>convert_to_dense() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool row_, typename Value_  = double, typename Index  = int, typename StoredValue_  = Value_, class Matrix_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index &gt; &gt; tatami::convert_to_dense </td>
          <td>(</td>
          <td class="paramtype">const Matrix_ *&#160;</td>
          <td class="paramname"><em>incoming</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">row</td><td>Whether to return a row-major matrix. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of data values in the output interface. </td></tr>
    <tr><td class="paramname">Index</td><td>Integer type for the indices in the output interface. </td></tr>
    <tr><td class="paramname">StoredValue_</td><td>Type of data values to be stored in the output. </td></tr>
    <tr><td class="paramname">Matrix_</td><td>Input matrix class, most typically a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">incoming</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a new <code><a class="el" href="classtatami_1_1DenseMatrix.html" title="Dense matrix representation.">tatami::DenseMatrix</a></code> with the same dimensions and type as the matrix referenced by <code>incoming</code>. If <code>row = true</code>, the matrix is row-major, otherwise it is column-major. </dd></dl>

</div>
</div>
<a id="a64e8745f8aaaa5ad93c6ce65a0a6591e" name="a64e8745f8aaaa5ad93c6ce65a0a6591e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64e8745f8aaaa5ad93c6ce65a0a6591e">&#9670;&#160;</a></span>convert_to_dense() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_  = double, typename Index_  = int, typename StoredValue_  = Value_, class Matrix_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; tatami::convert_to_dense </td>
          <td>(</td>
          <td class="paramtype">const Matrix_ *&#160;</td>
          <td class="paramname"><em>incoming</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This overload makes it easier to control the desired output order when it is not known at compile time.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of data values in the output interface. </td></tr>
    <tr><td class="paramname">Index</td><td>Integer type for the indices in the output interface. </td></tr>
    <tr><td class="paramname">StoredValue_</td><td>Type of data values to be stored in the output. </td></tr>
    <tr><td class="paramname">Matrix_</td><td>Input matrix class, most typically a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">incoming</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">order</td><td>Ordering of values in the output dense matrix - row-major (0) or column-major (1). If set to -1, the ordering is chosen based on <code><a class="el" href="classtatami_1_1Matrix.html#a69382d2a4e66cda1a9eb48dc25ab113a">tatami::Matrix::prefer_rows()</a></code>. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a new <code><a class="el" href="classtatami_1_1DenseMatrix.html" title="Dense matrix representation.">tatami::DenseMatrix</a></code> with the same dimensions and type as the matrix referenced by <code>incoming</code>. </dd></dl>

</div>
</div>
<a id="a220c47e470b3ade64ede7303e50ca92d" name="a220c47e470b3ade64ede7303e50ca92d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a220c47e470b3ade64ede7303e50ca92d">&#9670;&#160;</a></span>convert_to_sparse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool row_, typename Value_  = double, typename Index_  = int, typename StoredValue_  = Value_, typename StoredIndex_  = Index_, class InputMatrix_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; tatami::convert_to_sparse </td>
          <td>(</td>
          <td class="paramtype">const InputMatrix_ *&#160;</td>
          <td class="paramname"><em>incoming</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">row_</td><td>Whether to return a compressed sparse row matrix. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of data values in the output interface. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the indices in the output interface. </td></tr>
    <tr><td class="paramname">StoredValue_</td><td>Type of data values to be stored in the output. </td></tr>
    <tr><td class="paramname">StoredIndex_</td><td>Integer type for storing the indices in the output. </td></tr>
    <tr><td class="paramname">InputMatrix_</td><td>Input matrix class, most typically a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">incoming</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>, possibly containing delayed operations. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a new <code><a class="el" href="classtatami_1_1CompressedSparseMatrix.html" title="Compressed sparse matrix representation.">tatami::CompressedSparseMatrix</a></code>, with the same dimensions and type as the matrix referenced by <code>incoming</code>. If <code>row_ = true</code>, the matrix is compressed sparse row, otherwise it is compressed sparse column. </dd></dl>

</div>
</div>
<a id="a5847f3cd78ce89170ca43262d7f5f8e3" name="a5847f3cd78ce89170ca43262d7f5f8e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5847f3cd78ce89170ca43262d7f5f8e3">&#9670;&#160;</a></span>convert_to_sparse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_  = double, typename Index_  = int, typename StoredValue_  = Value_, typename StoredIndex_  = Index_, class InputMatrix_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; tatami::convert_to_sparse </td>
          <td>(</td>
          <td class="paramtype">const InputMatrix_ *&#160;</td>
          <td class="paramname"><em>incoming</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This overload makes it easier to control the desired output order when it is not known at compile time.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of data values in the output interface. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the indices in the output interface. </td></tr>
    <tr><td class="paramname">StoredValue_</td><td>Type of data values to be stored in the output. </td></tr>
    <tr><td class="paramname">StoredIndex_</td><td>Integer type for storing the indices in the output. </td></tr>
    <tr><td class="paramname">InputMatrix_</td><td>Input matrix class, most typically a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">incoming</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">order</td><td>Ordering of values in the output matrix - compressed sparse row (0) or column (1). If set to -1, the ordering is chosen based on <code><a class="el" href="classtatami_1_1Matrix.html#a69382d2a4e66cda1a9eb48dc25ab113a">tatami::Matrix::prefer_rows()</a></code>. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a new <code><a class="el" href="classtatami_1_1CompressedSparseMatrix.html" title="Compressed sparse matrix representation.">tatami::CompressedSparseMatrix</a></code>, with the same dimensions and type as the matrix referenced by <code>incoming</code>. </dd></dl>

</div>
</div>
<a id="af01c93a616eb99f6a17861a8b19f7ee0" name="af01c93a616eb99f6a17861a8b19f7ee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af01c93a616eb99f6a17861a8b19f7ee0">&#9670;&#160;</a></span>process_consecutive_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index_ , class Function_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tatami::process_consecutive_indices </td>
          <td>(</td>
          <td class="paramtype">const Index_ *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function_&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Process runs of consecutive indices that are used in the index-aware <code>dense_row()</code>, <code>sparse_column()</code>, etc. methods. This provides some opportunities for optimization when the indices contain contiguous stretches. For example, third-party libraries can be asked to process blocks of observations rather than handling them one at a time.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
    <tr><td class="paramname">Function_</td><td>Function to apply to each contiguous run.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Pointer to an array of sorted and unique indices for row/column elements. </td></tr>
    <tr><td class="paramname">length</td><td>Length of the array pointed to by <code>indices</code>. </td></tr>
    <tr><td class="paramname">fun</td><td>Function to apply to each contiguous run of indices. This should take two arguments - the start index of each run, and the length of the run. Calls to <code>fun</code> are guaranteed to contain increasing start indices with non-overlapping runs. The return value of this function is ignored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7518f5e8e09a6f6d7d3955b8ea286689" name="a7518f5e8e09a6f6d7d3955b8ea286689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7518f5e8e09a6f6d7d3955b8ea286689">&#9670;&#160;</a></span>wrap_shared_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; &gt; tatami::wrap_shared_ptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrap a raw pointer inside a <code>shared_ptr</code>, typically to enable use of a raw <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code> pointer with delayed operation wrappers. This enables use of delayed operations inside functions that accept a raw pointer to an externally owned <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to the same object addressed by <code>ptr</code>. The assumption is that <code>ptr</code> will always outlive the returned pointer. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
