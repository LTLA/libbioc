<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tatami: tatami Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tatami
   </div>
   <div id="projectbrief">C++ API for different matrix representations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">tatami Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Flexible representations for matrix data.  
<a href="namespacetatami.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1ArrayView.html">ArrayView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">View into a pre-allocated array.  <a href="classtatami_1_1ArrayView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1BlockSparsifiedWrapper.html">BlockSparsifiedWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap a block dense extractor in the sparse interface.  <a href="structtatami_1_1BlockSparsifiedWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1CompressedSparseContents.html">CompressedSparseContents</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compressed sparse contents.  <a href="structtatami_1_1CompressedSparseContents.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1CompressedSparseMatrix.html">CompressedSparseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compressed sparse matrix representation.  <a href="classtatami_1_1CompressedSparseMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1ConsecutiveOracle.html">ConsecutiveOracle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predict future accesses of a consecutive sequence.  <a href="structtatami_1_1ConsecutiveOracle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedAbsHelper.html">DelayedAbsHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the absolute value of a matrix entry.  <a href="structtatami_1_1DelayedAbsHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedAcosHelper.html">DelayedAcosHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the arc cosine of a matrix entry.  <a href="structtatami_1_1DelayedAcosHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedAcoshHelper.html">DelayedAcoshHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the inverse hyperbolic cosine of a matrix entry.  <a href="structtatami_1_1DelayedAcoshHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedArithScalarHelper.html">DelayedArithScalarHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed scalar arithmetic.  <a href="structtatami_1_1DelayedArithScalarHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedArithVectorHelper.html">DelayedArithVectorHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed vector arithmetic.  <a href="structtatami_1_1DelayedArithVectorHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedAsinHelper.html">DelayedAsinHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the arc sine of a matrix entry.  <a href="structtatami_1_1DelayedAsinHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedAsinhHelper.html">DelayedAsinhHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the inverse hyperbolic sine of a matrix entry.  <a href="structtatami_1_1DelayedAsinhHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedAtanHelper.html">DelayedAtanHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the arc tangent of a matrix entry.  <a href="structtatami_1_1DelayedAtanHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedAtanhHelper.html">DelayedAtanhHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the inverse hyperbolic tangent of a matrix entry.  <a href="structtatami_1_1DelayedAtanhHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedBinaryAdvancedMockHelper.html">DelayedBinaryAdvancedMockHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advanced mock operation for <code><a class="el" href="classtatami_1_1DelayedBinaryIsometricOp.html" title="Delayed isometric operations on two matrices.">DelayedBinaryIsometricOp</a></code>.  <a href="structtatami_1_1DelayedBinaryAdvancedMockHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedBinaryArithHelper.html">DelayedBinaryArithHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed binary arithmetic.  <a href="structtatami_1_1DelayedBinaryArithHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedBinaryBasicMockHelper.html">DelayedBinaryBasicMockHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic mock operation for <code><a class="el" href="classtatami_1_1DelayedBinaryIsometricOp.html" title="Delayed isometric operations on two matrices.">DelayedBinaryIsometricOp</a></code>.  <a href="structtatami_1_1DelayedBinaryBasicMockHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedBinaryBooleanHelper.html">DelayedBinaryBooleanHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed binary boolean operations.  <a href="structtatami_1_1DelayedBinaryBooleanHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedBinaryCompareHelper.html">DelayedBinaryCompareHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed binary comparison.  <a href="structtatami_1_1DelayedBinaryCompareHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedBinaryIsometricOp.html">DelayedBinaryIsometricOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed isometric operations on two matrices.  <a href="classtatami_1_1DelayedBinaryIsometricOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedBind.html">DelayedBind</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed combining of a matrix.  <a href="classtatami_1_1DelayedBind.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedBooleanNotHelper.html">DelayedBooleanNotHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed boolean NOT operation.  <a href="structtatami_1_1DelayedBooleanNotHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedBooleanScalarHelper.html">DelayedBooleanScalarHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed scalar boolean operation.  <a href="structtatami_1_1DelayedBooleanScalarHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedBooleanVectorHelper.html">DelayedBooleanVectorHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed vector boolean operations.  <a href="structtatami_1_1DelayedBooleanVectorHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedCast.html">DelayedCast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recast a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> to a different interface type.  <a href="classtatami_1_1DelayedCast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedCeilingHelper.html">DelayedCeilingHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the ceiling of a matrix entry.  <a href="structtatami_1_1DelayedCeilingHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedCompareScalarHelper.html">DelayedCompareScalarHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed scalar comparison.  <a href="structtatami_1_1DelayedCompareScalarHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedCompareVectorHelper.html">DelayedCompareVectorHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed vector comparisons.  <a href="structtatami_1_1DelayedCompareVectorHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedCosHelper.html">DelayedCosHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the cosine of a matrix entry.  <a href="structtatami_1_1DelayedCosHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedCoshHelper.html">DelayedCoshHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the hyperbolic cosine of a matrix entry.  <a href="structtatami_1_1DelayedCoshHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedExpHelper.html">DelayedExpHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a matrix entry as an exponent.  <a href="structtatami_1_1DelayedExpHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedExpm1Helper.html">DelayedExpm1Helper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a matrix entry as an exponent minus 1.  <a href="structtatami_1_1DelayedExpm1Helper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedFloorHelper.html">DelayedFloorHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the floor of a matrix entry.  <a href="structtatami_1_1DelayedFloorHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedGammaHelper.html">DelayedGammaHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the gamma of a matrix entry.  <a href="structtatami_1_1DelayedGammaHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedLgammaHelper.html">DelayedLgammaHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the logarithm of the gamma of a matrix entry.  <a href="structtatami_1_1DelayedLgammaHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedLog1pHelper.html">DelayedLog1pHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the logarithm of a matrix entry plus 1.  <a href="structtatami_1_1DelayedLog1pHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedLogHelper.html">DelayedLogHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the logarithm of a matrix entry.  <a href="structtatami_1_1DelayedLogHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedRoundHelper.html">DelayedRoundHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round a matrix entry to the nearest integer.  <a href="structtatami_1_1DelayedRoundHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedSignHelper.html">DelayedSignHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the sign of a matrix entry.  <a href="structtatami_1_1DelayedSignHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedSinHelper.html">DelayedSinHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the sine of a matrix entry.  <a href="structtatami_1_1DelayedSinHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedSinhHelper.html">DelayedSinhHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the hyperbolic sine of a matrix entry.  <a href="structtatami_1_1DelayedSinhHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedSqrtHelper.html">DelayedSqrtHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the square root of a matrix entry.  <a href="structtatami_1_1DelayedSqrtHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedSubset.html">DelayedSubset</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">delayed subsetting of a matrix with general indices.  <a href="classtatami_1_1DelayedSubset.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedSubsetBlock.html">DelayedSubsetBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed subsetting to a contiguous block.  <a href="classtatami_1_1DelayedSubsetBlock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedSubsetSorted.html">DelayedSubsetSorted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed subsetting of a matrix with sorted indices.  <a href="classtatami_1_1DelayedSubsetSorted.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html">DelayedSubsetSortedUnique</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed subsetting of a matrix with sorted, unique indices.  <a href="classtatami_1_1DelayedSubsetSortedUnique.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedSubsetUnique.html">DelayedSubsetUnique</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed subsetting of a matrix with unique indices.  <a href="classtatami_1_1DelayedSubsetUnique.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedTanHelper.html">DelayedTanHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the tangent of a matrix entry.  <a href="structtatami_1_1DelayedTanHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedTanhHelper.html">DelayedTanhHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the hyperbolic tangent of a matrix entry.  <a href="structtatami_1_1DelayedTanhHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedTranspose.html">DelayedTranspose</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed transposition of a matrix.  <a href="classtatami_1_1DelayedTranspose.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedTruncHelper.html">DelayedTruncHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the trunc of a matrix entry.  <a href="structtatami_1_1DelayedTruncHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedUnaryAdvancedMockHelper.html">DelayedUnaryAdvancedMockHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advanced mock operation for <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOp.html" title="Delayed isometric operations on a single matrix.">DelayedUnaryIsometricOp</a></code>.  <a href="structtatami_1_1DelayedUnaryAdvancedMockHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedUnaryBasicMockHelper.html">DelayedUnaryBasicMockHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic mock operation for a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOp.html" title="Delayed isometric operations on a single matrix.">DelayedUnaryIsometricOp</a></code>.  <a href="structtatami_1_1DelayedUnaryBasicMockHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricOp.html">DelayedUnaryIsometricOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed isometric operations on a single matrix.  <a href="classtatami_1_1DelayedUnaryIsometricOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DenseMatrix.html">DenseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dense matrix representation.  <a href="classtatami_1_1DenseMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1FixedVectorOracle.html">FixedVectorOracle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predict future accesses from a fixed sequence in a vector.  <a href="structtatami_1_1FixedVectorOracle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1FixedViewOracle.html">FixedViewOracle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predict future accesses from a view on a fixed sequence.  <a href="structtatami_1_1FixedViewOracle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1FragmentedSparseContents.html">FragmentedSparseContents</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fragmented sparse contents.  <a href="structtatami_1_1FragmentedSparseContents.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1FragmentedSparseMatrix.html">FragmentedSparseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fragmented sparse matrix representation.  <a href="classtatami_1_1FragmentedSparseMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1FullSparsifiedWrapper.html">FullSparsifiedWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap a full dense extractor in the sparse interface.  <a href="structtatami_1_1FullSparsifiedWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1has__data.html">has_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for the <code>data()</code> method.  <a href="structtatami_1_1has__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1has__data_3_01T_00_01V_00_01decltype_07_07void_08_01std_1_1declval_3_01V_01_4_07_08_8data_07_08_00_010_08_4.html">has_data&lt; T, V, decltype((void) std::declval&lt; V &gt;().data(), 0)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for the <code>data()</code> method.  <a href="structtatami_1_1has__data_3_01T_00_01V_00_01decltype_07_07void_08_01std_1_1declval_3_01V_01_4_07_08_8data_07_08_00_010_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1IndexSparsifiedWrapper.html">IndexSparsifiedWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap an indexed dense extractor in the sparse interface.  <a href="structtatami_1_1IndexSparsifiedWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html">Matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual class for a matrix with a defined type.  <a href="classtatami_1_1Matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a dimension element in dense form without an oracle.  <a href="structtatami_1_1MyopicDenseExtractor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract in sparse form without an oracle.  <a href="structtatami_1_1MyopicSparseExtractor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1Options.html">Options</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structtatami_1_1Options.html" title="Options for iteration and extraction.">Options</a> for iteration and extraction.  <a href="structtatami_1_1Options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1Oracle.html">Oracle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predict future access requests.  <a href="structtatami_1_1Oracle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract in dense form with an oracle.  <a href="structtatami_1_1OracularDenseExtractor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract in sparse form with an oracle.  <a href="structtatami_1_1OracularSparseExtractor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1PseudoOracularDenseExtractor.html">PseudoOracularDenseExtractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mimic the <code><a class="el" href="structtatami_1_1OracularDenseExtractor.html" title="Extract in dense form with an oracle.">OracularDenseExtractor</a></code> interface.  <a href="structtatami_1_1PseudoOracularDenseExtractor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1PseudoOracularSparseExtractor.html">PseudoOracularSparseExtractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mimic the <code><a class="el" href="structtatami_1_1OracularSparseExtractor.html" title="Extract in sparse form with an oracle.">OracularSparseExtractor</a></code> interface.  <a href="structtatami_1_1PseudoOracularSparseExtractor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1SomeNumericArray.html">SomeNumericArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of some numeric type, determined at runtime.  <a href="structtatami_1_1SomeNumericArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A range of a sparse vector.  <a href="structtatami_1_1SparseRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1SparseRangeCopy.html">SparseRangeCopy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A range of a sparse vector with copying.  <a href="structtatami_1_1SparseRangeCopy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a4e0374ed6401df3d6ae262ad379a4743" id="r_a4e0374ed6401df3d6ae262ad379a4743"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> oracle_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; </td></tr>
<tr class="memitem:a4e0374ed6401df3d6ae262ad379a4743"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a4e0374ed6401df3d6ae262ad379a4743">DenseExtractor</a> = <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> std::conditional&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">oracle_</a>, <a class="el" href="structtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;, <a class="el" href="structtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;::type</td></tr>
<tr class="separator:a4e0374ed6401df3d6ae262ad379a4743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a542a16a6a2c2c1efdc7b6e9eae9040" id="r_a9a542a16a6a2c2c1efdc7b6e9eae9040"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> oracle_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; </td></tr>
<tr class="memitem:a9a542a16a6a2c2c1efdc7b6e9eae9040"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a9a542a16a6a2c2c1efdc7b6e9eae9040">SparseExtractor</a> = <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> std::conditional&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">oracle_</a>, <a class="el" href="structtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;, <a class="el" href="structtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;::type</td></tr>
<tr class="separator:a9a542a16a6a2c2c1efdc7b6e9eae9040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb0bdf0b79fe19e504b49b43984f634" id="r_abbb0bdf0b79fe19e504b49b43984f634"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; </td></tr>
<tr class="memitem:abbb0bdf0b79fe19e504b49b43984f634"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#abbb0bdf0b79fe19e504b49b43984f634">VectorPtr</a> = std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> std::vector&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;</td></tr>
<tr class="separator:abbb0bdf0b79fe19e504b49b43984f634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c670894994f1d620abb55953f98441" id="r_a35c670894994f1d620abb55953f98441"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a35c670894994f1d620abb55953f98441">NumericMatrix</a> = <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">double</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> &gt;</td></tr>
<tr class="separator:a35c670894994f1d620abb55953f98441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac47a769e00660eb7e9b5fcd543bcf2d3" id="r_ac47a769e00660eb7e9b5fcd543bcf2d3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">class</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Storage_</a>  = std::vector&lt;Value_&gt;&gt; </td></tr>
<tr class="memitem:ac47a769e00660eb7e9b5fcd543bcf2d3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ac47a769e00660eb7e9b5fcd543bcf2d3">DenseColumnMatrix</a> = <a class="el" href="classtatami_1_1DenseMatrix.html">DenseMatrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">false</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Storage_</a> &gt;</td></tr>
<tr class="separator:ac47a769e00660eb7e9b5fcd543bcf2d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51122d20490b377cd3f4609cc044f314" id="r_a51122d20490b377cd3f4609cc044f314"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">class</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Storage_</a>  = std::vector&lt;Value_&gt;&gt; </td></tr>
<tr class="memitem:a51122d20490b377cd3f4609cc044f314"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a51122d20490b377cd3f4609cc044f314">DenseRowMatrix</a> = <a class="el" href="classtatami_1_1DenseMatrix.html">DenseMatrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">true</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Storage_</a> &gt;</td></tr>
<tr class="separator:a51122d20490b377cd3f4609cc044f314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18cee3a5d9734f0092b03d023cfe4b6a" id="r_a18cee3a5d9734f0092b03d023cfe4b6a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">class</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">ValueStorage_</a>  = std::vector&lt;Value_&gt;, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">class</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">IndexStorage_</a>  = std::vector&lt;Index_&gt;, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">class</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">PointerStorage_</a>  = std::vector&lt;size_t&gt;&gt; </td></tr>
<tr class="memitem:a18cee3a5d9734f0092b03d023cfe4b6a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a18cee3a5d9734f0092b03d023cfe4b6a">CompressedSparseColumnMatrix</a> = <a class="el" href="classtatami_1_1CompressedSparseMatrix.html">CompressedSparseMatrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">false</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">ValueStorage_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">IndexStorage_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">PointerStorage_</a> &gt;</td></tr>
<tr class="separator:a18cee3a5d9734f0092b03d023cfe4b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0111adeeb583aeb7e24e9e1e25be4aa0" id="r_a0111adeeb583aeb7e24e9e1e25be4aa0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">class</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">ValueStorage_</a>  = std::vector&lt;Value_&gt;, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">class</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">IndexStorage_</a>  = std::vector&lt;Index_&gt;, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">class</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">PointerStorage_</a>  = std::vector&lt;size_t&gt;&gt; </td></tr>
<tr class="memitem:a0111adeeb583aeb7e24e9e1e25be4aa0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a0111adeeb583aeb7e24e9e1e25be4aa0">CompressedSparseRowMatrix</a> = <a class="el" href="classtatami_1_1CompressedSparseMatrix.html">CompressedSparseMatrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">true</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">ValueStorage_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">IndexStorage_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">PointerStorage_</a> &gt;</td></tr>
<tr class="separator:a0111adeeb583aeb7e24e9e1e25be4aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9735bdc6e0a2856cd4747efbbf9f3c" id="r_a6b9735bdc6e0a2856cd4747efbbf9f3c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">class</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">ValueVectorStorage_</a>  = std::vector&lt;std::vector&lt;Value_&gt; &gt;, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">class</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">IndexVectorStorage_</a>  = std::vector&lt;std::vector&lt;Index_&gt; &gt;&gt; </td></tr>
<tr class="memitem:a6b9735bdc6e0a2856cd4747efbbf9f3c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a6b9735bdc6e0a2856cd4747efbbf9f3c">FragmentedSparseColumnMatrix</a> = <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html">FragmentedSparseMatrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">false</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">ValueVectorStorage_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">IndexVectorStorage_</a> &gt;</td></tr>
<tr class="separator:a6b9735bdc6e0a2856cd4747efbbf9f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d97fc9bd75052a79bb643d0fb5a0b98" id="r_a3d97fc9bd75052a79bb643d0fb5a0b98"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">class</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">ValueVectorStorage_</a>  = std::vector&lt;std::vector&lt;Value_&gt; &gt;, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">class</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">IndexVectorStorage_</a>  = std::vector&lt;std::vector&lt;Index_&gt; &gt;&gt; </td></tr>
<tr class="memitem:a3d97fc9bd75052a79bb643d0fb5a0b98"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a3d97fc9bd75052a79bb643d0fb5a0b98">FragmentedSparseRowMatrix</a> = <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html">FragmentedSparseMatrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">true</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">ValueVectorStorage_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">IndexVectorStorage_</a> &gt;</td></tr>
<tr class="separator:a3d97fc9bd75052a79bb643d0fb5a0b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a028d23a7be58854b2e60dfae1b04b" id="r_a58a028d23a7be58854b2e60dfae1b04b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">class</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Array_</a> &gt; </td></tr>
<tr class="memitem:a58a028d23a7be58854b2e60dfae1b04b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a58a028d23a7be58854b2e60dfae1b04b">ElementType</a> = <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> std::remove_cv&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> std::remove_reference&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">decltype</a>(std::declval&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Array_</a> &gt;()[0])&gt;::type &gt;::type</td></tr>
<tr class="separator:a58a028d23a7be58854b2e60dfae1b04b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9d426a238a93d02635b4172c725808" id="r_aab9d426a238a93d02635b4172c725808"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> oracle_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; </td></tr>
<tr class="memitem:aab9d426a238a93d02635b4172c725808"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#aab9d426a238a93d02635b4172c725808">MaybeOracle</a> = <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> std::conditional&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">oracle_</a>, std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> &gt;::type</td></tr>
<tr class="separator:aab9d426a238a93d02635b4172c725808"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a0a2ecaf58e2b69bb4a808e814aeb16a1" id="r_a0a2ecaf58e2b69bb4a808e814aeb16a1"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a0a2ecaf58e2b69bb4a808e814aeb16a1">DimensionSelectionType</a> : char { <b>FULL</b>
, <b>BLOCK</b>
, <b>INDEX</b>
 }</td></tr>
<tr class="separator:a0a2ecaf58e2b69bb4a808e814aeb16a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab44a37b3762de0c5b1ffbfceb25fa0f" id="r_aab44a37b3762de0c5b1ffbfceb25fa0f"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#aab44a37b3762de0c5b1ffbfceb25fa0f">DelayedArithOp</a> : char { <br />
&#160;&#160;<b>ADD</b>
, <b>SUBTRACT</b>
, <b>MULTIPLY</b>
, <b>DIVIDE</b>
, <br />
&#160;&#160;<b>POWER</b>
, <b>MODULO</b>
, <b>INTEGER_DIVIDE</b>
<br />
 }</td></tr>
<tr class="separator:aab44a37b3762de0c5b1ffbfceb25fa0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2104862d4068933ea4cc805c92f82d07" id="r_a2104862d4068933ea4cc805c92f82d07"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a2104862d4068933ea4cc805c92f82d07">DelayedBooleanOp</a> : char { <b>AND</b>
, <b>OR</b>
, <b>XOR</b>
, <b>EQUAL</b>
 }</td></tr>
<tr class="separator:a2104862d4068933ea4cc805c92f82d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4fc175a57ace709941b5ca7ddb19708" id="r_ac4fc175a57ace709941b5ca7ddb19708"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ac4fc175a57ace709941b5ca7ddb19708">DelayedCompareOp</a> : char { <br />
&#160;&#160;<b>EQUAL</b>
, <b>GREATER_THAN</b>
, <b>LESS_THAN</b>
, <b>GREATER_THAN_OR_EQUAL</b>
, <br />
&#160;&#160;<b>LESS_THAN_OR_EQUAL</b>
, <b>NOT_EQUAL</b>
<br />
 }</td></tr>
<tr class="separator:ac4fc175a57ace709941b5ca7ddb19708"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aaa4de72fa0357087aa607876b2b99366" id="r_aaa4de72fa0357087aa607876b2b99366"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">StoredValue_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputIndex_</a> &gt; </td></tr>
<tr class="memitem:aaa4de72fa0357087aa607876b2b99366"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#aaa4de72fa0357087aa607876b2b99366">convert_to_dense</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputIndex_</a> &gt; *<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">incoming</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">row</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">StoredValue_</a> *<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">store</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">threads</a>=1)</td></tr>
<tr class="separator:aaa4de72fa0357087aa607876b2b99366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6e4754f2e6c6451d16f88a01c87c14" id="r_a7b6e4754f2e6c6451d16f88a01c87c14"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">StoredValue_</a>  = Value_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputIndex_</a> &gt; </td></tr>
<tr class="memitem:a7b6e4754f2e6c6451d16f88a01c87c14"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a7b6e4754f2e6c6451d16f88a01c87c14">convert_to_dense</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputIndex_</a> &gt; *<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">incoming</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">row</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">threads</a>=1)</td></tr>
<tr class="separator:a7b6e4754f2e6c6451d16f88a01c87c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74ad14ba410177396121d272371dffd" id="r_aa74ad14ba410177396121d272371dffd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">StoredValue_</a>  = Value_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputIndex_</a> &gt; </td></tr>
<tr class="memitem:aa74ad14ba410177396121d272371dffd"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#aa74ad14ba410177396121d272371dffd">convert_to_dense</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputIndex_</a> &gt; *<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">incoming</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">order</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">threads</a>=1)</td></tr>
<tr class="separator:aa74ad14ba410177396121d272371dffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c1d1f96ea3a59d9f6106b17873d494" id="r_a07c1d1f96ea3a59d9f6106b17873d494"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Input_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Output_</a> &gt; </td></tr>
<tr class="memitem:a07c1d1f96ea3a59d9f6106b17873d494"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a07c1d1f96ea3a59d9f6106b17873d494">transpose</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Input_</a> *<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">input</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">size_t</a> nrow, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">size_t</a> ncol, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">size_t</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">input_stride</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Output_</a> *<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">output</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">size_t</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">output_stride</a>)</td></tr>
<tr class="separator:a07c1d1f96ea3a59d9f6106b17873d494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86be7b06c9d13b25f9ff04eed87430a7" id="r_a86be7b06c9d13b25f9ff04eed87430a7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Input_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Output_</a> &gt; </td></tr>
<tr class="memitem:a86be7b06c9d13b25f9ff04eed87430a7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a86be7b06c9d13b25f9ff04eed87430a7">transpose</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Input_</a> *<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">input</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">size_t</a> nrow, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">size_t</a> ncol, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Output_</a> *<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">output</a>)</td></tr>
<tr class="separator:a86be7b06c9d13b25f9ff04eed87430a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d138b1e7f6a26f814c025363cc3db80" id="r_a1d138b1e7f6a26f814c025363cc3db80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBinaryArithHelper.html">DelayedBinaryArithHelper</a>&lt; DelayedArithOp::ADD &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a1d138b1e7f6a26f814c025363cc3db80">make_DelayedBinaryAddHelper</a> ()</td></tr>
<tr class="separator:a1d138b1e7f6a26f814c025363cc3db80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c951d489cb0f2bb0e90f2cf4a25862" id="r_ac4c951d489cb0f2bb0e90f2cf4a25862"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBinaryArithHelper.html">DelayedBinaryArithHelper</a>&lt; DelayedArithOp::SUBTRACT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ac4c951d489cb0f2bb0e90f2cf4a25862">make_DelayedBinarySubtractHelper</a> ()</td></tr>
<tr class="separator:ac4c951d489cb0f2bb0e90f2cf4a25862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2569c540083a24f92af8140358e1e9c4" id="r_a2569c540083a24f92af8140358e1e9c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBinaryArithHelper.html">DelayedBinaryArithHelper</a>&lt; DelayedArithOp::MULTIPLY &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a2569c540083a24f92af8140358e1e9c4">make_DelayedBinaryMultiplyHelper</a> ()</td></tr>
<tr class="separator:a2569c540083a24f92af8140358e1e9c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4cf766f850766b966f7121728a6af8" id="r_aeb4cf766f850766b966f7121728a6af8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBinaryArithHelper.html">DelayedBinaryArithHelper</a>&lt; DelayedArithOp::DIVIDE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#aeb4cf766f850766b966f7121728a6af8">make_DelayedBinaryDivideHelper</a> ()</td></tr>
<tr class="separator:aeb4cf766f850766b966f7121728a6af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c73c04e7b08130ed7b46d93c4dfd11" id="r_ab6c73c04e7b08130ed7b46d93c4dfd11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBinaryArithHelper.html">DelayedBinaryArithHelper</a>&lt; DelayedArithOp::POWER &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ab6c73c04e7b08130ed7b46d93c4dfd11">make_DelayedBinaryPowerHelper</a> ()</td></tr>
<tr class="separator:ab6c73c04e7b08130ed7b46d93c4dfd11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04293eb1e8eefb7024cc192d75ac093e" id="r_a04293eb1e8eefb7024cc192d75ac093e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBinaryArithHelper.html">DelayedBinaryArithHelper</a>&lt; DelayedArithOp::MODULO &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a04293eb1e8eefb7024cc192d75ac093e">make_DelayedBinaryModuloHelper</a> ()</td></tr>
<tr class="separator:a04293eb1e8eefb7024cc192d75ac093e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f54741424bef6a21225935a45e9d53" id="r_aa8f54741424bef6a21225935a45e9d53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBinaryArithHelper.html">DelayedBinaryArithHelper</a>&lt; DelayedArithOp::INTEGER_DIVIDE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#aa8f54741424bef6a21225935a45e9d53">make_DelayedBinaryIntegerDivideHelper</a> ()</td></tr>
<tr class="separator:aa8f54741424bef6a21225935a45e9d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1063aea86897ef76e17b1772320b8f7d" id="r_a1063aea86897ef76e17b1772320b8f7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBinaryBooleanHelper.html">DelayedBinaryBooleanHelper</a>&lt; DelayedBooleanOp::EQUAL &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a1063aea86897ef76e17b1772320b8f7d">make_DelayedBinaryBooleanEqualHelper</a> ()</td></tr>
<tr class="separator:a1063aea86897ef76e17b1772320b8f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31625dbb50d420fe1b0da406f19ef33d" id="r_a31625dbb50d420fe1b0da406f19ef33d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBinaryBooleanHelper.html">DelayedBinaryBooleanHelper</a>&lt; DelayedBooleanOp::AND &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a31625dbb50d420fe1b0da406f19ef33d">make_DelayedBinaryBooleanAndHelper</a> ()</td></tr>
<tr class="separator:a31625dbb50d420fe1b0da406f19ef33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65bad100b39d9372fbeb23d16dae6588" id="r_a65bad100b39d9372fbeb23d16dae6588"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBinaryBooleanHelper.html">DelayedBinaryBooleanHelper</a>&lt; DelayedBooleanOp::OR &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a65bad100b39d9372fbeb23d16dae6588">make_DelayedBinaryBooleanOrHelper</a> ()</td></tr>
<tr class="separator:a65bad100b39d9372fbeb23d16dae6588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb091953ab0f55406935a52b7ecb7350" id="r_aeb091953ab0f55406935a52b7ecb7350"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBinaryBooleanHelper.html">DelayedBinaryBooleanHelper</a>&lt; DelayedBooleanOp::XOR &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#aeb091953ab0f55406935a52b7ecb7350">make_DelayedBinaryBooleanXorHelper</a> ()</td></tr>
<tr class="separator:aeb091953ab0f55406935a52b7ecb7350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3599db8f6d19fc9172da45a3b6244fc" id="r_ac3599db8f6d19fc9172da45a3b6244fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBinaryCompareHelper.html">DelayedBinaryCompareHelper</a>&lt; DelayedCompareOp::EQUAL &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ac3599db8f6d19fc9172da45a3b6244fc">make_DelayedBinaryEqualHelper</a> ()</td></tr>
<tr class="separator:ac3599db8f6d19fc9172da45a3b6244fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4fb79c5a2cddab2f5c9cf0bd9fe3d0" id="r_abe4fb79c5a2cddab2f5c9cf0bd9fe3d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBinaryCompareHelper.html">DelayedBinaryCompareHelper</a>&lt; DelayedCompareOp::GREATER_THAN &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#abe4fb79c5a2cddab2f5c9cf0bd9fe3d0">make_DelayedBinaryGreaterThanHelper</a> ()</td></tr>
<tr class="separator:abe4fb79c5a2cddab2f5c9cf0bd9fe3d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a24f5bf2c2c61382aef43f2c8d3362" id="r_ae6a24f5bf2c2c61382aef43f2c8d3362"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBinaryCompareHelper.html">DelayedBinaryCompareHelper</a>&lt; DelayedCompareOp::LESS_THAN &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ae6a24f5bf2c2c61382aef43f2c8d3362">make_DelayedBinaryLessThanHelper</a> ()</td></tr>
<tr class="separator:ae6a24f5bf2c2c61382aef43f2c8d3362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31cd299427d73538dc00dcbffa9cd2b" id="r_ad31cd299427d73538dc00dcbffa9cd2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBinaryCompareHelper.html">DelayedBinaryCompareHelper</a>&lt; DelayedCompareOp::GREATER_THAN_OR_EQUAL &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ad31cd299427d73538dc00dcbffa9cd2b">make_DelayedBinaryGreaterThanOrEqualHelper</a> ()</td></tr>
<tr class="separator:ad31cd299427d73538dc00dcbffa9cd2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c7cc26409e5c995b7264164b148f4c" id="r_a38c7cc26409e5c995b7264164b148f4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBinaryCompareHelper.html">DelayedBinaryCompareHelper</a>&lt; DelayedCompareOp::LESS_THAN_OR_EQUAL &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a38c7cc26409e5c995b7264164b148f4c">make_DelayedBinaryLessThanOrEqualHelper</a> ()</td></tr>
<tr class="separator:a38c7cc26409e5c995b7264164b148f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3073c4e33dcf89416af292399ba55c29" id="r_a3073c4e33dcf89416af292399ba55c29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBinaryCompareHelper.html">DelayedBinaryCompareHelper</a>&lt; DelayedCompareOp::NOT_EQUAL &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a3073c4e33dcf89416af292399ba55c29">make_DelayedBinaryNotEqualHelper</a> ()</td></tr>
<tr class="separator:a3073c4e33dcf89416af292399ba55c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39c0767d23c6bdc5f4267f062ef2e17" id="r_af39c0767d23c6bdc5f4267f062ef2e17"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">class</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Operation_</a> &gt; </td></tr>
<tr class="memitem:af39c0767d23c6bdc5f4267f062ef2e17"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#af39c0767d23c6bdc5f4267f062ef2e17">make_DelayedBinaryIsometricOp</a> (std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; left, std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; right, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Operation_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">op</a>)</td></tr>
<tr class="separator:af39c0767d23c6bdc5f4267f062ef2e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b2b9798f2a43b62821131ba3a3f6bd" id="r_a33b2b9798f2a43b62821131ba3a3f6bd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a>  = Value_&gt; </td></tr>
<tr class="memitem:a33b2b9798f2a43b62821131ba3a3f6bd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedArithScalarHelper.html">DelayedArithScalarHelper</a>&lt; DelayedArithOp::ADD, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">true</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a33b2b9798f2a43b62821131ba3a3f6bd">make_DelayedAddScalarHelper</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">s</a>)</td></tr>
<tr class="separator:a33b2b9798f2a43b62821131ba3a3f6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bdfe26c0f1426b611e91ee7569045de" id="r_a9bdfe26c0f1426b611e91ee7569045de"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> right_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a>  = Value_&gt; </td></tr>
<tr class="memitem:a9bdfe26c0f1426b611e91ee7569045de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedArithScalarHelper.html">DelayedArithScalarHelper</a>&lt; DelayedArithOp::SUBTRACT, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">right_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a9bdfe26c0f1426b611e91ee7569045de">make_DelayedSubtractScalarHelper</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">s</a>)</td></tr>
<tr class="separator:a9bdfe26c0f1426b611e91ee7569045de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa653b51960498cc467ea69c18ea0c097" id="r_aa653b51960498cc467ea69c18ea0c097"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a>  = Value_&gt; </td></tr>
<tr class="memitem:aa653b51960498cc467ea69c18ea0c097"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedArithScalarHelper.html">DelayedArithScalarHelper</a>&lt; DelayedArithOp::MULTIPLY, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">true</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#aa653b51960498cc467ea69c18ea0c097">make_DelayedMultiplyScalarHelper</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">s</a>)</td></tr>
<tr class="separator:aa653b51960498cc467ea69c18ea0c097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60076096ee4296c0e187a226be5ca4b5" id="r_a60076096ee4296c0e187a226be5ca4b5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> right_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a>  = Value_&gt; </td></tr>
<tr class="memitem:a60076096ee4296c0e187a226be5ca4b5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedArithScalarHelper.html">DelayedArithScalarHelper</a>&lt; DelayedArithOp::DIVIDE, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">right_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a60076096ee4296c0e187a226be5ca4b5">make_DelayedDivideScalarHelper</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">s</a>)</td></tr>
<tr class="separator:a60076096ee4296c0e187a226be5ca4b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c478145f87c37a9fe6d4e8490fbf05c" id="r_a8c478145f87c37a9fe6d4e8490fbf05c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> right_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a>  = Value_&gt; </td></tr>
<tr class="memitem:a8c478145f87c37a9fe6d4e8490fbf05c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedArithScalarHelper.html">DelayedArithScalarHelper</a>&lt; DelayedArithOp::POWER, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">right_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a8c478145f87c37a9fe6d4e8490fbf05c">make_DelayedPowerScalarHelper</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">s</a>)</td></tr>
<tr class="separator:a8c478145f87c37a9fe6d4e8490fbf05c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5504f584d6db28c05d78f1917c40810d" id="r_a5504f584d6db28c05d78f1917c40810d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> right_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a>  = Value_&gt; </td></tr>
<tr class="memitem:a5504f584d6db28c05d78f1917c40810d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedArithScalarHelper.html">DelayedArithScalarHelper</a>&lt; DelayedArithOp::MODULO, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">right_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a5504f584d6db28c05d78f1917c40810d">make_DelayedModuloScalarHelper</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">s</a>)</td></tr>
<tr class="separator:a5504f584d6db28c05d78f1917c40810d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec92ba88a0f5e9d7bf52021ed28e859" id="r_a5ec92ba88a0f5e9d7bf52021ed28e859"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> right_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a>  = Value_&gt; </td></tr>
<tr class="memitem:a5ec92ba88a0f5e9d7bf52021ed28e859"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedArithScalarHelper.html">DelayedArithScalarHelper</a>&lt; DelayedArithOp::INTEGER_DIVIDE, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">right_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a5ec92ba88a0f5e9d7bf52021ed28e859">make_DelayedIntegerDivideScalarHelper</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">s</a>)</td></tr>
<tr class="separator:a5ec92ba88a0f5e9d7bf52021ed28e859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628c631be4424b37c1c1e68e28c5e982" id="r_a628c631be4424b37c1c1e68e28c5e982"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> margin_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>  = std::vector&lt;double&gt;&gt; </td></tr>
<tr class="memitem:a628c631be4424b37c1c1e68e28c5e982"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedArithVectorHelper.html">DelayedArithVectorHelper</a>&lt; DelayedArithOp::ADD, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">true</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">margin_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a628c631be4424b37c1c1e68e28c5e982">make_DelayedAddVectorHelper</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">v</a>)</td></tr>
<tr class="separator:a628c631be4424b37c1c1e68e28c5e982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a800b92854282015d96308fb283aeb508" id="r_a800b92854282015d96308fb283aeb508"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> right_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> margin_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>  = std::vector&lt;double&gt;&gt; </td></tr>
<tr class="memitem:a800b92854282015d96308fb283aeb508"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedArithVectorHelper.html">DelayedArithVectorHelper</a>&lt; DelayedArithOp::SUBTRACT, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">right_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">margin_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a800b92854282015d96308fb283aeb508">make_DelayedSubtractVectorHelper</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">v</a>)</td></tr>
<tr class="separator:a800b92854282015d96308fb283aeb508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab929acdeb634187cd08d1100bbbf1b29" id="r_ab929acdeb634187cd08d1100bbbf1b29"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> margin_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>  = std::vector&lt;double&gt;&gt; </td></tr>
<tr class="memitem:ab929acdeb634187cd08d1100bbbf1b29"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedArithVectorHelper.html">DelayedArithVectorHelper</a>&lt; DelayedArithOp::MULTIPLY, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">true</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">margin_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ab929acdeb634187cd08d1100bbbf1b29">make_DelayedMultiplyVectorHelper</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">v</a>)</td></tr>
<tr class="separator:ab929acdeb634187cd08d1100bbbf1b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4629f17aa4f3a4be06f3479bb6f68f" id="r_a1a4629f17aa4f3a4be06f3479bb6f68f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> right_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> margin_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>  = std::vector&lt;double&gt;&gt; </td></tr>
<tr class="memitem:a1a4629f17aa4f3a4be06f3479bb6f68f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedArithVectorHelper.html">DelayedArithVectorHelper</a>&lt; DelayedArithOp::DIVIDE, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">right_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">margin_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a1a4629f17aa4f3a4be06f3479bb6f68f">make_DelayedDivideVectorHelper</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">v</a>)</td></tr>
<tr class="separator:a1a4629f17aa4f3a4be06f3479bb6f68f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe489bd754c040491ebc753a4e5656e" id="r_aafe489bd754c040491ebc753a4e5656e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> right_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> margin_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>  = std::vector&lt;double&gt;&gt; </td></tr>
<tr class="memitem:aafe489bd754c040491ebc753a4e5656e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedArithVectorHelper.html">DelayedArithVectorHelper</a>&lt; DelayedArithOp::POWER, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">right_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">margin_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#aafe489bd754c040491ebc753a4e5656e">make_DelayedPowerVectorHelper</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">v</a>)</td></tr>
<tr class="separator:aafe489bd754c040491ebc753a4e5656e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4220ce5709e46ebce77b240b572d97d9" id="r_a4220ce5709e46ebce77b240b572d97d9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> right_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> margin_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>  = std::vector&lt;double&gt;&gt; </td></tr>
<tr class="memitem:a4220ce5709e46ebce77b240b572d97d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedArithVectorHelper.html">DelayedArithVectorHelper</a>&lt; DelayedArithOp::MODULO, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">right_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">margin_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a4220ce5709e46ebce77b240b572d97d9">make_DelayedModuloVectorHelper</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">v</a>)</td></tr>
<tr class="separator:a4220ce5709e46ebce77b240b572d97d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857fc6c11ec69895ac85991ac83c395d" id="r_a857fc6c11ec69895ac85991ac83c395d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> right_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> margin_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>  = std::vector&lt;double&gt;&gt; </td></tr>
<tr class="memitem:a857fc6c11ec69895ac85991ac83c395d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedArithVectorHelper.html">DelayedArithVectorHelper</a>&lt; DelayedArithOp::INTEGER_DIVIDE, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">right_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">margin_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a857fc6c11ec69895ac85991ac83c395d">make_DelayedIntegerDivideVectorHelper</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">v</a>)</td></tr>
<tr class="separator:a857fc6c11ec69895ac85991ac83c395d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac812e757b55c2145bc3d4cd113c712fd" id="r_ac812e757b55c2145bc3d4cd113c712fd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double&gt; </td></tr>
<tr class="memitem:ac812e757b55c2145bc3d4cd113c712fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBooleanNotHelper.html">DelayedBooleanNotHelper</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ac812e757b55c2145bc3d4cd113c712fd">make_DelayedBooleanNotHelper</a> ()</td></tr>
<tr class="separator:ac812e757b55c2145bc3d4cd113c712fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae460e24124cef43d8a5d3b82e8f02325" id="r_ae460e24124cef43d8a5d3b82e8f02325"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double&gt; </td></tr>
<tr class="memitem:ae460e24124cef43d8a5d3b82e8f02325"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBooleanScalarHelper.html">DelayedBooleanScalarHelper</a>&lt; DelayedBooleanOp::AND, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ae460e24124cef43d8a5d3b82e8f02325">make_DelayedBooleanAndScalarHelper</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">s</a>)</td></tr>
<tr class="separator:ae460e24124cef43d8a5d3b82e8f02325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7dbc64e6b0a0c8c48b1423b4b6748f1" id="r_ac7dbc64e6b0a0c8c48b1423b4b6748f1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double&gt; </td></tr>
<tr class="memitem:ac7dbc64e6b0a0c8c48b1423b4b6748f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBooleanScalarHelper.html">DelayedBooleanScalarHelper</a>&lt; DelayedBooleanOp::OR &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ac7dbc64e6b0a0c8c48b1423b4b6748f1">make_DelayedBooleanOrScalarHelper</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">s</a>)</td></tr>
<tr class="separator:ac7dbc64e6b0a0c8c48b1423b4b6748f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f6f1b1d28c670f38fda651fe2aa03a" id="r_a29f6f1b1d28c670f38fda651fe2aa03a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double&gt; </td></tr>
<tr class="memitem:a29f6f1b1d28c670f38fda651fe2aa03a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBooleanScalarHelper.html">DelayedBooleanScalarHelper</a>&lt; DelayedBooleanOp::XOR &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a29f6f1b1d28c670f38fda651fe2aa03a">make_DelayedBooleanXorScalarHelper</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">s</a>)</td></tr>
<tr class="separator:a29f6f1b1d28c670f38fda651fe2aa03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc5d47e0c391c17c85bddf19cc5620a" id="r_a6bc5d47e0c391c17c85bddf19cc5620a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double&gt; </td></tr>
<tr class="memitem:a6bc5d47e0c391c17c85bddf19cc5620a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBooleanScalarHelper.html">DelayedBooleanScalarHelper</a>&lt; DelayedBooleanOp::EQUAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a6bc5d47e0c391c17c85bddf19cc5620a">make_DelayedBooleanEqualScalarHelper</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">s</a>)</td></tr>
<tr class="separator:a6bc5d47e0c391c17c85bddf19cc5620a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd06669afab8565747e08bbce4b041f" id="r_a1fd06669afab8565747e08bbce4b041f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> margin_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>  = std::vector&lt;Value_&gt;&gt; </td></tr>
<tr class="memitem:a1fd06669afab8565747e08bbce4b041f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBooleanVectorHelper.html">DelayedBooleanVectorHelper</a>&lt; DelayedBooleanOp::AND, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">margin_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a1fd06669afab8565747e08bbce4b041f">make_DelayedBooleanAndVectorHelper</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">v</a>)</td></tr>
<tr class="separator:a1fd06669afab8565747e08bbce4b041f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503f23fe3e5a2c5f5bc6c0db01a7f64d" id="r_a503f23fe3e5a2c5f5bc6c0db01a7f64d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> margin_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>  = std::vector&lt;Value_&gt;&gt; </td></tr>
<tr class="memitem:a503f23fe3e5a2c5f5bc6c0db01a7f64d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBooleanVectorHelper.html">DelayedBooleanVectorHelper</a>&lt; DelayedBooleanOp::OR, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">margin_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a503f23fe3e5a2c5f5bc6c0db01a7f64d">make_DelayedBooleanOrVectorHelper</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">v</a>)</td></tr>
<tr class="separator:a503f23fe3e5a2c5f5bc6c0db01a7f64d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bcdace63565fc670b0393675e33bb11" id="r_a4bcdace63565fc670b0393675e33bb11"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> margin_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>  = std::vector&lt;Value_&gt;&gt; </td></tr>
<tr class="memitem:a4bcdace63565fc670b0393675e33bb11"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBooleanVectorHelper.html">DelayedBooleanVectorHelper</a>&lt; DelayedBooleanOp::XOR, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">margin_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a4bcdace63565fc670b0393675e33bb11">make_DelayedBooleanXorVectorHelper</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">v</a>)</td></tr>
<tr class="separator:a4bcdace63565fc670b0393675e33bb11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b07dc8b7a71776bcc222d7c437e2ca3" id="r_a8b07dc8b7a71776bcc222d7c437e2ca3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> margin_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>  = std::vector&lt;Value_&gt;&gt; </td></tr>
<tr class="memitem:a8b07dc8b7a71776bcc222d7c437e2ca3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBooleanVectorHelper.html">DelayedBooleanVectorHelper</a>&lt; DelayedBooleanOp::EQUAL, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">margin_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a8b07dc8b7a71776bcc222d7c437e2ca3">make_DelayedBooleanEqualVectorHelper</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">v</a>)</td></tr>
<tr class="separator:a8b07dc8b7a71776bcc222d7c437e2ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11bfea31e4524927274dc1d80c32fd96" id="r_a11bfea31e4524927274dc1d80c32fd96"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a>  = Value_&gt; </td></tr>
<tr class="memitem:a11bfea31e4524927274dc1d80c32fd96"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedCompareScalarHelper.html">DelayedCompareScalarHelper</a>&lt; DelayedCompareOp::EQUAL, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a11bfea31e4524927274dc1d80c32fd96">make_DelayedEqualScalarHelper</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">s</a>)</td></tr>
<tr class="separator:a11bfea31e4524927274dc1d80c32fd96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1961ba2a59d705adf7b8627523a62b3a" id="r_a1961ba2a59d705adf7b8627523a62b3a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a>  = Value_&gt; </td></tr>
<tr class="memitem:a1961ba2a59d705adf7b8627523a62b3a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedCompareScalarHelper.html">DelayedCompareScalarHelper</a>&lt; DelayedCompareOp::GREATER_THAN, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a1961ba2a59d705adf7b8627523a62b3a">make_DelayedGreaterThanScalarHelper</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">s</a>)</td></tr>
<tr class="separator:a1961ba2a59d705adf7b8627523a62b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d2d381ec9c0d87f5d561b4dd9d5a58e" id="r_a7d2d381ec9c0d87f5d561b4dd9d5a58e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a>  = Value_&gt; </td></tr>
<tr class="memitem:a7d2d381ec9c0d87f5d561b4dd9d5a58e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedCompareScalarHelper.html">DelayedCompareScalarHelper</a>&lt; DelayedCompareOp::LESS_THAN, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a7d2d381ec9c0d87f5d561b4dd9d5a58e">make_DelayedLessThanScalarHelper</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">s</a>)</td></tr>
<tr class="separator:a7d2d381ec9c0d87f5d561b4dd9d5a58e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3df12ccdf4692c0f660f1634a79b857" id="r_ac3df12ccdf4692c0f660f1634a79b857"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a>  = Value_&gt; </td></tr>
<tr class="memitem:ac3df12ccdf4692c0f660f1634a79b857"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedCompareScalarHelper.html">DelayedCompareScalarHelper</a>&lt; DelayedCompareOp::GREATER_THAN_OR_EQUAL, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ac3df12ccdf4692c0f660f1634a79b857">make_DelayedGreaterThanOrEqualScalarHelper</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">s</a>)</td></tr>
<tr class="separator:ac3df12ccdf4692c0f660f1634a79b857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e67b02534cbe1813be5e2d690af88b" id="r_af5e67b02534cbe1813be5e2d690af88b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a>  = Value_&gt; </td></tr>
<tr class="memitem:af5e67b02534cbe1813be5e2d690af88b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedCompareScalarHelper.html">DelayedCompareScalarHelper</a>&lt; DelayedCompareOp::LESS_THAN_OR_EQUAL, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#af5e67b02534cbe1813be5e2d690af88b">make_DelayedLessThanOrEqualScalarHelper</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">s</a>)</td></tr>
<tr class="separator:af5e67b02534cbe1813be5e2d690af88b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d5cef56d2119e73e3f670d49de6b48" id="r_ac5d5cef56d2119e73e3f670d49de6b48"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a>  = Value_&gt; </td></tr>
<tr class="memitem:ac5d5cef56d2119e73e3f670d49de6b48"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedCompareScalarHelper.html">DelayedCompareScalarHelper</a>&lt; DelayedCompareOp::NOT_EQUAL, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ac5d5cef56d2119e73e3f670d49de6b48">make_DelayedNotEqualScalarHelper</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">s</a>)</td></tr>
<tr class="separator:ac5d5cef56d2119e73e3f670d49de6b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40c54d5c5cc1109d42a150f5cd7ed2f" id="r_aa40c54d5c5cc1109d42a150f5cd7ed2f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> margin_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>  = std::vector&lt;Value_&gt;&gt; </td></tr>
<tr class="memitem:aa40c54d5c5cc1109d42a150f5cd7ed2f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedCompareVectorHelper.html">DelayedCompareVectorHelper</a>&lt; DelayedCompareOp::EQUAL, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">margin_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#aa40c54d5c5cc1109d42a150f5cd7ed2f">make_DelayedEqualVectorHelper</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">v</a>)</td></tr>
<tr class="separator:aa40c54d5c5cc1109d42a150f5cd7ed2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1951e22415be4714495556f701a7fd" id="r_aaf1951e22415be4714495556f701a7fd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> margin_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>  = std::vector&lt;Value_&gt;&gt; </td></tr>
<tr class="memitem:aaf1951e22415be4714495556f701a7fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedCompareVectorHelper.html">DelayedCompareVectorHelper</a>&lt; DelayedCompareOp::GREATER_THAN, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">margin_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#aaf1951e22415be4714495556f701a7fd">make_DelayedGreaterThanVectorHelper</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">v</a>)</td></tr>
<tr class="separator:aaf1951e22415be4714495556f701a7fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dca8b9072813f6e9e52aa0536817b82" id="r_a6dca8b9072813f6e9e52aa0536817b82"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> margin_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>  = std::vector&lt;Value_&gt;&gt; </td></tr>
<tr class="memitem:a6dca8b9072813f6e9e52aa0536817b82"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedCompareVectorHelper.html">DelayedCompareVectorHelper</a>&lt; DelayedCompareOp::LESS_THAN, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">margin_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a6dca8b9072813f6e9e52aa0536817b82">make_DelayedLessThanVectorHelper</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">v</a>)</td></tr>
<tr class="separator:a6dca8b9072813f6e9e52aa0536817b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a3e0489fdaccc80c7cc0125e9cf906" id="r_a70a3e0489fdaccc80c7cc0125e9cf906"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> margin_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>  = std::vector&lt;Value_&gt;&gt; </td></tr>
<tr class="memitem:a70a3e0489fdaccc80c7cc0125e9cf906"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedCompareVectorHelper.html">DelayedCompareVectorHelper</a>&lt; DelayedCompareOp::GREATER_THAN_OR_EQUAL, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">margin_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a70a3e0489fdaccc80c7cc0125e9cf906">make_DelayedGreaterThanOrEqualVectorHelper</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">v</a>)</td></tr>
<tr class="separator:a70a3e0489fdaccc80c7cc0125e9cf906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83999d2ac877c5b15f6fd5a0f33a894a" id="r_a83999d2ac877c5b15f6fd5a0f33a894a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> margin_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>  = std::vector&lt;Value_&gt;&gt; </td></tr>
<tr class="memitem:a83999d2ac877c5b15f6fd5a0f33a894a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedCompareVectorHelper.html">DelayedCompareVectorHelper</a>&lt; DelayedCompareOp::LESS_THAN_OR_EQUAL, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">margin_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a83999d2ac877c5b15f6fd5a0f33a894a">make_DelayedLessThanOrEqualVectorHelper</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">v</a>)</td></tr>
<tr class="separator:a83999d2ac877c5b15f6fd5a0f33a894a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c84e8b757cf5ba6479a6ea3e6e530e3" id="r_a6c84e8b757cf5ba6479a6ea3e6e530e3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> margin_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>  = std::vector&lt;Value_&gt;&gt; </td></tr>
<tr class="memitem:a6c84e8b757cf5ba6479a6ea3e6e530e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedCompareVectorHelper.html">DelayedCompareVectorHelper</a>&lt; DelayedCompareOp::NOT_EQUAL, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">margin_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a6c84e8b757cf5ba6479a6ea3e6e530e3">make_DelayedNotEqualVectorHelper</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">v</a>)</td></tr>
<tr class="separator:a6c84e8b757cf5ba6479a6ea3e6e530e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b072944c766d85dc4ce4dc734e0b75" id="r_a07b072944c766d85dc4ce4dc734e0b75"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">class</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Operation_</a> &gt; </td></tr>
<tr class="memitem:a07b072944c766d85dc4ce4dc734e0b75"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a07b072944c766d85dc4ce4dc734e0b75">make_DelayedUnaryIsometricOp</a> (std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">p</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Operation_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">op</a>)</td></tr>
<tr class="separator:a07b072944c766d85dc4ce4dc734e0b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2620b6e2812c6952ed562d359229a99" id="r_af2620b6e2812c6952ed562d359229a99"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> margin_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; </td></tr>
<tr class="memitem:af2620b6e2812c6952ed562d359229a99"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#af2620b6e2812c6952ed562d359229a99">make_DelayedBind</a> (std::vector&lt; std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; &gt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">ps</a>)</td></tr>
<tr class="separator:af2620b6e2812c6952ed562d359229a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c8b88eeaa5fcbb1e5d47d020eb98ea" id="r_ab4c8b88eeaa5fcbb1e5d47d020eb98ea"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">ValueOut_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">IndexOut_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">ValueIn_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">IndexIn_</a> &gt; </td></tr>
<tr class="memitem:ab4c8b88eeaa5fcbb1e5d47d020eb98ea"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">ValueOut_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">IndexOut_</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ab4c8b88eeaa5fcbb1e5d47d020eb98ea">make_DelayedCast</a> (std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">ValueIn_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">IndexIn_</a> &gt; &gt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">p</a>)</td></tr>
<tr class="separator:ab4c8b88eeaa5fcbb1e5d47d020eb98ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa35d8e9fe286967f327ec0eb6bd5005" id="r_afa35d8e9fe286967f327ec0eb6bd5005"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; </td></tr>
<tr class="memitem:afa35d8e9fe286967f327ec0eb6bd5005"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#afa35d8e9fe286967f327ec0eb6bd5005">make_DelayedTranspose</a> (std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">p</a>)</td></tr>
<tr class="separator:afa35d8e9fe286967f327ec0eb6bd5005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17e92414b0bff60f7b7a6431ac8a330" id="r_ab17e92414b0bff60f7b7a6431ac8a330"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> ROW, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">class</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">U</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">class</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">V</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">class</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">W</a> &gt; </td></tr>
<tr class="memitem:ab17e92414b0bff60f7b7a6431ac8a330"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">size_t</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ab17e92414b0bff60f7b7a6431ac8a330">compress_sparse_triplets</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">size_t</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">nr</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">size_t</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">nc</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">U</a> &amp;values, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">V</a> &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">rows</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">W</a> &amp;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">cols</a>)</td></tr>
<tr class="separator:ab17e92414b0bff60f7b7a6431ac8a330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1aee6313d02036d2f56703f372e1df6" id="r_ad1aee6313d02036d2f56703f372e1df6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> row_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputIndex_</a> &gt; </td></tr>
<tr class="memitem:ad1aee6313d02036d2f56703f372e1df6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1CompressedSparseContents.html">CompressedSparseContents</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ad1aee6313d02036d2f56703f372e1df6">retrieve_compressed_sparse_contents</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputIndex_</a> &gt; *<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">incoming</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">two_pass</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">threads</a>=1)</td></tr>
<tr class="separator:ad1aee6313d02036d2f56703f372e1df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48dab0e55d3b852afcfd9e93835190df" id="r_a48dab0e55d3b852afcfd9e93835190df"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> row_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">StoredValue_</a>  = Value_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">StoredIndex_</a>  = Index_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputIndex_</a> &gt; </td></tr>
<tr class="memitem:a48dab0e55d3b852afcfd9e93835190df"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a48dab0e55d3b852afcfd9e93835190df">convert_to_compressed_sparse</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputIndex_</a> &gt; *<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">incoming</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">two_pass</a>=<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">false</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">threads</a>=1)</td></tr>
<tr class="separator:a48dab0e55d3b852afcfd9e93835190df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf7ca799fac9cff0c16a77bf98e32ff3" id="r_acf7ca799fac9cff0c16a77bf98e32ff3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">StoredValue_</a>  = Value_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">StoredIndex_</a>  = Index_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputIndex_</a> &gt; </td></tr>
<tr class="memitem:acf7ca799fac9cff0c16a77bf98e32ff3"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#acf7ca799fac9cff0c16a77bf98e32ff3">convert_to_compressed_sparse</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputIndex_</a> &gt; *<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">incoming</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">order</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">two_pass</a>=<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">false</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">threads</a>=1)</td></tr>
<tr class="separator:acf7ca799fac9cff0c16a77bf98e32ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012194aba94c37703f15555247e02155" id="r_a012194aba94c37703f15555247e02155"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> row_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputIndex_</a> &gt; </td></tr>
<tr class="memitem:a012194aba94c37703f15555247e02155"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1FragmentedSparseContents.html">FragmentedSparseContents</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a012194aba94c37703f15555247e02155">retrieve_fragmented_sparse_contents</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputIndex_</a> &gt; *<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">incoming</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">threads</a>=1)</td></tr>
<tr class="separator:a012194aba94c37703f15555247e02155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953ad06ecc9a36c8d2c1f3febe84a787" id="r_a953ad06ecc9a36c8d2c1f3febe84a787"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> row_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">StoredValue_</a>  = Value_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">StoredIndex_</a>  = Index_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputIndex_</a> &gt; </td></tr>
<tr class="memitem:a953ad06ecc9a36c8d2c1f3febe84a787"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a953ad06ecc9a36c8d2c1f3febe84a787">convert_to_fragmented_sparse</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputIndex_</a> &gt; *<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">incoming</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">threads</a>=1)</td></tr>
<tr class="separator:a953ad06ecc9a36c8d2c1f3febe84a787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46babb9d985cffcb54bcba89553a811" id="r_ae46babb9d985cffcb54bcba89553a811"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">StoredValue_</a>  = Value_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">StoredIndex_</a>  = Index_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputIndex_</a> &gt; </td></tr>
<tr class="memitem:ae46babb9d985cffcb54bcba89553a811"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ae46babb9d985cffcb54bcba89553a811">convert_to_fragmented_sparse</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputIndex_</a> &gt; *<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">incoming</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">order</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">threads</a>=1)</td></tr>
<tr class="separator:ae46babb9d985cffcb54bcba89553a811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f4aafc0a1fbdc0c31bc122d24122a63" id="r_a8f4aafc0a1fbdc0c31bc122d24122a63"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> margin_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; </td></tr>
<tr class="memitem:a8f4aafc0a1fbdc0c31bc122d24122a63"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a8f4aafc0a1fbdc0c31bc122d24122a63">make_DelayedSubsetBlock</a> (std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">p</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">f</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">l</a>)</td></tr>
<tr class="separator:a8f4aafc0a1fbdc0c31bc122d24122a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc63177b00e6e3e2fa47754b8d87704" id="r_abfc63177b00e6e3e2fa47754b8d87704"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> margin_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">class</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">IndexStorage_</a> &gt; </td></tr>
<tr class="memitem:abfc63177b00e6e3e2fa47754b8d87704"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#abfc63177b00e6e3e2fa47754b8d87704">make_DelayedSubset</a> (std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">p</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">IndexStorage_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">idx</a>)</td></tr>
<tr class="separator:abfc63177b00e6e3e2fa47754b8d87704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05590455e558621c8ffc1b98c4fd454" id="r_af05590455e558621c8ffc1b98c4fd454"><td class="memTemplParams" colspan="2">template&lt;bool sparse_, typename Value_ , typename Index_ , typename ... Args_&gt; </td></tr>
<tr class="memitem:af05590455e558621c8ffc1b98c4fd454"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">consecutive_extractor</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *mat, bool row, Index_ iter_start, Index_ iter_length, Args_ &amp;&amp;... args)</td></tr>
<tr class="separator:af05590455e558621c8ffc1b98c4fd454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab52a806e3f13a68741a9e1f77dccab14" id="r_ab52a806e3f13a68741a9e1f77dccab14"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Size_</a> &gt; </td></tr>
<tr class="memitem:ab52a806e3f13a68741a9e1f77dccab14"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ab52a806e3f13a68741a9e1f77dccab14">copy_n</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> *<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">input</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Size_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">n</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> *<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">output</a>)</td></tr>
<tr class="separator:ab52a806e3f13a68741a9e1f77dccab14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e845574f229ff8308121456fac3d47" id="r_ae5e845574f229ff8308121456fac3d47"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> sparse_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> oracle_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> ... Args_&gt; </td></tr>
<tr class="memitem:ae5e845574f229ff8308121456fac3d47"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#ae5e845574f229ff8308121456fac3d47">new_extractor</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; *ptr, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">row</a>, <a class="el" href="namespacetatami.html#aab9d426a238a93d02635b4172c725808">MaybeOracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">oracle_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; oracle, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Args_</a> &amp;&amp;... <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">args</a>)</td></tr>
<tr class="separator:ae5e845574f229ff8308121456fac3d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e252422f9959a123ba390a941ae76f" id="r_a41e252422f9959a123ba390a941ae76f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> parallel_ = true, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">class</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Function_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; </td></tr>
<tr class="memitem:a41e252422f9959a123ba390a941ae76f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a41e252422f9959a123ba390a941ae76f">parallelize</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Function_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">fun</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">tasks</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">size_t</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">threads</a>)</td></tr>
<tr class="separator:a41e252422f9959a123ba390a941ae76f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01c93a616eb99f6a17861a8b19f7ee0" id="r_af01c93a616eb99f6a17861a8b19f7ee0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">class</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Function_</a> &gt; </td></tr>
<tr class="memitem:af01c93a616eb99f6a17861a8b19f7ee0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#af01c93a616eb99f6a17861a8b19f7ee0">process_consecutive_indices</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> *indices, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> length, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Function_</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">fun</a>)</td></tr>
<tr class="separator:af01c93a616eb99f6a17861a8b19f7ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7518f5e8e09a6f6d7d3955b8ea286689" id="r_a7518f5e8e09a6f6d7d3955b8ea286689"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">T</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">IDX</a> &gt; </td></tr>
<tr class="memitem:a7518f5e8e09a6f6d7d3955b8ea286689"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">T</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">IDX</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetatami.html#a7518f5e8e09a6f6d7d3955b8ea286689">wrap_shared_ptr</a> (<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">T</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">IDX</a> &gt; *ptr)</td></tr>
<tr class="separator:a7518f5e8e09a6f6d7d3955b8ea286689"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Flexible representations for matrix data. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a4e0374ed6401df3d6ae262ad379a4743" name="a4e0374ed6401df3d6ae262ad379a4743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e0374ed6401df3d6ae262ad379a4743">&#9670;&#160;</a></span>DenseExtractor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> oracle_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">using</a> <a class="el" href="namespacetatami.html#a4e0374ed6401df3d6ae262ad379a4743">tatami::DenseExtractor</a> = <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typedef</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> std::conditional&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">oracle_</a>, <a class="el" href="structtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&gt;, <a class="el" href="structtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&gt; &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">oracle_</td><td>Whether to use an oracle-aware interface. </td></tr>
    <tr><td class="paramname">Value_</td><td>Data value type, should be numeric. </td></tr>
    <tr><td class="paramname">Index_</td><td>Row/column index type, should be integer.</td></tr>
  </table>
  </dd>
</dl>
<p>Type alias that switches between <code><a class="el" href="structtatami_1_1OracularDenseExtractor.html" title="Extract in dense form with an oracle.">OracularDenseExtractor</a></code> and <code><a class="el" href="structtatami_1_1MyopicDenseExtractor.html" title="Extract a dimension element in dense form without an oracle.">MyopicDenseExtractor</a></code> depending on <code>oracle_</code>. Intended for templated class definitions, where setting <code>oracle_</code> can define subclasses for both interfaces. </p>

</div>
</div>
<a id="a9a542a16a6a2c2c1efdc7b6e9eae9040" name="a9a542a16a6a2c2c1efdc7b6e9eae9040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a542a16a6a2c2c1efdc7b6e9eae9040">&#9670;&#160;</a></span>SparseExtractor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> oracle_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">using</a> <a class="el" href="namespacetatami.html#a9a542a16a6a2c2c1efdc7b6e9eae9040">tatami::SparseExtractor</a> = <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typedef</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> std::conditional&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">oracle_</a>, <a class="el" href="structtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&gt;, <a class="el" href="structtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&gt; &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">oracle_</td><td>Whether to use an oracle-aware interface. </td></tr>
    <tr><td class="paramname">Value_</td><td>Data value type, should be numeric. </td></tr>
    <tr><td class="paramname">Index_</td><td>Row/column index type, should be integer.</td></tr>
  </table>
  </dd>
</dl>
<p>Type alias that switches between <code><a class="el" href="structtatami_1_1OracularSparseExtractor.html" title="Extract in sparse form with an oracle.">OracularSparseExtractor</a></code> and <code><a class="el" href="structtatami_1_1MyopicSparseExtractor.html" title="Extract in sparse form without an oracle.">MyopicSparseExtractor</a></code> depending on <code>oracle_</code>. Intended for templated class definitions, where setting <code>oracle_</code> can define subclasses for both interfaces. </p>

</div>
</div>
<a id="abbb0bdf0b79fe19e504b49b43984f634" name="abbb0bdf0b79fe19e504b49b43984f634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbb0bdf0b79fe19e504b49b43984f634">&#9670;&#160;</a></span>VectorPtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">using</a> <a class="el" href="namespacetatami.html#abbb0bdf0b79fe19e504b49b43984f634">tatami::VectorPtr</a> = <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typedef</a> std::shared_ptr&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> std::vector&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>Row/column index type, should be integer.</td></tr>
  </table>
  </dd>
</dl>
<p>Pointer to a vector, typically containing unique and sorted indices. We use a shared pointer so that we can cheaply re-use the same sequence of indices for multiple <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> objects. </p>

</div>
</div>
<a id="a35c670894994f1d620abb55953f98441" name="a35c670894994f1d620abb55953f98441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35c670894994f1d620abb55953f98441">&#9670;&#160;</a></span>NumericMatrix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">using</a> <a class="el" href="namespacetatami.html#a35c670894994f1d620abb55953f98441">tatami::NumericMatrix</a> = <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typedef</a> <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">double</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenient shorthand for the most common use case of double-precision matrices. </p>

</div>
</div>
<a id="ac47a769e00660eb7e9b5fcd543bcf2d3" name="ac47a769e00660eb7e9b5fcd543bcf2d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac47a769e00660eb7e9b5fcd543bcf2d3">&#9670;&#160;</a></span>DenseColumnMatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">class</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Storage_</a>  = std::vector&lt;Value_&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">using</a> <a class="el" href="namespacetatami.html#ac47a769e00660eb7e9b5fcd543bcf2d3">tatami::DenseColumnMatrix</a> = <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typedef</a> <a class="el" href="classtatami_1_1DenseMatrix.html">DenseMatrix</a>&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">false</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Storage_</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Column-major matrix. See <code><a class="el" href="classtatami_1_1DenseMatrix.html" title="Dense matrix representation.">tatami::DenseMatrix</a></code> for details on the template parameters. </p>

</div>
</div>
<a id="a51122d20490b377cd3f4609cc044f314" name="a51122d20490b377cd3f4609cc044f314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51122d20490b377cd3f4609cc044f314">&#9670;&#160;</a></span>DenseRowMatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">class</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Storage_</a>  = std::vector&lt;Value_&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">using</a> <a class="el" href="namespacetatami.html#a51122d20490b377cd3f4609cc044f314">tatami::DenseRowMatrix</a> = <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typedef</a> <a class="el" href="classtatami_1_1DenseMatrix.html">DenseMatrix</a>&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">true</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Storage_</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Row-major matrix. See <code><a class="el" href="classtatami_1_1DenseMatrix.html" title="Dense matrix representation.">tatami::DenseMatrix</a></code> for details on the template parameters. </p>

</div>
</div>
<a id="a18cee3a5d9734f0092b03d023cfe4b6a" name="a18cee3a5d9734f0092b03d023cfe4b6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18cee3a5d9734f0092b03d023cfe4b6a">&#9670;&#160;</a></span>CompressedSparseColumnMatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">class</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">ValueStorage_</a>  = std::vector&lt;Value_&gt;, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">class</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">IndexStorage_</a>  = std::vector&lt;Index_&gt;, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">class</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">PointerStorage_</a>  = std::vector&lt;size_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">using</a> <a class="el" href="namespacetatami.html#a18cee3a5d9734f0092b03d023cfe4b6a">tatami::CompressedSparseColumnMatrix</a> = <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typedef</a> <a class="el" href="classtatami_1_1CompressedSparseMatrix.html">CompressedSparseMatrix</a>&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">false</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">ValueStorage_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">IndexStorage_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">PointerStorage_</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compressed sparse column matrix. See <code><a class="el" href="classtatami_1_1CompressedSparseMatrix.html" title="Compressed sparse matrix representation.">tatami::CompressedSparseMatrix</a></code> for details on the template parameters. </p>

</div>
</div>
<a id="a0111adeeb583aeb7e24e9e1e25be4aa0" name="a0111adeeb583aeb7e24e9e1e25be4aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0111adeeb583aeb7e24e9e1e25be4aa0">&#9670;&#160;</a></span>CompressedSparseRowMatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">class</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">ValueStorage_</a>  = std::vector&lt;Value_&gt;, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">class</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">IndexStorage_</a>  = std::vector&lt;Index_&gt;, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">class</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">PointerStorage_</a>  = std::vector&lt;size_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">using</a> <a class="el" href="namespacetatami.html#a0111adeeb583aeb7e24e9e1e25be4aa0">tatami::CompressedSparseRowMatrix</a> = <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typedef</a> <a class="el" href="classtatami_1_1CompressedSparseMatrix.html">CompressedSparseMatrix</a>&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">true</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">ValueStorage_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">IndexStorage_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">PointerStorage_</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compressed sparse row matrix. See <code><a class="el" href="classtatami_1_1CompressedSparseMatrix.html" title="Compressed sparse matrix representation.">tatami::CompressedSparseMatrix</a></code> for details on the template parameters. </p>

</div>
</div>
<a id="a6b9735bdc6e0a2856cd4747efbbf9f3c" name="a6b9735bdc6e0a2856cd4747efbbf9f3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b9735bdc6e0a2856cd4747efbbf9f3c">&#9670;&#160;</a></span>FragmentedSparseColumnMatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">class</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">ValueVectorStorage_</a>  = std::vector&lt;std::vector&lt;Value_&gt; &gt;, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">class</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">IndexVectorStorage_</a>  = std::vector&lt;std::vector&lt;Index_&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">using</a> <a class="el" href="namespacetatami.html#a6b9735bdc6e0a2856cd4747efbbf9f3c">tatami::FragmentedSparseColumnMatrix</a> = <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typedef</a> <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html">FragmentedSparseMatrix</a>&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">false</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">ValueVectorStorage_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">IndexVectorStorage_</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fragmented sparse column matrix. See <code><a class="el" href="classtatami_1_1FragmentedSparseMatrix.html" title="Fragmented sparse matrix representation.">tatami::FragmentedSparseMatrix</a></code> for details on the template parameters. </p>

</div>
</div>
<a id="a3d97fc9bd75052a79bb643d0fb5a0b98" name="a3d97fc9bd75052a79bb643d0fb5a0b98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d97fc9bd75052a79bb643d0fb5a0b98">&#9670;&#160;</a></span>FragmentedSparseRowMatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">class</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">ValueVectorStorage_</a>  = std::vector&lt;std::vector&lt;Value_&gt; &gt;, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">class</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">IndexVectorStorage_</a>  = std::vector&lt;std::vector&lt;Index_&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">using</a> <a class="el" href="namespacetatami.html#a3d97fc9bd75052a79bb643d0fb5a0b98">tatami::FragmentedSparseRowMatrix</a> = <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typedef</a> <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html">FragmentedSparseMatrix</a>&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">true</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">ValueVectorStorage_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">IndexVectorStorage_</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fragmented sparse row matrix. See <code><a class="el" href="classtatami_1_1FragmentedSparseMatrix.html" title="Fragmented sparse matrix representation.">tatami::FragmentedSparseMatrix</a></code> for details on the template parameters. </p>

</div>
</div>
<a id="a58a028d23a7be58854b2e60dfae1b04b" name="a58a028d23a7be58854b2e60dfae1b04b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58a028d23a7be58854b2e60dfae1b04b">&#9670;&#160;</a></span>ElementType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">class</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Array_</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">using</a> <a class="el" href="namespacetatami.html#a58a028d23a7be58854b2e60dfae1b04b">tatami::ElementType</a> = <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typedef</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> std::remove_cv&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> std::remove_reference&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">decltype</a>(std::declval&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Array_</a>&gt;()[0])&gt;::type&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Array_</td><td>Some array of values that are accessed with <code>[</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>Extract the type of array elements, after stripping away references and <code>const</code>-ness. </p>

</div>
</div>
<a id="aab9d426a238a93d02635b4172c725808" name="aab9d426a238a93d02635b4172c725808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab9d426a238a93d02635b4172c725808">&#9670;&#160;</a></span>MaybeOracle</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> oracle_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">using</a> <a class="el" href="namespacetatami.html#aab9d426a238a93d02635b4172c725808">tatami::MaybeOracle</a> = <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typedef</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> std::conditional&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">oracle_</a>, std::shared_ptr&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="structtatami_1_1Oracle.html">Oracle</a>&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&gt; &gt;, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">oracle_</td><td>Whether an oracle should be supplied. </td></tr>
    <tr><td class="paramname">Index_</td><td>Row/column index type, should be integer.</td></tr>
  </table>
  </dd>
</dl>
<p>Maybe an <code><a class="el" href="structtatami_1_1Oracle.html" title="Predict future access requests.">Oracle</a></code>, maybe a placeholder boolean, depending on <code>oracle_</code>. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a0a2ecaf58e2b69bb4a808e814aeb16a1" name="a0a2ecaf58e2b69bb4a808e814aeb16a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a2ecaf58e2b69bb4a808e814aeb16a1">&#9670;&#160;</a></span>DimensionSelectionType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">enum</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">class</a> <a class="el" href="namespacetatami.html#a0a2ecaf58e2b69bb4a808e814aeb16a1">tatami::DimensionSelectionType</a> : <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">char</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Type of selection along a dimension, typically the extraction dimension:</p>
<ul>
<li><code>FULL</code>: selects the full extent of the dimension, i.e., all elements in the dimension.</li>
<li><code>BLOCK</code>: selects a contiguous block of elements in the dimension.</li>
<li><code>INDEX</code>: selects a sorted and unique array of indices of dimension elements. </li>
</ul>

</div>
</div>
<a id="aab44a37b3762de0c5b1ffbfceb25fa0f" name="aab44a37b3762de0c5b1ffbfceb25fa0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab44a37b3762de0c5b1ffbfceb25fa0f">&#9670;&#160;</a></span>DelayedArithOp</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">enum</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">class</a> <a class="el" href="namespacetatami.html#aab44a37b3762de0c5b1ffbfceb25fa0f">tatami::DelayedArithOp</a> : <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">char</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Type of the delayed arithmetic operation. </p>

</div>
</div>
<a id="a2104862d4068933ea4cc805c92f82d07" name="a2104862d4068933ea4cc805c92f82d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2104862d4068933ea4cc805c92f82d07">&#9670;&#160;</a></span>DelayedBooleanOp</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">enum</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">class</a> <a class="el" href="namespacetatami.html#a2104862d4068933ea4cc805c92f82d07">tatami::DelayedBooleanOp</a> : <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">char</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Type of the delayed boolean operation. </p>

</div>
</div>
<a id="ac4fc175a57ace709941b5ca7ddb19708" name="ac4fc175a57ace709941b5ca7ddb19708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4fc175a57ace709941b5ca7ddb19708">&#9670;&#160;</a></span>DelayedCompareOp</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">enum</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">class</a> <a class="el" href="namespacetatami.html#ac4fc175a57ace709941b5ca7ddb19708">tatami::DelayedCompareOp</a> : <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">char</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Type of the delayed comparison operation. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aaa4de72fa0357087aa607876b2b99366" name="aaa4de72fa0357087aa607876b2b99366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa4de72fa0357087aa607876b2b99366">&#9670;&#160;</a></span>convert_to_dense() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">StoredValue_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputIndex_</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">void</a> tatami::convert_to_dense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputIndex_</a> &gt; *&#160;</td>
          <td class="paramname"><em>incoming</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">StoredValue_</a> *&#160;</td>
          <td class="paramname"><em>store</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a>&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">StoredValue_</td><td>Type of data values to be stored in the output. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of data values in the input. </td></tr>
    <tr><td class="paramname">InputIndex_</td><td>Integer type for the indices in the input.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">incoming</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">row</td><td>Whether to return a row-major matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">store</td><td>Pointer to an array of length equal to the product of the dimensions of <code>incoming</code>. On output, this is filled with values from <code>incoming</code> in row- or column-major format depending on <code>row</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">threads</td><td>Number of threads to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b6e4754f2e6c6451d16f88a01c87c14" name="a7b6e4754f2e6c6451d16f88a01c87c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b6e4754f2e6c6451d16f88a01c87c14">&#9670;&#160;</a></span>convert_to_dense() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">StoredValue_</a>  = Value_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputIndex_</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; tatami::convert_to_dense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputIndex_</a> &gt; *&#160;</td>
          <td class="paramname"><em>incoming</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a>&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">row</td><td>Whether to return a row-major matrix. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of data values in the output interface. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the indices in the output interface. </td></tr>
    <tr><td class="paramname">StoredValue_</td><td>Type of data values to be stored in the output. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of data values in the input. </td></tr>
    <tr><td class="paramname">InputIndex_</td><td>Integer type for the indices in the input.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">incoming</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a new <code><a class="el" href="classtatami_1_1DenseMatrix.html" title="Dense matrix representation.">tatami::DenseMatrix</a></code> with the same dimensions and type as the matrix referenced by <code>incoming</code>. If <code>row = true</code>, the matrix is row-major, otherwise it is column-major. </dd></dl>

</div>
</div>
<a id="aa74ad14ba410177396121d272371dffd" name="aa74ad14ba410177396121d272371dffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa74ad14ba410177396121d272371dffd">&#9670;&#160;</a></span>convert_to_dense() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">StoredValue_</a>  = Value_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputIndex_</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; tatami::convert_to_dense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputIndex_</a> &gt; *&#160;</td>
          <td class="paramname"><em>incoming</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a>&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This overload makes it easier to control the desired output order when it is not known at compile time.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of data values in the output interface. </td></tr>
    <tr><td class="paramname">Index</td><td>Integer type for the indices in the output interface. </td></tr>
    <tr><td class="paramname">StoredValue_</td><td>Type of data values to be stored in the output. </td></tr>
    <tr><td class="paramname">Matrix_</td><td>Input matrix class, most typically a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">incoming</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">order</td><td>Ordering of values in the output dense matrix - row-major (0) or column-major (1). If set to -1, the ordering is chosen based on <code><a class="el" href="classtatami_1_1Matrix.html#a69382d2a4e66cda1a9eb48dc25ab113a">tatami::Matrix::prefer_rows()</a></code>. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a new <code><a class="el" href="classtatami_1_1DenseMatrix.html" title="Dense matrix representation.">tatami::DenseMatrix</a></code> with the same dimensions and type as the matrix referenced by <code>incoming</code>. </dd></dl>

</div>
</div>
<a id="a07c1d1f96ea3a59d9f6106b17873d494" name="a07c1d1f96ea3a59d9f6106b17873d494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c1d1f96ea3a59d9f6106b17873d494">&#9670;&#160;</a></span>transpose() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Input_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Output_</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">void</a> tatami::transpose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Input_</a> *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">size_t</a>&#160;</td>
          <td class="paramname"><em>nrow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">size_t</a>&#160;</td>
          <td class="paramname"><em>ncol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">size_t</a>&#160;</td>
          <td class="paramname"><em>input_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Output_</a> *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">size_t</a>&#160;</td>
          <td class="paramname"><em>output_stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Input_</td><td>Input type. </td></tr>
    <tr><td class="paramname">Output_</td><td>Output type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Pointer to an array containing a row-major matrix with <code>nrow</code> rows and <code>ncol</code> columns. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nrow</td><td>Number of rows in the matrix stored at <code>input</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ncol</td><td>Number of columns in the matrix stored at <code>input</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">input_stride</td><td>Distance between corresponding entries on consecutive rows of the <code>input</code> matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Pointer to an array of length <code>nrow * ncol</code>. On output, this will hold the transpose of the matrix represented by <code>input</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">output_stride</td><td>Distance between corresponding entries on consecutive columns of the <code>output</code> matrix.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is intended for developers of <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> subclasses who need to do some transposition, e.g., for dense chunks during caching. The <code>*_stride</code> arguments allow <code>input</code> and <code>output</code> to refer to submatrices of larger arrays. </p>

</div>
</div>
<a id="a86be7b06c9d13b25f9ff04eed87430a7" name="a86be7b06c9d13b25f9ff04eed87430a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86be7b06c9d13b25f9ff04eed87430a7">&#9670;&#160;</a></span>transpose() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Input_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Output_</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">void</a> tatami::transpose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Input_</a> *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">size_t</a>&#160;</td>
          <td class="paramname"><em>nrow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">size_t</a>&#160;</td>
          <td class="paramname"><em>ncol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Output_</a> *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Input_</td><td>Input type. </td></tr>
    <tr><td class="paramname">Output_</td><td>Output type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Pointer to an array containing a row-major matrix with <code>nrow</code> rows and <code>ncol</code> columns. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nrow</td><td>Number of rows in the matrix stored at <code>input</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ncol</td><td>Number of columns in the matrix stored at <code>input</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Pointer to an array of length <code>nrow * ncol</code>. On output, this will hold the transpose of the matrix represented by <code>input</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is intended for developers of <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> subclasses who need to do some transposition, e.g., for dense chunks during caching. Users should instead construct a <code><a class="el" href="classtatami_1_1DelayedTranspose.html" title="Delayed transposition of a matrix.">DelayedTranspose</a></code> object to perform a memory-efficient delayed transposition, or use <code><a class="el" href="namespacetatami.html#aaa4de72fa0357087aa607876b2b99366">convert_to_dense()</a></code> to convert their dense data into the desired storage layout. </p>

</div>
</div>
<a id="a1d138b1e7f6a26f814c025363cc3db80" name="a1d138b1e7f6a26f814c025363cc3db80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d138b1e7f6a26f814c025363cc3db80">&#9670;&#160;</a></span>make_DelayedBinaryAddHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBinaryArithHelper.html">DelayedBinaryArithHelper</a>&lt; DelayedArithOp::ADD &gt; tatami::make_DelayedBinaryAddHelper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed binary addition. </dd></dl>

</div>
</div>
<a id="ac4c951d489cb0f2bb0e90f2cf4a25862" name="ac4c951d489cb0f2bb0e90f2cf4a25862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4c951d489cb0f2bb0e90f2cf4a25862">&#9670;&#160;</a></span>make_DelayedBinarySubtractHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBinaryArithHelper.html">DelayedBinaryArithHelper</a>&lt; DelayedArithOp::SUBTRACT &gt; tatami::make_DelayedBinarySubtractHelper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed binary subtraction. </dd></dl>

</div>
</div>
<a id="a2569c540083a24f92af8140358e1e9c4" name="a2569c540083a24f92af8140358e1e9c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2569c540083a24f92af8140358e1e9c4">&#9670;&#160;</a></span>make_DelayedBinaryMultiplyHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBinaryArithHelper.html">DelayedBinaryArithHelper</a>&lt; DelayedArithOp::MULTIPLY &gt; tatami::make_DelayedBinaryMultiplyHelper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed binary multiplication. </dd></dl>

</div>
</div>
<a id="aeb4cf766f850766b966f7121728a6af8" name="aeb4cf766f850766b966f7121728a6af8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb4cf766f850766b966f7121728a6af8">&#9670;&#160;</a></span>make_DelayedBinaryDivideHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBinaryArithHelper.html">DelayedBinaryArithHelper</a>&lt; DelayedArithOp::DIVIDE &gt; tatami::make_DelayedBinaryDivideHelper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed binary division. </dd></dl>

</div>
</div>
<a id="ab6c73c04e7b08130ed7b46d93c4dfd11" name="ab6c73c04e7b08130ed7b46d93c4dfd11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6c73c04e7b08130ed7b46d93c4dfd11">&#9670;&#160;</a></span>make_DelayedBinaryPowerHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBinaryArithHelper.html">DelayedBinaryArithHelper</a>&lt; DelayedArithOp::POWER &gt; tatami::make_DelayedBinaryPowerHelper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed binary power. </dd></dl>

</div>
</div>
<a id="a04293eb1e8eefb7024cc192d75ac093e" name="a04293eb1e8eefb7024cc192d75ac093e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04293eb1e8eefb7024cc192d75ac093e">&#9670;&#160;</a></span>make_DelayedBinaryModuloHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBinaryArithHelper.html">DelayedBinaryArithHelper</a>&lt; DelayedArithOp::MODULO &gt; tatami::make_DelayedBinaryModuloHelper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed binary modulo. </dd></dl>

</div>
</div>
<a id="aa8f54741424bef6a21225935a45e9d53" name="aa8f54741424bef6a21225935a45e9d53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8f54741424bef6a21225935a45e9d53">&#9670;&#160;</a></span>make_DelayedBinaryIntegerDivideHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBinaryArithHelper.html">DelayedBinaryArithHelper</a>&lt; DelayedArithOp::INTEGER_DIVIDE &gt; tatami::make_DelayedBinaryIntegerDivideHelper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed binary integer division. </dd></dl>

</div>
</div>
<a id="a1063aea86897ef76e17b1772320b8f7d" name="a1063aea86897ef76e17b1772320b8f7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1063aea86897ef76e17b1772320b8f7d">&#9670;&#160;</a></span>make_DelayedBinaryBooleanEqualHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBinaryBooleanHelper.html">DelayedBinaryBooleanHelper</a>&lt; DelayedBooleanOp::EQUAL &gt; tatami::make_DelayedBinaryBooleanEqualHelper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed binary boolean equivalence operation. </dd></dl>

</div>
</div>
<a id="a31625dbb50d420fe1b0da406f19ef33d" name="a31625dbb50d420fe1b0da406f19ef33d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31625dbb50d420fe1b0da406f19ef33d">&#9670;&#160;</a></span>make_DelayedBinaryBooleanAndHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBinaryBooleanHelper.html">DelayedBinaryBooleanHelper</a>&lt; DelayedBooleanOp::AND &gt; tatami::make_DelayedBinaryBooleanAndHelper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed binary AND comparison. </dd></dl>

</div>
</div>
<a id="a65bad100b39d9372fbeb23d16dae6588" name="a65bad100b39d9372fbeb23d16dae6588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65bad100b39d9372fbeb23d16dae6588">&#9670;&#160;</a></span>make_DelayedBinaryBooleanOrHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBinaryBooleanHelper.html">DelayedBinaryBooleanHelper</a>&lt; DelayedBooleanOp::OR &gt; tatami::make_DelayedBinaryBooleanOrHelper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed binary OR comparison. </dd></dl>

</div>
</div>
<a id="aeb091953ab0f55406935a52b7ecb7350" name="aeb091953ab0f55406935a52b7ecb7350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb091953ab0f55406935a52b7ecb7350">&#9670;&#160;</a></span>make_DelayedBinaryBooleanXorHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBinaryBooleanHelper.html">DelayedBinaryBooleanHelper</a>&lt; DelayedBooleanOp::XOR &gt; tatami::make_DelayedBinaryBooleanXorHelper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed binary XOR comparison. </dd></dl>

</div>
</div>
<a id="ac3599db8f6d19fc9172da45a3b6244fc" name="ac3599db8f6d19fc9172da45a3b6244fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3599db8f6d19fc9172da45a3b6244fc">&#9670;&#160;</a></span>make_DelayedBinaryEqualHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBinaryCompareHelper.html">DelayedBinaryCompareHelper</a>&lt; DelayedCompareOp::EQUAL &gt; tatami::make_DelayedBinaryEqualHelper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed binary equality comparison. </dd></dl>

</div>
</div>
<a id="abe4fb79c5a2cddab2f5c9cf0bd9fe3d0" name="abe4fb79c5a2cddab2f5c9cf0bd9fe3d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe4fb79c5a2cddab2f5c9cf0bd9fe3d0">&#9670;&#160;</a></span>make_DelayedBinaryGreaterThanHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBinaryCompareHelper.html">DelayedBinaryCompareHelper</a>&lt; DelayedCompareOp::GREATER_THAN &gt; tatami::make_DelayedBinaryGreaterThanHelper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed binary greater-than comparison. </dd></dl>

</div>
</div>
<a id="ae6a24f5bf2c2c61382aef43f2c8d3362" name="ae6a24f5bf2c2c61382aef43f2c8d3362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a24f5bf2c2c61382aef43f2c8d3362">&#9670;&#160;</a></span>make_DelayedBinaryLessThanHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBinaryCompareHelper.html">DelayedBinaryCompareHelper</a>&lt; DelayedCompareOp::LESS_THAN &gt; tatami::make_DelayedBinaryLessThanHelper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed binary less-than comparison. </dd></dl>

</div>
</div>
<a id="ad31cd299427d73538dc00dcbffa9cd2b" name="ad31cd299427d73538dc00dcbffa9cd2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad31cd299427d73538dc00dcbffa9cd2b">&#9670;&#160;</a></span>make_DelayedBinaryGreaterThanOrEqualHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBinaryCompareHelper.html">DelayedBinaryCompareHelper</a>&lt; DelayedCompareOp::GREATER_THAN_OR_EQUAL &gt; tatami::make_DelayedBinaryGreaterThanOrEqualHelper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed binary greater-than-or-equal comparison. </dd></dl>

</div>
</div>
<a id="a38c7cc26409e5c995b7264164b148f4c" name="a38c7cc26409e5c995b7264164b148f4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38c7cc26409e5c995b7264164b148f4c">&#9670;&#160;</a></span>make_DelayedBinaryLessThanOrEqualHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBinaryCompareHelper.html">DelayedBinaryCompareHelper</a>&lt; DelayedCompareOp::LESS_THAN_OR_EQUAL &gt; tatami::make_DelayedBinaryLessThanOrEqualHelper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed binary less-than-or-equal comparison. </dd></dl>

</div>
</div>
<a id="a3073c4e33dcf89416af292399ba55c29" name="a3073c4e33dcf89416af292399ba55c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3073c4e33dcf89416af292399ba55c29">&#9670;&#160;</a></span>make_DelayedBinaryNotEqualHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBinaryCompareHelper.html">DelayedBinaryCompareHelper</a>&lt; DelayedCompareOp::NOT_EQUAL &gt; tatami::make_DelayedBinaryNotEqualHelper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed binary non-equality comparison to a scalar. </dd></dl>

</div>
</div>
<a id="af39c0767d23c6bdc5f4267f062ef2e17" name="af39c0767d23c6bdc5f4267f062ef2e17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af39c0767d23c6bdc5f4267f062ef2e17">&#9670;&#160;</a></span>make_DelayedBinaryIsometricOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">class</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Operation_</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; tatami::make_DelayedBinaryIsometricOp </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Operation_</a>&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <code>make_*</code> helper function to enable partial template deduction of supplied types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of index value. </td></tr>
    <tr><td class="paramname">Operation_</td><td>Helper class defining the operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>Pointer to a (possibly <code>const</code>) <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code>. </td></tr>
    <tr><td class="paramname">right</td><td>Pointer to a (possibly <code>const</code>) <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code>. </td></tr>
    <tr><td class="paramname">op</td><td>Instance of the operation helper class.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Instance of a <code><a class="el" href="classtatami_1_1DelayedBinaryIsometricOp.html" title="Delayed isometric operations on two matrices.">DelayedBinaryIsometricOp</a></code> clas. </dd></dl>

</div>
</div>
<a id="a33b2b9798f2a43b62821131ba3a3f6bd" name="a33b2b9798f2a43b62821131ba3a3f6bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33b2b9798f2a43b62821131ba3a3f6bd">&#9670;&#160;</a></span>make_DelayedAddScalarHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a>  = Value_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedArithScalarHelper.html">DelayedArithScalarHelper</a>&lt; DelayedArithOp::ADD, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">true</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a> &gt; tatami::make_DelayedAddScalarHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of the data value. </td></tr>
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Scalar value to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed scalar addition. </dd></dl>

</div>
</div>
<a id="a9bdfe26c0f1426b611e91ee7569045de" name="a9bdfe26c0f1426b611e91ee7569045de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bdfe26c0f1426b611e91ee7569045de">&#9670;&#160;</a></span>make_DelayedSubtractScalarHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> right_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a>  = Value_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedArithScalarHelper.html">DelayedArithScalarHelper</a>&lt; DelayedArithOp::SUBTRACT, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">right_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a> &gt; tatami::make_DelayedSubtractScalarHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">right_</td><td>Whether the scalar should be on the right hand side of the subtraction. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the data value. </td></tr>
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Scalar value to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed scalar subtraction. </dd></dl>

</div>
</div>
<a id="aa653b51960498cc467ea69c18ea0c097" name="aa653b51960498cc467ea69c18ea0c097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa653b51960498cc467ea69c18ea0c097">&#9670;&#160;</a></span>make_DelayedMultiplyScalarHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a>  = Value_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedArithScalarHelper.html">DelayedArithScalarHelper</a>&lt; DelayedArithOp::MULTIPLY, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">true</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a> &gt; tatami::make_DelayedMultiplyScalarHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of the data value. </td></tr>
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Scalar value to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed scalar multiplication. </dd></dl>

</div>
</div>
<a id="a60076096ee4296c0e187a226be5ca4b5" name="a60076096ee4296c0e187a226be5ca4b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60076096ee4296c0e187a226be5ca4b5">&#9670;&#160;</a></span>make_DelayedDivideScalarHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> right_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a>  = Value_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedArithScalarHelper.html">DelayedArithScalarHelper</a>&lt; DelayedArithOp::DIVIDE, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">right_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a> &gt; tatami::make_DelayedDivideScalarHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">right_</td><td>Whether the scalar should be on the right hand side of the division. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the data value. </td></tr>
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Scalar value to be divided. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed scalar division. </dd></dl>

</div>
</div>
<a id="a8c478145f87c37a9fe6d4e8490fbf05c" name="a8c478145f87c37a9fe6d4e8490fbf05c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c478145f87c37a9fe6d4e8490fbf05c">&#9670;&#160;</a></span>make_DelayedPowerScalarHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> right_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a>  = Value_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedArithScalarHelper.html">DelayedArithScalarHelper</a>&lt; DelayedArithOp::POWER, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">right_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a> &gt; tatami::make_DelayedPowerScalarHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">right_</td><td>Whether the scalar should be on the right hand side of the power transformation. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the data value. </td></tr>
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Scalar value to be power transformed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed scalar power transformation. </dd></dl>

</div>
</div>
<a id="a5504f584d6db28c05d78f1917c40810d" name="a5504f584d6db28c05d78f1917c40810d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5504f584d6db28c05d78f1917c40810d">&#9670;&#160;</a></span>make_DelayedModuloScalarHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> right_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a>  = Value_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedArithScalarHelper.html">DelayedArithScalarHelper</a>&lt; DelayedArithOp::MODULO, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">right_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a> &gt; tatami::make_DelayedModuloScalarHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">right_</td><td>Whether the scalar should be on the right hand side of the modulus. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the data value. </td></tr>
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Scalar value to be modulo transformed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed scalar modulus. </dd></dl>

</div>
</div>
<a id="a5ec92ba88a0f5e9d7bf52021ed28e859" name="a5ec92ba88a0f5e9d7bf52021ed28e859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec92ba88a0f5e9d7bf52021ed28e859">&#9670;&#160;</a></span>make_DelayedIntegerDivideScalarHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> right_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a>  = Value_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedArithScalarHelper.html">DelayedArithScalarHelper</a>&lt; DelayedArithOp::INTEGER_DIVIDE, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">right_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a> &gt; tatami::make_DelayedIntegerDivideScalarHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">right_</td><td>Whether the scalar should be on the right hand side of the integer division. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the data value. </td></tr>
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Scalar value to be integer divided. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed scalar integer division. </dd></dl>

</div>
</div>
<a id="a628c631be4424b37c1c1e68e28c5e982" name="a628c631be4424b37c1c1e68e28c5e982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a628c631be4424b37c1c1e68e28c5e982">&#9670;&#160;</a></span>make_DelayedAddVectorHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> margin_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>  = std::vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedArithVectorHelper.html">DelayedArithVectorHelper</a>&lt; DelayedArithOp::ADD, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">true</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">margin_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> &gt; tatami::make_DelayedAddVectorHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">margin_</td><td><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a> dimension along which the addition is to occur, see <code><a class="el" href="structtatami_1_1DelayedArithVectorHelper.html" title="Delayed vector arithmetic.">DelayedArithVectorHelper</a></code>. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the data value. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector to be added to the rows/columns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed vector addition. </dd></dl>

</div>
</div>
<a id="a800b92854282015d96308fb283aeb508" name="a800b92854282015d96308fb283aeb508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a800b92854282015d96308fb283aeb508">&#9670;&#160;</a></span>make_DelayedSubtractVectorHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> right_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> margin_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>  = std::vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedArithVectorHelper.html">DelayedArithVectorHelper</a>&lt; DelayedArithOp::SUBTRACT, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">right_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">margin_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> &gt; tatami::make_DelayedSubtractVectorHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">right_</td><td>Whether the scalar should be on the right hand side of the subtraction. </td></tr>
    <tr><td class="paramname">margin_</td><td><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a> dimension along which the subtraction is to occur, see <code><a class="el" href="structtatami_1_1DelayedArithVectorHelper.html" title="Delayed vector arithmetic.">DelayedArithVectorHelper</a></code>. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the data value. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector to subtract from (or be subtracted by) the rows/columns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed vector subtraction. </dd></dl>

</div>
</div>
<a id="ab929acdeb634187cd08d1100bbbf1b29" name="ab929acdeb634187cd08d1100bbbf1b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab929acdeb634187cd08d1100bbbf1b29">&#9670;&#160;</a></span>make_DelayedMultiplyVectorHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> margin_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>  = std::vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedArithVectorHelper.html">DelayedArithVectorHelper</a>&lt; DelayedArithOp::MULTIPLY, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">true</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">margin_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> &gt; tatami::make_DelayedMultiplyVectorHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">margin_</td><td><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a> dimension along which the multiplication is to occur, see <code><a class="el" href="structtatami_1_1DelayedArithVectorHelper.html" title="Delayed vector arithmetic.">DelayedArithVectorHelper</a></code>. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the data value. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector to multiply the rows/columns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed vector multiplication. </dd></dl>

</div>
</div>
<a id="a1a4629f17aa4f3a4be06f3479bb6f68f" name="a1a4629f17aa4f3a4be06f3479bb6f68f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a4629f17aa4f3a4be06f3479bb6f68f">&#9670;&#160;</a></span>make_DelayedDivideVectorHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> right_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> margin_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>  = std::vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedArithVectorHelper.html">DelayedArithVectorHelper</a>&lt; DelayedArithOp::DIVIDE, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">right_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">margin_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> &gt; tatami::make_DelayedDivideVectorHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">right_</td><td>Whether the scalar should be on the right hand side of the division. </td></tr>
    <tr><td class="paramname">margin_</td><td><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a> dimension along which the division is to occur, see <code><a class="el" href="structtatami_1_1DelayedArithVectorHelper.html" title="Delayed vector arithmetic.">DelayedArithVectorHelper</a></code>. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the data value. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector to divide (or be divided by) the rows/columns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed vector division. </dd></dl>

</div>
</div>
<a id="aafe489bd754c040491ebc753a4e5656e" name="aafe489bd754c040491ebc753a4e5656e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafe489bd754c040491ebc753a4e5656e">&#9670;&#160;</a></span>make_DelayedPowerVectorHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> right_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> margin_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>  = std::vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedArithVectorHelper.html">DelayedArithVectorHelper</a>&lt; DelayedArithOp::POWER, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">right_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">margin_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> &gt; tatami::make_DelayedPowerVectorHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">right_</td><td>Whether the scalar should be on the right hand side of the power transformation. </td></tr>
    <tr><td class="paramname">margin_</td><td><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a> dimension along which the power transformation is to occur, see <code><a class="el" href="structtatami_1_1DelayedArithVectorHelper.html" title="Delayed vector arithmetic.">DelayedArithVectorHelper</a></code>. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the data value. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector to use in the power transformation of the rows/columns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed vector power transformation. </dd></dl>

</div>
</div>
<a id="a4220ce5709e46ebce77b240b572d97d9" name="a4220ce5709e46ebce77b240b572d97d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4220ce5709e46ebce77b240b572d97d9">&#9670;&#160;</a></span>make_DelayedModuloVectorHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> right_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> margin_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>  = std::vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedArithVectorHelper.html">DelayedArithVectorHelper</a>&lt; DelayedArithOp::MODULO, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">right_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">margin_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> &gt; tatami::make_DelayedModuloVectorHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">right_</td><td>Whether the scalar should be on the right hand side of the modulus. </td></tr>
    <tr><td class="paramname">margin_</td><td><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a> dimension along which the modulus is to occur, see <code><a class="el" href="structtatami_1_1DelayedArithVectorHelper.html" title="Delayed vector arithmetic.">DelayedArithVectorHelper</a></code>. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the data value. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector to use in the modulus of the rows/columns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed vector modulus. </dd></dl>

</div>
</div>
<a id="a857fc6c11ec69895ac85991ac83c395d" name="a857fc6c11ec69895ac85991ac83c395d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a857fc6c11ec69895ac85991ac83c395d">&#9670;&#160;</a></span>make_DelayedIntegerDivideVectorHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> right_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> margin_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>  = std::vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedArithVectorHelper.html">DelayedArithVectorHelper</a>&lt; DelayedArithOp::INTEGER_DIVIDE, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">right_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">margin_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> &gt; tatami::make_DelayedIntegerDivideVectorHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">right_</td><td>Whether the scalar should be on the right hand side of the integer division. </td></tr>
    <tr><td class="paramname">margin_</td><td><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a> dimension along which the integer division is to occur, see <code><a class="el" href="structtatami_1_1DelayedArithVectorHelper.html" title="Delayed vector arithmetic.">DelayedArithVectorHelper</a></code>. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the data value. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector to integer divide (or be integer divided by) the rows/columns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed vector division. </dd></dl>

</div>
</div>
<a id="ac812e757b55c2145bc3d4cd113c712fd" name="ac812e757b55c2145bc3d4cd113c712fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac812e757b55c2145bc3d4cd113c712fd">&#9670;&#160;</a></span>make_DelayedBooleanNotHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBooleanNotHelper.html">DelayedBooleanNotHelper</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> &gt; tatami::make_DelayedBooleanNotHelper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of the data value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed NOT operation. </dd></dl>

</div>
</div>
<a id="ae460e24124cef43d8a5d3b82e8f02325" name="ae460e24124cef43d8a5d3b82e8f02325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae460e24124cef43d8a5d3b82e8f02325">&#9670;&#160;</a></span>make_DelayedBooleanAndScalarHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBooleanScalarHelper.html">DelayedBooleanScalarHelper</a>&lt; DelayedBooleanOp::AND, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> &gt; tatami::make_DelayedBooleanAndScalarHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of the data value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Scalar value to use in the operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed AND operation with a scalar. </dd></dl>

</div>
</div>
<a id="ac7dbc64e6b0a0c8c48b1423b4b6748f1" name="ac7dbc64e6b0a0c8c48b1423b4b6748f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7dbc64e6b0a0c8c48b1423b4b6748f1">&#9670;&#160;</a></span>make_DelayedBooleanOrScalarHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBooleanScalarHelper.html">DelayedBooleanScalarHelper</a>&lt; DelayedBooleanOp::OR &gt; tatami::make_DelayedBooleanOrScalarHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of the data value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Scalar value to use in the operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed OR operation with a scalar. </dd></dl>

</div>
</div>
<a id="a29f6f1b1d28c670f38fda651fe2aa03a" name="a29f6f1b1d28c670f38fda651fe2aa03a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f6f1b1d28c670f38fda651fe2aa03a">&#9670;&#160;</a></span>make_DelayedBooleanXorScalarHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBooleanScalarHelper.html">DelayedBooleanScalarHelper</a>&lt; DelayedBooleanOp::XOR &gt; tatami::make_DelayedBooleanXorScalarHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of the data value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Scalar value to be used in the operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed XOR operation with a scalar. </dd></dl>

</div>
</div>
<a id="a6bc5d47e0c391c17c85bddf19cc5620a" name="a6bc5d47e0c391c17c85bddf19cc5620a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bc5d47e0c391c17c85bddf19cc5620a">&#9670;&#160;</a></span>make_DelayedBooleanEqualScalarHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBooleanScalarHelper.html">DelayedBooleanScalarHelper</a>&lt; DelayedBooleanOp::EQUAL &gt; tatami::make_DelayedBooleanEqualScalarHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of the data value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Scalar value to be used in the operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed boolean equality operation with a scalar. </dd></dl>

</div>
</div>
<a id="a1fd06669afab8565747e08bbce4b041f" name="a1fd06669afab8565747e08bbce4b041f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fd06669afab8565747e08bbce4b041f">&#9670;&#160;</a></span>make_DelayedBooleanAndVectorHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> margin_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>  = std::vector&lt;Value_&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBooleanVectorHelper.html">DelayedBooleanVectorHelper</a>&lt; DelayedBooleanOp::AND, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">margin_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> &gt; tatami::make_DelayedBooleanAndVectorHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of the data value. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
    <tr><td class="paramname">margin_</td><td><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a> dimension along which the comparison is to occur, see <code><a class="el" href="structtatami_1_1DelayedBooleanVectorHelper.html" title="Delayed vector boolean operations.">DelayedBooleanVectorHelper</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector of values to be used in the operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed AND operation with a vector. </dd></dl>

</div>
</div>
<a id="a503f23fe3e5a2c5f5bc6c0db01a7f64d" name="a503f23fe3e5a2c5f5bc6c0db01a7f64d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a503f23fe3e5a2c5f5bc6c0db01a7f64d">&#9670;&#160;</a></span>make_DelayedBooleanOrVectorHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> margin_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>  = std::vector&lt;Value_&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBooleanVectorHelper.html">DelayedBooleanVectorHelper</a>&lt; DelayedBooleanOp::OR, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">margin_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> &gt; tatami::make_DelayedBooleanOrVectorHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of the data value. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
    <tr><td class="paramname">margin_</td><td><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a> dimension along which the comparison is to occur, see <code><a class="el" href="structtatami_1_1DelayedBooleanVectorHelper.html" title="Delayed vector boolean operations.">DelayedBooleanVectorHelper</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector of values to be used in the operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed OR operation with a vector. </dd></dl>

</div>
</div>
<a id="a4bcdace63565fc670b0393675e33bb11" name="a4bcdace63565fc670b0393675e33bb11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bcdace63565fc670b0393675e33bb11">&#9670;&#160;</a></span>make_DelayedBooleanXorVectorHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> margin_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>  = std::vector&lt;Value_&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBooleanVectorHelper.html">DelayedBooleanVectorHelper</a>&lt; DelayedBooleanOp::XOR, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">margin_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> &gt; tatami::make_DelayedBooleanXorVectorHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of the data value. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
    <tr><td class="paramname">margin_</td><td><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a> dimension along which the comparison is to occur, see <code><a class="el" href="structtatami_1_1DelayedBooleanVectorHelper.html" title="Delayed vector boolean operations.">DelayedBooleanVectorHelper</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector of values to be used in the operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed XOR operation with a vector. </dd></dl>

</div>
</div>
<a id="a8b07dc8b7a71776bcc222d7c437e2ca3" name="a8b07dc8b7a71776bcc222d7c437e2ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b07dc8b7a71776bcc222d7c437e2ca3">&#9670;&#160;</a></span>make_DelayedBooleanEqualVectorHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> margin_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>  = std::vector&lt;Value_&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBooleanVectorHelper.html">DelayedBooleanVectorHelper</a>&lt; DelayedBooleanOp::EQUAL, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">margin_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> &gt; tatami::make_DelayedBooleanEqualVectorHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of the data value. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
    <tr><td class="paramname">margin_</td><td><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a> dimension along which the comparison is to occur, see <code><a class="el" href="structtatami_1_1DelayedBooleanVectorHelper.html" title="Delayed vector boolean operations.">DelayedBooleanVectorHelper</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector of values to be used in the operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed boolean equality operation with a vector. </dd></dl>

</div>
</div>
<a id="a11bfea31e4524927274dc1d80c32fd96" name="a11bfea31e4524927274dc1d80c32fd96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11bfea31e4524927274dc1d80c32fd96">&#9670;&#160;</a></span>make_DelayedEqualScalarHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a>  = Value_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedCompareScalarHelper.html">DelayedCompareScalarHelper</a>&lt; DelayedCompareOp::EQUAL, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a> &gt; tatami::make_DelayedEqualScalarHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of the data value. </td></tr>
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Scalar value to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed equality comparison to a scalar. </dd></dl>

</div>
</div>
<a id="a1961ba2a59d705adf7b8627523a62b3a" name="a1961ba2a59d705adf7b8627523a62b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1961ba2a59d705adf7b8627523a62b3a">&#9670;&#160;</a></span>make_DelayedGreaterThanScalarHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a>  = Value_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedCompareScalarHelper.html">DelayedCompareScalarHelper</a>&lt; DelayedCompareOp::GREATER_THAN, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a> &gt; tatami::make_DelayedGreaterThanScalarHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of the data value. </td></tr>
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Scalar value to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed greater-than comparison to a scalar. </dd></dl>

</div>
</div>
<a id="a7d2d381ec9c0d87f5d561b4dd9d5a58e" name="a7d2d381ec9c0d87f5d561b4dd9d5a58e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d2d381ec9c0d87f5d561b4dd9d5a58e">&#9670;&#160;</a></span>make_DelayedLessThanScalarHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a>  = Value_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedCompareScalarHelper.html">DelayedCompareScalarHelper</a>&lt; DelayedCompareOp::LESS_THAN, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a> &gt; tatami::make_DelayedLessThanScalarHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of the data value. </td></tr>
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Scalar value to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed less-than comparison to a scalar. </dd></dl>

</div>
</div>
<a id="ac3df12ccdf4692c0f660f1634a79b857" name="ac3df12ccdf4692c0f660f1634a79b857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3df12ccdf4692c0f660f1634a79b857">&#9670;&#160;</a></span>make_DelayedGreaterThanOrEqualScalarHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a>  = Value_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedCompareScalarHelper.html">DelayedCompareScalarHelper</a>&lt; DelayedCompareOp::GREATER_THAN_OR_EQUAL, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a> &gt; tatami::make_DelayedGreaterThanOrEqualScalarHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of the data value. </td></tr>
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Scalar value to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed greater-than-or-equal comparison to a scalar. </dd></dl>

</div>
</div>
<a id="af5e67b02534cbe1813be5e2d690af88b" name="af5e67b02534cbe1813be5e2d690af88b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5e67b02534cbe1813be5e2d690af88b">&#9670;&#160;</a></span>make_DelayedLessThanOrEqualScalarHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a>  = Value_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedCompareScalarHelper.html">DelayedCompareScalarHelper</a>&lt; DelayedCompareOp::LESS_THAN_OR_EQUAL, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a> &gt; tatami::make_DelayedLessThanOrEqualScalarHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of the data value. </td></tr>
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Scalar value to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed less-than-or-equal comparison to a scalar. </dd></dl>

</div>
</div>
<a id="ac5d5cef56d2119e73e3f670d49de6b48" name="ac5d5cef56d2119e73e3f670d49de6b48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5d5cef56d2119e73e3f670d49de6b48">&#9670;&#160;</a></span>make_DelayedNotEqualScalarHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a>  = Value_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedCompareScalarHelper.html">DelayedCompareScalarHelper</a>&lt; DelayedCompareOp::NOT_EQUAL, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a> &gt; tatami::make_DelayedNotEqualScalarHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Scalar_</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of the data value. </td></tr>
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Scalar value to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed non-equality comparison to a scalar. </dd></dl>

</div>
</div>
<a id="aa40c54d5c5cc1109d42a150f5cd7ed2f" name="aa40c54d5c5cc1109d42a150f5cd7ed2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa40c54d5c5cc1109d42a150f5cd7ed2f">&#9670;&#160;</a></span>make_DelayedEqualVectorHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> margin_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>  = std::vector&lt;Value_&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedCompareVectorHelper.html">DelayedCompareVectorHelper</a>&lt; DelayedCompareOp::EQUAL, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">margin_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> &gt; tatami::make_DelayedEqualVectorHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">margin_</td><td><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a> dimension along which the comparison is to occur, see <code><a class="el" href="structtatami_1_1DelayedCompareVectorHelper.html" title="Delayed vector comparisons.">DelayedCompareVectorHelper</a></code>. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the data value. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector of values to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed equality comparison to a vector. </dd></dl>

</div>
</div>
<a id="aaf1951e22415be4714495556f701a7fd" name="aaf1951e22415be4714495556f701a7fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf1951e22415be4714495556f701a7fd">&#9670;&#160;</a></span>make_DelayedGreaterThanVectorHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> margin_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>  = std::vector&lt;Value_&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedCompareVectorHelper.html">DelayedCompareVectorHelper</a>&lt; DelayedCompareOp::GREATER_THAN, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">margin_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> &gt; tatami::make_DelayedGreaterThanVectorHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">margin_</td><td><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a> dimension along which the comparison is to occur, see <code><a class="el" href="structtatami_1_1DelayedCompareVectorHelper.html" title="Delayed vector comparisons.">DelayedCompareVectorHelper</a></code>. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the data value. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector of values to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed greater-than comparison to a vector. </dd></dl>

</div>
</div>
<a id="a6dca8b9072813f6e9e52aa0536817b82" name="a6dca8b9072813f6e9e52aa0536817b82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dca8b9072813f6e9e52aa0536817b82">&#9670;&#160;</a></span>make_DelayedLessThanVectorHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> margin_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>  = std::vector&lt;Value_&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedCompareVectorHelper.html">DelayedCompareVectorHelper</a>&lt; DelayedCompareOp::LESS_THAN, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">margin_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> &gt; tatami::make_DelayedLessThanVectorHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">margin_</td><td><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a> dimension along which the comparison is to occur, see <code><a class="el" href="structtatami_1_1DelayedCompareVectorHelper.html" title="Delayed vector comparisons.">DelayedCompareVectorHelper</a></code>. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the data value. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector of values to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed less-than comparison to a vector. </dd></dl>

</div>
</div>
<a id="a70a3e0489fdaccc80c7cc0125e9cf906" name="a70a3e0489fdaccc80c7cc0125e9cf906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70a3e0489fdaccc80c7cc0125e9cf906">&#9670;&#160;</a></span>make_DelayedGreaterThanOrEqualVectorHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> margin_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>  = std::vector&lt;Value_&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedCompareVectorHelper.html">DelayedCompareVectorHelper</a>&lt; DelayedCompareOp::GREATER_THAN_OR_EQUAL, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">margin_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> &gt; tatami::make_DelayedGreaterThanOrEqualVectorHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">margin_</td><td><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a> dimension along which the comparison is to occur, see <code><a class="el" href="structtatami_1_1DelayedCompareVectorHelper.html" title="Delayed vector comparisons.">DelayedCompareVectorHelper</a></code>. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the data value. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector of values to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed greater-than-or-equal comparison to a vector. </dd></dl>

</div>
</div>
<a id="a83999d2ac877c5b15f6fd5a0f33a894a" name="a83999d2ac877c5b15f6fd5a0f33a894a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83999d2ac877c5b15f6fd5a0f33a894a">&#9670;&#160;</a></span>make_DelayedLessThanOrEqualVectorHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> margin_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>  = std::vector&lt;Value_&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedCompareVectorHelper.html">DelayedCompareVectorHelper</a>&lt; DelayedCompareOp::LESS_THAN_OR_EQUAL, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">margin_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> &gt; tatami::make_DelayedLessThanOrEqualVectorHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">margin_</td><td><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a> dimension along which the comparison is to occur, see <code><a class="el" href="structtatami_1_1DelayedCompareVectorHelper.html" title="Delayed vector comparisons.">DelayedCompareVectorHelper</a></code>. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the data value. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector of values to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed less-than-or-equal comparison to a vector. </dd></dl>

</div>
</div>
<a id="a6c84e8b757cf5ba6479a6ea3e6e530e3" name="a6c84e8b757cf5ba6479a6ea3e6e530e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c84e8b757cf5ba6479a6ea3e6e530e3">&#9670;&#160;</a></span>make_DelayedNotEqualVectorHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> margin_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>  = std::vector&lt;Value_&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedCompareVectorHelper.html">DelayedCompareVectorHelper</a>&lt; DelayedCompareOp::NOT_EQUAL, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">margin_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a> &gt; tatami::make_DelayedNotEqualVectorHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Vector_</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">margin_</td><td><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a> dimension along which the comparison is to occur, see <code><a class="el" href="structtatami_1_1DelayedCompareVectorHelper.html" title="Delayed vector comparisons.">DelayedCompareVectorHelper</a></code>. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the data value. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector of values to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed non-equality comparison to a vector. </dd></dl>

</div>
</div>
<a id="a07b072944c766d85dc4ce4dc734e0b75" name="a07b072944c766d85dc4ce4dc734e0b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b072944c766d85dc4ce4dc734e0b75">&#9670;&#160;</a></span>make_DelayedUnaryIsometricOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">class</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Operation_</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; tatami::make_DelayedUnaryIsometricOp </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Operation_</a>&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <code>make_*</code> helper function to enable partial template deduction of supplied types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of index value. </td></tr>
    <tr><td class="paramname">Operation_</td><td>Helper class defining the operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to a (possibly <code>const</code>) <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code>. </td></tr>
    <tr><td class="paramname">op</td><td>Instance of the operation helper class.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Instance of a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOp.html" title="Delayed isometric operations on a single matrix.">DelayedUnaryIsometricOp</a></code> clas. </dd></dl>

</div>
</div>
<a id="af2620b6e2812c6952ed562d359229a99" name="af2620b6e2812c6952ed562d359229a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2620b6e2812c6952ed562d359229a99">&#9670;&#160;</a></span>make_DelayedBind()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> margin_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; tatami::make_DelayedBind </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; &gt;&#160;</td>
          <td class="paramname"><em>ps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <code>make_*</code> helper function to enable partial template deduction of supplied types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">margin_</td><td>Dimension along which the combining is to occur. If 0, matrices are combined along the rows; if 1, matrices are combined to the columns. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of index value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ps</td><td>Pointers to <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <code><a class="el" href="classtatami_1_1DelayedBind.html" title="Delayed combining of a matrix.">DelayedBind</a></code> instance. </dd></dl>

</div>
</div>
<a id="ab4c8b88eeaa5fcbb1e5d47d020eb98ea" name="ab4c8b88eeaa5fcbb1e5d47d020eb98ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4c8b88eeaa5fcbb1e5d47d020eb98ea">&#9670;&#160;</a></span>make_DelayedCast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">ValueOut_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">IndexOut_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">ValueIn_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">IndexIn_</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">ValueOut_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">IndexOut_</a> &gt; &gt; tatami::make_DelayedCast </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">ValueIn_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">IndexIn_</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recast a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> to a different interface type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueOut_</td><td>Data type to cast to. </td></tr>
    <tr><td class="paramname">IndexOut_</td><td>Index type to cast to. </td></tr>
    <tr><td class="paramname">ValueIn_</td><td>Data type to cast from. </td></tr>
    <tr><td class="paramname">IndexIn_</td><td>Index type to cast from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to the (possbly <code>const</code>) <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> instance to cast from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> instance of the desired interface type. </dd></dl>

</div>
</div>
<a id="afa35d8e9fe286967f327ec0eb6bd5005" name="afa35d8e9fe286967f327ec0eb6bd5005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa35d8e9fe286967f327ec0eb6bd5005">&#9670;&#160;</a></span>make_DelayedTranspose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; tatami::make_DelayedTranspose </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <code>make_*</code> helper function to enable partial template deduction of supplied types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of index value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to a (possibly <code>const</code>) <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <code><a class="el" href="classtatami_1_1DelayedTranspose.html" title="Delayed transposition of a matrix.">DelayedTranspose</a></code> instance. </dd></dl>

</div>
</div>
<a id="ab17e92414b0bff60f7b7a6431ac8a330" name="ab17e92414b0bff60f7b7a6431ac8a330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab17e92414b0bff60f7b7a6431ac8a330">&#9670;&#160;</a></span>compress_sparse_triplets()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> ROW, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">class</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">U</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">class</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">V</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">class</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">W</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">size_t</a> &gt; tatami::compress_sparse_triplets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">size_t</a>&#160;</td>
          <td class="paramname"><em>nr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">size_t</a>&#160;</td>
          <td class="paramname"><em>nc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">U</a> &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">V</a> &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">W</a> &amp;&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ROW</td><td>Whether to create a compressed sparse row format. If <code>false</code>, the compressed sparse column format is used instead. </td></tr>
    <tr><td class="paramname">U</td><td>Random-access container for the values. </td></tr>
    <tr><td class="paramname">V</td><td>Random access container for the row indices. </td></tr>
    <tr><td class="paramname">W</td><td>Random access container for the column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nr</td><td>Number of rows. </td></tr>
    <tr><td class="paramname">nc</td><td>Number of columns. </td></tr>
    <tr><td class="paramname">rows</td><td>Row indices. Values must be non-negative integers less than <code>nr</code>. </td></tr>
    <tr><td class="paramname">cols</td><td>Column indices. Values must be non-negative integers less than <code>nc</code>. </td></tr>
    <tr><td class="paramname">values</td><td>Non-zero values.</td></tr>
  </table>
  </dd>
</dl>
<p><code>rows</code>, <code>cols</code> and <code>values</code> must be of the same length. Corresponding entries across these vectors are assumed to contain data for a single non-zero element.</p>
<dl class="section return"><dt>Returns</dt><dd><code>rows</code>, <code>cols</code> and <code>values</code> are sorted in-place by the row and column indices (if <code>ROW = true</code>) or by the column and row indices (if <code>ROW = false</code>). A vector of index pointers is returned with length <code>nr + 1</code> (if <code>ROW = true</code>) or <code>nc + 1</code> (if <code>ROW = false</code>). </dd></dl>

</div>
</div>
<a id="ad1aee6313d02036d2f56703f372e1df6" name="ad1aee6313d02036d2f56703f372e1df6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1aee6313d02036d2f56703f372e1df6">&#9670;&#160;</a></span>retrieve_compressed_sparse_contents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> row_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputIndex_</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1CompressedSparseContents.html">CompressedSparseContents</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; tatami::retrieve_compressed_sparse_contents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputIndex_</a> &gt; *&#160;</td>
          <td class="paramname"><em>incoming</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td>
          <td class="paramname"><em>two_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a>&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">row_</td><td>Whether to retrieve contents by row. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of data values in the output interface. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the indices in the output interface. </td></tr>
    <tr><td class="paramname">StoredValue_</td><td>Type of data values to be stored in the output. </td></tr>
    <tr><td class="paramname">StoredIndex_</td><td>Integer type for storing the indices in the output. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of data values in the input interface. </td></tr>
    <tr><td class="paramname">InputIndex_</td><td>Integer type for indices in the input interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">incoming</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">two_pass</td><td>Whether to perform the retrieval in two passes. This requires another pass through <code>incoming</code> but is more memory-efficient. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Contents of the sparse matrix in compressed form, see <code><a class="el" href="structtatami_1_1FragmentedSparseContents.html" title="Fragmented sparse contents.">FragmentedSparseContents</a></code>. </dd></dl>

</div>
</div>
<a id="a48dab0e55d3b852afcfd9e93835190df" name="a48dab0e55d3b852afcfd9e93835190df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48dab0e55d3b852afcfd9e93835190df">&#9670;&#160;</a></span>convert_to_compressed_sparse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> row_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">StoredValue_</a>  = Value_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">StoredIndex_</a>  = Index_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputIndex_</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; tatami::convert_to_compressed_sparse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputIndex_</a> &gt; *&#160;</td>
          <td class="paramname"><em>incoming</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td>
          <td class="paramname"><em>two_pass</em> = <code><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">false</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a>&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">row_</td><td>Whether to return a compressed sparse row matrix. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of data values in the output interface. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the indices in the output interface. </td></tr>
    <tr><td class="paramname">StoredValue_</td><td>Type of data values to be stored in the output. </td></tr>
    <tr><td class="paramname">StoredIndex_</td><td>Integer type for storing the indices in the output. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of data values in the input interface. </td></tr>
    <tr><td class="paramname">InputIndex_</td><td>Integer type for indices in the input interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">incoming</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>, possibly containing delayed operations. </td></tr>
    <tr><td class="paramname">two_pass</td><td>Whether to use a two-pass strategy that reduces peak memory usage at the cost of speed. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a new <code><a class="el" href="classtatami_1_1CompressedSparseMatrix.html" title="Compressed sparse matrix representation.">tatami::CompressedSparseMatrix</a></code>, with the same dimensions and type as the matrix referenced by <code>incoming</code>. If <code>row_ = true</code>, the matrix is compressed sparse row, otherwise it is compressed sparse column. </dd></dl>

</div>
</div>
<a id="acf7ca799fac9cff0c16a77bf98e32ff3" name="acf7ca799fac9cff0c16a77bf98e32ff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf7ca799fac9cff0c16a77bf98e32ff3">&#9670;&#160;</a></span>convert_to_compressed_sparse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">StoredValue_</a>  = Value_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">StoredIndex_</a>  = Index_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputIndex_</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; tatami::convert_to_compressed_sparse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputIndex_</a> &gt; *&#160;</td>
          <td class="paramname"><em>incoming</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td>
          <td class="paramname"><em>two_pass</em> = <code><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">false</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a>&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This overload makes it easier to control the desired output order when it is not known at compile time.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of data values in the output interface. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the indices in the output interface. </td></tr>
    <tr><td class="paramname">StoredValue_</td><td>Type of data values to be stored in the output. </td></tr>
    <tr><td class="paramname">StoredIndex_</td><td>Integer type for storing the indices in the output. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of data values in the input interface. </td></tr>
    <tr><td class="paramname">InputIndex_</td><td>Integer type for indices in the input interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">incoming</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">order</td><td>Ordering of values in the output matrix - compressed sparse row (0) or column (1). If set to -1, the ordering is chosen based on <code><a class="el" href="classtatami_1_1Matrix.html#a69382d2a4e66cda1a9eb48dc25ab113a">tatami::Matrix::prefer_rows()</a></code>. </td></tr>
    <tr><td class="paramname">two_pass</td><td>Whether to use a two-pass strategy that reduces peak memory usage at the cost of speed. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a new <code><a class="el" href="classtatami_1_1CompressedSparseMatrix.html" title="Compressed sparse matrix representation.">tatami::CompressedSparseMatrix</a></code>, with the same dimensions and type as the matrix referenced by <code>incoming</code>. </dd></dl>

</div>
</div>
<a id="a012194aba94c37703f15555247e02155" name="a012194aba94c37703f15555247e02155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a012194aba94c37703f15555247e02155">&#9670;&#160;</a></span>retrieve_fragmented_sparse_contents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> row_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputIndex_</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1FragmentedSparseContents.html">FragmentedSparseContents</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; tatami::retrieve_fragmented_sparse_contents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputIndex_</a> &gt; *&#160;</td>
          <td class="paramname"><em>incoming</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a>&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">row_</td><td>Whether to retrieve contents by row. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of data values in the output interface. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the indices in the output interface. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of data values in the input interface. </td></tr>
    <tr><td class="paramname">InputIndex_</td><td>Integer type for indices in the input interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">incoming</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Contents of the sparse matrix in fragmented form, see <code><a class="el" href="structtatami_1_1FragmentedSparseContents.html" title="Fragmented sparse contents.">FragmentedSparseContents</a></code>. </dd></dl>

</div>
</div>
<a id="a953ad06ecc9a36c8d2c1f3febe84a787" name="a953ad06ecc9a36c8d2c1f3febe84a787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a953ad06ecc9a36c8d2c1f3febe84a787">&#9670;&#160;</a></span>convert_to_fragmented_sparse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> row_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">StoredValue_</a>  = Value_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">StoredIndex_</a>  = Index_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputIndex_</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; tatami::convert_to_fragmented_sparse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputIndex_</a> &gt; *&#160;</td>
          <td class="paramname"><em>incoming</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a>&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">row_</td><td>Whether to return a fragmented sparse row matrix. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of data values in the output interface. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the indices in the output interface. </td></tr>
    <tr><td class="paramname">StoredValue_</td><td>Type of data values to be stored in the output. </td></tr>
    <tr><td class="paramname">StoredIndex_</td><td>Integer type for storing the indices in the output. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of data values in the input interface. </td></tr>
    <tr><td class="paramname">InputIndex_</td><td>Integer type for indices in the input interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">incoming</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>, possibly containing delayed operations. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a new <code><a class="el" href="classtatami_1_1FragmentedSparseMatrix.html" title="Fragmented sparse matrix representation.">tatami::FragmentedSparseMatrix</a></code>, with the same dimensions and type as the matrix referenced by <code>incoming</code>. If <code>row_ = true</code>, the matrix is fragmented sparse row, otherwise it is fragmented sparse column. </dd></dl>

</div>
</div>
<a id="ae46babb9d985cffcb54bcba89553a811" name="ae46babb9d985cffcb54bcba89553a811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae46babb9d985cffcb54bcba89553a811">&#9670;&#160;</a></span>convert_to_fragmented_sparse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>  = double, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>  = int, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">StoredValue_</a>  = Value_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">StoredIndex_</a>  = Index_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputIndex_</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; tatami::convert_to_fragmented_sparse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputValue_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">InputIndex_</a> &gt; *&#160;</td>
          <td class="paramname"><em>incoming</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a>&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This overload makes it easier to control the desired output order when it is not known at compile time.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of data values in the output interface. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the indices in the output interface. </td></tr>
    <tr><td class="paramname">StoredValue_</td><td>Type of data values to be stored in the output. </td></tr>
    <tr><td class="paramname">StoredIndex_</td><td>Integer type for storing the indices in the output. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of data values in the input interface. </td></tr>
    <tr><td class="paramname">InputIndex_</td><td>Integer type for indices in the input interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">incoming</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">order</td><td>Ordering of values in the output matrix - fragmented sparse row (0) or column (1). If set to -1, the ordering is chosen based on <code><a class="el" href="classtatami_1_1Matrix.html#a69382d2a4e66cda1a9eb48dc25ab113a">tatami::Matrix::prefer_rows()</a></code>. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a new <code><a class="el" href="classtatami_1_1FragmentedSparseMatrix.html" title="Fragmented sparse matrix representation.">tatami::FragmentedSparseMatrix</a></code>, with the same dimensions and type as the matrix referenced by <code>incoming</code>. </dd></dl>

</div>
</div>
<a id="a8f4aafc0a1fbdc0c31bc122d24122a63" name="a8f4aafc0a1fbdc0c31bc122d24122a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f4aafc0a1fbdc0c31bc122d24122a63">&#9670;&#160;</a></span>make_DelayedSubsetBlock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> margin_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; tatami::make_DelayedSubsetBlock </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <code>make_*</code> helper function to enable partial template deduction of supplied types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">margin_</td><td>Dimension along which the addition is to occur. If 0, the subset is applied to the rows; if 1, the subset is applied to the columns. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to the underlying (pre-subset) <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code>. </td></tr>
    <tr><td class="paramname">f</td><td>Index of the start of the block. This should be a row index if <code>margin_ = 0</code> and a column index otherwise. </td></tr>
    <tr><td class="paramname">l</td><td>Index of the one-past-the-end of the block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <code><a class="el" href="classtatami_1_1DelayedSubsetBlock.html" title="Delayed subsetting to a contiguous block.">DelayedSubsetBlock</a></code> instance. </dd></dl>

</div>
</div>
<a id="abfc63177b00e6e3e2fa47754b8d87704" name="abfc63177b00e6e3e2fa47754b8d87704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc63177b00e6e3e2fa47754b8d87704">&#9670;&#160;</a></span>make_DelayedSubset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">int</a> margin_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">class</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">IndexStorage_</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt; tatami::make_DelayedSubset </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">IndexStorage_</a>&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <code>make_*</code> helper function to enable partial template deduction of supplied types. This will automatically dispatch to <code><a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html" title="Delayed subsetting of a matrix with sorted, unique indices.">DelayedSubsetSortedUnique</a></code>, <code><a class="el" href="classtatami_1_1DelayedSubsetUnique.html" title="Delayed subsetting of a matrix with unique indices.">DelayedSubsetUnique</a></code>, <code><a class="el" href="classtatami_1_1DelayedSubsetSorted.html" title="Delayed subsetting of a matrix with sorted indices.">DelayedSubsetSorted</a></code> or <code><a class="el" href="classtatami_1_1DelayedSubset.html" title="delayed subsetting of a matrix with general indices.">DelayedSubset</a></code>, depending on the values in <code>idx</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">margin_</td><td>Dimension along which the subsetting is to occur. If 0, the subset is applied to the rows; if 1, the subset is applied to the columns. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type of the row/column indices. </td></tr>
    <tr><td class="paramname">IndexStorage_</td><td>Vector containing the subset indices, to be automatically deduced. Any class implementing <code>[</code>, <code>size()</code>, <code>begin()</code> and <code>end()</code> can be used here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to a (possibly <code>const</code>) <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code>. </td></tr>
    <tr><td class="paramname">idx</td><td>Instance of the index vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <code><a class="el" href="classtatami_1_1DelayedSubset.html" title="delayed subsetting of a matrix with general indices.">DelayedSubset</a></code> instance. </dd></dl>

</div>
</div>
<a id="af05590455e558621c8ffc1b98c4fd454" name="af05590455e558621c8ffc1b98c4fd454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af05590455e558621c8ffc1b98c4fd454">&#9670;&#160;</a></span>consecutive_extractor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool sparse_, typename Value_ , typename Index_ , typename ... Args_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto tatami::consecutive_extractor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_&#160;</td>
          <td class="paramname"><em>iter_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_&#160;</td>
          <td class="paramname"><em>iter_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args_ &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">sparse_</td><td>Whether to perform sparse retrieval. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of the row/column index. </td></tr>
    <tr><td class="paramname">Args_</td><td>Types of further arguments to pass to <code><a class="el" href="classtatami_1_1Matrix.html#a168f0e932b5503c9bfc5dbd42754a7a5">Matrix::dense_row</a></code> or <code><a class="el" href="classtatami_1_1Matrix.html#a48300b3739f26bb10732c572ea9e5c57">Matrix::dense_column</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a> to iterate over. </td></tr>
    <tr><td class="paramname">row</td><td>Whether to perform extraction on rows. </td></tr>
    <tr><td class="paramname">iter_start</td><td>Index of the first row/column of the iteration range. </td></tr>
    <tr><td class="paramname">iter_length</td><td>Number of rows/columns in the iteration range. </td></tr>
    <tr><td class="paramname">args</td><td>Further arguments to pass to <code><a class="el" href="classtatami_1_1Matrix.html#a168f0e932b5503c9bfc5dbd42754a7a5">Matrix::dense_row</a></code> or <code><a class="el" href="classtatami_1_1Matrix.html#a48300b3739f26bb10732c572ea9e5c57">Matrix::dense_column</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An extractor for iteration over consecutive rows/columns in <code>[iter_start, iter_start + iter_length)</code>. This may be either an <code><a class="el" href="structtatami_1_1OracularDenseExtractor.html" title="Extract in dense form with an oracle.">OracularDenseExtractor</a></code> or <code><a class="el" href="structtatami_1_1OracularSparseExtractor.html" title="Extract in sparse form with an oracle.">OracularSparseExtractor</a></code> depending on <code>sparse_</code>.</dd></dl>
<p>This function creates an extractor object with a <code><a class="el" href="structtatami_1_1ConsecutiveOracle.html" title="Predict future accesses of a consecutive sequence.">ConsecutiveOracle</a></code> instance spanning a range of rows or columns. <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> implementations that are oracle-aware can then perform pre-fetching of future accesses for greater performance. </p>

</div>
</div>
<a id="ab52a806e3f13a68741a9e1f77dccab14" name="ab52a806e3f13a68741a9e1f77dccab14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab52a806e3f13a68741a9e1f77dccab14">&#9670;&#160;</a></span>copy_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Size_</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> * tatami::copy_n </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Size_</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of value being copied. </td></tr>
    <tr><td class="paramname">Size_</td><td>Type for the array length.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Pointer to a source array of size <code>n</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>Length of the array. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Pointer to a destination array of size <code>n</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Values are copied from <code>input</code> to <code>output</code>, and <code>output</code> is returned. This is a no-op if <code>input == output</code>. </dd></dl>

</div>
</div>
<a id="ae5e845574f229ff8308121456fac3d47" name="ae5e845574f229ff8308121456fac3d47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5e845574f229ff8308121456fac3d47">&#9670;&#160;</a></span>new_extractor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> sparse_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> oracle_, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> ... Args_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">auto</a> tatami::new_extractor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Value_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#aab9d426a238a93d02635b4172c725808">MaybeOracle</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">oracle_</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt;&#160;</td>
          <td class="paramname"><em>oracle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Args_</a> &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This utility makes it easier for developers to write a single templated function that works with and without oracles. A boolean placeholder should be provided as the "oracle" in the myopic extractor case.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">sparse_</td><td>Whether to perform sparse retrieval. </td></tr>
    <tr><td class="paramname">oracle_</td><td>Whether an oracle should be supplied. </td></tr>
    <tr><td class="paramname">Value_</td><td>Data value type, should be numeric. </td></tr>
    <tr><td class="paramname">Index_</td><td>Row/column index type, should be integer. </td></tr>
    <tr><td class="paramname">Args_</td><td>Further arguments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code> object to iterate over. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">row</td><td>Whether to create a row-wise extractor. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">oracle</td><td>Pointer to an oracle if <code>oracle_ = true</code>, otherwise a placeholder boolean that is ignored. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">args</td><td>Zero or more additional arguments to pass to methods like <code><a class="el" href="classtatami_1_1Matrix.html#a168f0e932b5503c9bfc5dbd42754a7a5">Matrix::dense_row()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An extractor to access elements of the requested dimension of <code>ptr</code>. This may be any of <code><a class="el" href="structtatami_1_1MyopicDenseExtractor.html" title="Extract a dimension element in dense form without an oracle.">MyopicDenseExtractor</a></code>, <code><a class="el" href="structtatami_1_1MyopicSparseExtractor.html" title="Extract in sparse form without an oracle.">MyopicSparseExtractor</a></code>, <code><a class="el" href="structtatami_1_1OracularDenseExtractor.html" title="Extract in dense form with an oracle.">OracularDenseExtractor</a></code> or <code><a class="el" href="structtatami_1_1OracularSparseExtractor.html" title="Extract in sparse form with an oracle.">OracularSparseExtractor</a></code>, depending on <code>sparse_</code> and <code>oracle_</code>. </dd></dl>

</div>
</div>
<a id="a41e252422f9959a123ba390a941ae76f" name="a41e252422f9959a123ba390a941ae76f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41e252422f9959a123ba390a941ae76f">&#9670;&#160;</a></span>parallelize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">bool</a> parallel_ = true, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">class</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Function_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">void</a> tatami::parallelize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Function_</a>&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>tasks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">size_t</a>&#160;</td>
          <td class="paramname"><em>threads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply a function to a set of tasks in parallel, usually for iterating over a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">Matrix</a></code>. This can be done using:</p>
<ul>
<li>OpenMP, if available and enabled by the compiler.</li>
<li>Using a custom parallelization scheme, by defining a <code>TATAMI_CUSTOM_PARALLEL</code> function-like macro. This should accept the <code>fun</code>, <code>tasks</code> and <code>threads</code> arguments as below.</li>
<li><code>&lt;thread&gt;</code>, otherwise.</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">parallel_</td><td>Whether the tasks should be run in parallel. If <code>false</code>, no parallelization is performed and all tasks are run on the current thread. </td></tr>
    <tr><td class="paramname">Function_</td><td>Function to be applied for a contiguous range of tasks. This should accept three arguments:<ul>
<li><code>thread</code>, the thread number executing this task range. This will be passed as a <code>size_t</code>.</li>
<li><code>task_start</code>, the start index of the task range. This will be passed as a <code>Index_</code>.</li>
<li><code>task_length</code>, the number of tasks in the task range. This will be passed as a <code>Index_</code>. </li>
</ul>
</td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the number of tasks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fun</td><td>Function that executes a contiguous range of tasks. </td></tr>
    <tr><td class="paramname">tasks</td><td>Number of tasks. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af01c93a616eb99f6a17861a8b19f7ee0" name="af01c93a616eb99f6a17861a8b19f7ee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af01c93a616eb99f6a17861a8b19f7ee0">&#9670;&#160;</a></span>process_consecutive_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">class</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Function_</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">void</a> tatami::process_consecutive_indices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a> *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Index_</a>&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">Function_</a>&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Process runs of consecutive indices that are used in the index-aware <code>dense_row()</code>, <code>sparse_column()</code>, etc. methods. This provides some opportunities for optimization when the indices contain contiguous stretches. For example, third-party libraries can be asked to process blocks of observations rather than handling them one at a time.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
    <tr><td class="paramname">Function_</td><td>Function to apply to each contiguous run.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Pointer to an array of sorted and unique indices for row/column elements. </td></tr>
    <tr><td class="paramname">length</td><td>Length of the array pointed to by <code>indices</code>. </td></tr>
    <tr><td class="paramname">fun</td><td>Function to apply to each contiguous run of indices. This should take two arguments - the start index of each run, and the length of the run. Calls to <code>fun</code> are guaranteed to contain increasing start indices with non-overlapping runs. The return value of this function is ignored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7518f5e8e09a6f6d7d3955b8ea286689" name="a7518f5e8e09a6f6d7d3955b8ea286689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7518f5e8e09a6f6d7d3955b8ea286689">&#9670;&#160;</a></span>wrap_shared_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">T</a> , <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">typename</a> <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">IDX</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">T</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">IDX</a> &gt; &gt; tatami::wrap_shared_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">const</a> <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">T</a>, <a class="el" href="namespacetatami.html#af05590455e558621c8ffc1b98c4fd454">IDX</a> &gt; *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrap a raw pointer inside a <code>shared_ptr</code>, typically to enable use of a raw <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code> pointer with delayed operation wrappers. This enables use of delayed operations inside functions that accept a raw pointer to an externally owned <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix with a defined type.">tatami::Matrix</a></code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to the same object addressed by <code>ptr</code>. The assumption is that <code>ptr</code> will always outlive the returned pointer. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
