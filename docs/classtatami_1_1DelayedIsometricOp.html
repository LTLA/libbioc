<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tatami: tatami::DelayedIsometricOp&lt; T, IDX, OP &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tatami
   </div>
   <div id="projectbrief">C++ API for different matrix representations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>tatami</b></li><li class="navelem"><a class="el" href="classtatami_1_1DelayedIsometricOp.html">DelayedIsometricOp</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classtatami_1_1DelayedIsometricOp-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Delayed isometric operations on a matrix.  
 <a href="classtatami_1_1DelayedIsometricOp.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="DelayedIsometricOp_8hpp_source.html">DelayedIsometricOp.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classtatami_1_1DelayedIsometricOp__inherit__graph.png" border="0" usemap="#atatami_1_1DelayedIsometricOp_3_01T_00_01IDX_00_01OP_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="atatami_1_1DelayedIsometricOp_3_01T_00_01IDX_00_01OP_01_4_inherit__map" id="atatami_1_1DelayedIsometricOp_3_01T_00_01IDX_00_01OP_01_4_inherit__map">
<area shape="rect" title="Delayed isometric operations on a matrix." alt="" coords="5,169,169,211"/>
<area shape="rect" href="classtatami_1_1typed__matrix.html" title=" " alt="" coords="19,80,156,121"/>
<area shape="rect" href="classtatami_1_1matrix.html" title="Virtual class for all matrices." alt="" coords="38,5,137,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classtatami_1_1DelayedIsometricOp__coll__graph.png" border="0" usemap="#atatami_1_1DelayedIsometricOp_3_01T_00_01IDX_00_01OP_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="atatami_1_1DelayedIsometricOp_3_01T_00_01IDX_00_01OP_01_4_coll__map" id="atatami_1_1DelayedIsometricOp_3_01T_00_01IDX_00_01OP_01_4_coll__map">
<area shape="rect" title="Delayed isometric operations on a matrix." alt="" coords="5,169,169,211"/>
<area shape="rect" href="classtatami_1_1typed__matrix.html" title=" " alt="" coords="19,80,156,121"/>
<area shape="rect" href="classtatami_1_1matrix.html" title="Virtual class for all matrices." alt="" coords="38,5,137,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6b49cc20f2fcf3dfcd274d3d1e19b82b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedIsometricOp.html#a6b49cc20f2fcf3dfcd274d3d1e19b82b">DelayedIsometricOp</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1typed__matrix.html">typed_matrix</a>&lt; T, IDX &gt; &gt; p, OP op)</td></tr>
<tr class="separator:a6b49cc20f2fcf3dfcd274d3d1e19b82b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb764f8eb8457884519f3c9cce5945e"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedIsometricOp.html#a9fb764f8eb8457884519f3c9cce5945e">row</a> (size_t r, T *buffer, size_t start, size_t end, <a class="el" href="classtatami_1_1workspace.html">workspace</a> *work=nullptr) const</td></tr>
<tr class="separator:a9fb764f8eb8457884519f3c9cce5945e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad41206c6087c4745a211f6be776c0e12"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedIsometricOp.html#ad41206c6087c4745a211f6be776c0e12">column</a> (size_t c, T *buffer, size_t start, size_t end, <a class="el" href="classtatami_1_1workspace.html">workspace</a> *work=nullptr) const</td></tr>
<tr class="separator:ad41206c6087c4745a211f6be776c0e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd2e6a0f44233ad48c350be9b596a40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1sparse__range.html">sparse_range</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedIsometricOp.html#a5fd2e6a0f44233ad48c350be9b596a40">sparse_row</a> (size_t r, T *vbuffer, IDX *ibuffer, size_t start, size_t end, <a class="el" href="classtatami_1_1workspace.html">workspace</a> *work=nullptr, bool sorted=true) const</td></tr>
<tr class="separator:a5fd2e6a0f44233ad48c350be9b596a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa939832166475a2d576069ed08c9f0ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1sparse__range.html">sparse_range</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedIsometricOp.html#aa939832166475a2d576069ed08c9f0ba">sparse_column</a> (size_t c, T *vbuffer, IDX *ibuffer, size_t start, size_t end, <a class="el" href="classtatami_1_1workspace.html">workspace</a> *work=nullptr, bool sorted=true) const</td></tr>
<tr class="separator:aa939832166475a2d576069ed08c9f0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff7ed215617739acaa9571b43df40db"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedIsometricOp.html#afff7ed215617739acaa9571b43df40db">nrow</a> () const</td></tr>
<tr class="separator:afff7ed215617739acaa9571b43df40db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452bca17a80a3c0813fd17af9a31b954"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedIsometricOp.html#a452bca17a80a3c0813fd17af9a31b954">ncol</a> () const</td></tr>
<tr class="separator:a452bca17a80a3c0813fd17af9a31b954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825d8775cf38df919230278d2a01dafe"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1workspace.html">workspace</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedIsometricOp.html#a825d8775cf38df919230278d2a01dafe">new_workspace</a> (bool <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a9fb764f8eb8457884519f3c9cce5945e">row</a>) const</td></tr>
<tr class="separator:a825d8775cf38df919230278d2a01dafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7993cbcf05de154adb696169a7fa4003"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedIsometricOp.html#a7993cbcf05de154adb696169a7fa4003">sparse</a> () const</td></tr>
<tr class="separator:a7993cbcf05de154adb696169a7fa4003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac7d662db8f3b0da5431b3035a903e1e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedIsometricOp.html#aac7d662db8f3b0da5431b3035a903e1e">prefer_rows</a> () const</td></tr>
<tr class="separator:aac7d662db8f3b0da5431b3035a903e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classtatami_1_1typed__matrix"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classtatami_1_1typed__matrix')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classtatami_1_1typed__matrix.html">tatami::typed_matrix&lt; T, IDX &gt;</a></td></tr>
<tr class="memitem:a990d98d3065ba89ed74466e07e2069bd inherit pub_methods_classtatami_1_1typed__matrix"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1typed__matrix.html#a990d98d3065ba89ed74466e07e2069bd">row</a> (size_t r, T *buffer, <a class="el" href="classtatami_1_1workspace.html">workspace</a> *work=nullptr) const</td></tr>
<tr class="separator:a990d98d3065ba89ed74466e07e2069bd inherit pub_methods_classtatami_1_1typed__matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac893cae1d607508b6bb5122ce2e380c1 inherit pub_methods_classtatami_1_1typed__matrix"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1typed__matrix.html#ac893cae1d607508b6bb5122ce2e380c1">column</a> (size_t c, T *buffer, <a class="el" href="classtatami_1_1workspace.html">workspace</a> *work=nullptr) const</td></tr>
<tr class="separator:ac893cae1d607508b6bb5122ce2e380c1 inherit pub_methods_classtatami_1_1typed__matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f16ff7448cb0dc181f478ccee7acc2 inherit pub_methods_classtatami_1_1typed__matrix"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1sparse__range.html">sparse_range</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1typed__matrix.html#a18f16ff7448cb0dc181f478ccee7acc2">sparse_row</a> (size_t r, T *vbuffer, IDX *ibuffer, <a class="el" href="classtatami_1_1workspace.html">workspace</a> *work=nullptr, bool sorted=true) const</td></tr>
<tr class="separator:a18f16ff7448cb0dc181f478ccee7acc2 inherit pub_methods_classtatami_1_1typed__matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae731393551564a8f5aeaf6133b5110c4 inherit pub_methods_classtatami_1_1typed__matrix"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1sparse__range.html">sparse_range</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1typed__matrix.html#ae731393551564a8f5aeaf6133b5110c4">sparse_column</a> (size_t c, T *vbuffer, IDX *ibuffer, <a class="el" href="classtatami_1_1workspace.html">workspace</a> *work=nullptr, bool sorted=true) const</td></tr>
<tr class="separator:ae731393551564a8f5aeaf6133b5110c4 inherit pub_methods_classtatami_1_1typed__matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf879b09180a61660d8eacd2cfc035ac inherit pub_methods_classtatami_1_1typed__matrix"><td class="memItemLeft" align="right" valign="top"><a class="el" href="content__type_8hpp.html#aac79d5f0dc4bb45282e5a68cb2962dc5">content_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1typed__matrix.html#abf879b09180a61660d8eacd2cfc035ac">type</a> () const</td></tr>
<tr class="separator:abf879b09180a61660d8eacd2cfc035ac inherit pub_methods_classtatami_1_1typed__matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename IDX, class OP&gt;<br />
class tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</h3>

<p>Delayed isometric operations on a matrix. </p>
<p>Implements any operation that preserves the shape of the matrix and operates on each matrix value independently. This operation is "delayed" in that it is only evaluated on request, e.g., with <code><a class="el" href="classtatami_1_1DelayedIsometricOp.html#a9fb764f8eb8457884519f3c9cce5945e">row()</a></code> or friends.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of matrix value. </td></tr>
    <tr><td class="paramname">OP</td><td>Functor class implementing the operation. This should accept the row index, column index and value, and return the modified value after applying the operation. </td></tr>
    <tr><td class="paramname">IDX</td><td>Type of index value. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6b49cc20f2fcf3dfcd274d3d1e19b82b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b49cc20f2fcf3dfcd274d3d1e19b82b">&#9670;&nbsp;</a></span>DelayedIsometricOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX , class OP &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedIsometricOp.html">tatami::DelayedIsometricOp</a>&lt; T, IDX, OP &gt;::<a class="el" href="classtatami_1_1DelayedIsometricOp.html">DelayedIsometricOp</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1typed__matrix.html">typed_matrix</a>&lt; T, IDX &gt; &gt;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OP&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to the underlying matrix. </td></tr>
    <tr><td class="paramname">op</td><td>Instance of the functor class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad41206c6087c4745a211f6be776c0e12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad41206c6087c4745a211f6be776c0e12">&#9670;&nbsp;</a></span>column()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX , class OP &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classtatami_1_1DelayedIsometricOp.html">tatami::DelayedIsometricOp</a>&lt; T, IDX, OP &gt;::column </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtatami_1_1workspace.html">workspace</a> *&#160;</td>
          <td class="paramname"><em>work</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><code>buffer</code> may not necessarily be filled upon extraction if a pointer can be returned to the underlying data store. This be checked by comparing the returned pointer to <code>buffer</code>; if they are the same, <code>buffer</code> has been filled.</p>
<p>If <code>work</code> is not a null pointer, it should have been generated by <code><a class="el" href="classtatami_1_1DelayedIsometricOp.html#a825d8775cf38df919230278d2a01dafe">new_workspace()</a></code> with <code>row = false</code>. This is optional and should only affect the efficiency of extraction, not the contents.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Index of the column. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer with enough space for at least <code>last - first</code> values. </td></tr>
    <tr><td class="paramname">first</td><td>First row to extract for column <code>c</code>. </td></tr>
    <tr><td class="paramname">last</td><td>One past the last row to extract in <code>c</code>. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to a workspace.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the values of column <code>c</code>, starting from the value in the <code>first</code> row and containing <code>last - first</code> valid entries. </dd></dl>

<p>Implements <a class="el" href="classtatami_1_1typed__matrix.html#a9e6aa2e4538b74f25d018ad21ebc4c69">tatami::typed_matrix&lt; T, IDX &gt;</a>.</p>

</div>
</div>
<a id="a452bca17a80a3c0813fd17af9a31b954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a452bca17a80a3c0813fd17af9a31b954">&#9670;&nbsp;</a></span>ncol()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX , class OP &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classtatami_1_1DelayedIsometricOp.html">tatami::DelayedIsometricOp</a>&lt; T, IDX, OP &gt;::ncol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Number of columns. </dd></dl>

<p>Implements <a class="el" href="classtatami_1_1matrix.html#a433c79bdee72c01d00b169d236464964">tatami::matrix</a>.</p>

</div>
</div>
<a id="a825d8775cf38df919230278d2a01dafe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a825d8775cf38df919230278d2a01dafe">&#9670;&nbsp;</a></span>new_workspace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX , class OP &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classtatami_1_1workspace.html">workspace</a>&gt; <a class="el" href="classtatami_1_1DelayedIsometricOp.html">tatami::DelayedIsometricOp</a>&lt; T, IDX, OP &gt;::new_workspace </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A null pointer or a shared pointer to a <code>workspace</code> object, depending on the underlying (pre-operation) matrix. </dd></dl>

<p>Reimplemented from <a class="el" href="classtatami_1_1matrix.html#aad899d17508a770b901a864e03e0b838">tatami::matrix</a>.</p>

</div>
</div>
<a id="afff7ed215617739acaa9571b43df40db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff7ed215617739acaa9571b43df40db">&#9670;&nbsp;</a></span>nrow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX , class OP &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classtatami_1_1DelayedIsometricOp.html">tatami::DelayedIsometricOp</a>&lt; T, IDX, OP &gt;::nrow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Number of rows. </dd></dl>

<p>Implements <a class="el" href="classtatami_1_1matrix.html#a460aca32225635cc6e2ee6ef5e59bb0a">tatami::matrix</a>.</p>

</div>
</div>
<a id="aac7d662db8f3b0da5431b3035a903e1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac7d662db8f3b0da5431b3035a903e1e">&#9670;&nbsp;</a></span>prefer_rows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX , class OP &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtatami_1_1DelayedIsometricOp.html">tatami::DelayedIsometricOp</a>&lt; T, IDX, OP &gt;::prefer_rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if row-wise extraction is preferred by the underlying (pre-operation) matrix, otherwise returns <code>false</code>. </dd></dl>

<p>Reimplemented from <a class="el" href="classtatami_1_1matrix.html#ad080e53326aca6016a2bee8d19a0fea7">tatami::matrix</a>.</p>

</div>
</div>
<a id="a9fb764f8eb8457884519f3c9cce5945e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fb764f8eb8457884519f3c9cce5945e">&#9670;&nbsp;</a></span>row()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX , class OP &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classtatami_1_1DelayedIsometricOp.html">tatami::DelayedIsometricOp</a>&lt; T, IDX, OP &gt;::row </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtatami_1_1workspace.html">workspace</a> *&#160;</td>
          <td class="paramname"><em>work</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See comments for <code><a class="el" href="classtatami_1_1DelayedIsometricOp.html#ad41206c6087c4745a211f6be776c0e12">column()</a></code>, which are also applicable here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Index of the row. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer with enough space for at least <code>last - first</code> values. </td></tr>
    <tr><td class="paramname">first</td><td>First column to extract for row <code>r</code>. </td></tr>
    <tr><td class="paramname">last</td><td>One past the last column to extract in <code>r</code>. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to a workspace.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the values of row <code>r</code>, starting from the value in the <code>first</code> column and containing <code>last - first</code> valid entries. </dd></dl>

<p>Implements <a class="el" href="classtatami_1_1typed__matrix.html#a847586300593529aba1ff766a00f966d">tatami::typed_matrix&lt; T, IDX &gt;</a>.</p>

</div>
</div>
<a id="a7993cbcf05de154adb696169a7fa4003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7993cbcf05de154adb696169a7fa4003">&#9670;&nbsp;</a></span>sparse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX , class OP &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtatami_1_1DelayedIsometricOp.html">tatami::DelayedIsometricOp</a>&lt; T, IDX, OP &gt;::sparse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both the underlying (pre-operation) matrix is sparse and the operation preserves sparsity. Otherwise returns <code>false</code>. </dd></dl>

<p>Reimplemented from <a class="el" href="classtatami_1_1matrix.html#ad4d53813c32de8561a2cff905fe4a501">tatami::matrix</a>.</p>

</div>
</div>
<a id="aa939832166475a2d576069ed08c9f0ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa939832166475a2d576069ed08c9f0ba">&#9670;&nbsp;</a></span>sparse_column()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX , class OP &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1sparse__range.html">sparse_range</a>&lt;T, IDX&gt; <a class="el" href="classtatami_1_1DelayedIsometricOp.html">tatami::DelayedIsometricOp</a>&lt; T, IDX, OP &gt;::sparse_column </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>vbuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IDX *&#160;</td>
          <td class="paramname"><em>ibuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtatami_1_1workspace.html">workspace</a> *&#160;</td>
          <td class="paramname"><em>work</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sorted</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><code>vbuffer</code> may not necessarily be filled upon extraction if a pointer can be returned to the underlying data store. This be checked by comparing the returned <code><a class="el" href="structtatami_1_1sparse__range.html#ad23d530e0181196804b761942c73d2c2">sparse_range::value</a></code> pointer to <code>vbuffer</code>; if they are the same, <code>vbuffer</code> has been filled. The same applies for <code>ibuffer</code> and the returned <code><a class="el" href="structtatami_1_1sparse__range.html#ab90aaa9698db7de4df68e5adac8f7826">sparse_range::index</a></code> pointer.</p>
<p>Values in <code>vbuffer</code> are not guaranteed to be non-zero. If zeroes are explicitly initialized in the underlying representation, they will be reported here. However, one can safely assume that all values <em>not</em> in <code>vbuffer</code> are zero.</p>
<p>If <code>work</code> is not a null pointer, it should have been generated by <code><a class="el" href="classtatami_1_1DelayedIsometricOp.html#a825d8775cf38df919230278d2a01dafe">new_workspace()</a></code> with <code>row = true</code>. This is optional and should only affect the efficiency of extraction, not the contents.</p>
<p>Setting <code>sorted = false</code> can reduce computational work in situations where the order of non-zero elements does not matter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Index of the column. </td></tr>
    <tr><td class="paramname">vbuffer</td><td>Pointer with enough space for at least <code>last - first</code> values. </td></tr>
    <tr><td class="paramname">ibuffer</td><td>Pointer with enough space for at least <code>last - first</code> indices. </td></tr>
    <tr><td class="paramname">first</td><td>First row to extract for column <code>c</code>. </td></tr>
    <tr><td class="paramname">last</td><td>One past the last row to extract in <code>c</code>. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to a workspace. </td></tr>
    <tr><td class="paramname">sorted</td><td>Should the non-zero elements be sorted by their indices?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structtatami_1_1sparse__range.html" title="A range of sparse values.">sparse_range</a></code> object containing the number of non-zero elements in <code>c</code> from column <code>first</code> up to <code>last</code>. This also contains pointers to their row indices and values. </dd></dl>

<p>Reimplemented from <a class="el" href="classtatami_1_1typed__matrix.html#a8b706b89efcf4bffa2bf3477cb1c2f2c">tatami::typed_matrix&lt; T, IDX &gt;</a>.</p>

</div>
</div>
<a id="a5fd2e6a0f44233ad48c350be9b596a40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fd2e6a0f44233ad48c350be9b596a40">&#9670;&nbsp;</a></span>sparse_row()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX , class OP &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1sparse__range.html">sparse_range</a>&lt;T, IDX&gt; <a class="el" href="classtatami_1_1DelayedIsometricOp.html">tatami::DelayedIsometricOp</a>&lt; T, IDX, OP &gt;::sparse_row </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>vbuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IDX *&#160;</td>
          <td class="paramname"><em>ibuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtatami_1_1workspace.html">workspace</a> *&#160;</td>
          <td class="paramname"><em>work</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sorted</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See comments for <code><a class="el" href="classtatami_1_1DelayedIsometricOp.html#aa939832166475a2d576069ed08c9f0ba">sparse_column()</a></code>, which are also applicable here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Index of the row. </td></tr>
    <tr><td class="paramname">vbuffer</td><td>Pointer with enough space for at least <code>last - first</code> values. </td></tr>
    <tr><td class="paramname">ibuffer</td><td>Pointer with enough space for at least <code>last - first</code> indices. </td></tr>
    <tr><td class="paramname">first</td><td>First column to extract for row <code>r</code>. </td></tr>
    <tr><td class="paramname">last</td><td>One past the last column to extract in <code>r</code>. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to a workspace. </td></tr>
    <tr><td class="paramname">sorted</td><td>Should the non-zero elements be sorted by their indices?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structtatami_1_1sparse__range.html" title="A range of sparse values.">sparse_range</a></code> object containing the number of non-zero elements in <code>r</code> from column <code>first</code> up to <code>last</code>. This also contains pointers to their column indices and values. </dd></dl>

<p>Reimplemented from <a class="el" href="classtatami_1_1typed__matrix.html#a7a9568dbb4aaa06847693d6108237d38">tatami::typed_matrix&lt; T, IDX &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/github/workspace/include/tatami/base/<a class="el" href="DelayedIsometricOp_8hpp_source.html">DelayedIsometricOp.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
