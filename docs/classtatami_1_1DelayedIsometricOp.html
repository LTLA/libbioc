<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tatami: tatami::DelayedIsometricOp&lt; T, IDX, OP &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tatami
   </div>
   <div id="projectbrief">C++ API for different matrix representations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>tatami</b></li><li class="navelem"><a class="el" href="classtatami_1_1DelayedIsometricOp.html">DelayedIsometricOp</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classtatami_1_1DelayedIsometricOp-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tatami::DelayedIsometricOp&lt; T, IDX, OP &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Delayed isometric operations on a matrix.  
 <a href="classtatami_1_1DelayedIsometricOp.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="DelayedIsometricOp_8hpp_source.html">DelayedIsometricOp.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classtatami_1_1DelayedIsometricOp__inherit__graph.png" border="0" usemap="#atatami_1_1DelayedIsometricOp_3_01T_00_01IDX_00_01OP_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="atatami_1_1DelayedIsometricOp_3_01T_00_01IDX_00_01OP_01_4_inherit__map" id="atatami_1_1DelayedIsometricOp_3_01T_00_01IDX_00_01OP_01_4_inherit__map">
<area shape="rect" title="Delayed isometric operations on a matrix." alt="" coords="5,95,169,136"/>
<area shape="rect" href="classtatami_1_1Matrix.html" title=" " alt="" coords="26,5,149,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classtatami_1_1DelayedIsometricOp__coll__graph.png" border="0" usemap="#atatami_1_1DelayedIsometricOp_3_01T_00_01IDX_00_01OP_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="atatami_1_1DelayedIsometricOp_3_01T_00_01IDX_00_01OP_01_4_coll__map" id="atatami_1_1DelayedIsometricOp_3_01T_00_01IDX_00_01OP_01_4_coll__map">
<area shape="rect" title="Delayed isometric operations on a matrix." alt="" coords="5,95,169,136"/>
<area shape="rect" href="classtatami_1_1Matrix.html" title=" " alt="" coords="26,5,149,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac35c661c2c7ca2de94468b43aee46a54"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedIsometricOp.html#ac35c661c2c7ca2de94468b43aee46a54">DelayedIsometricOp</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; &gt; p, OP op)</td></tr>
<tr class="separator:ac35c661c2c7ca2de94468b43aee46a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381a5e419200c72518e62c40c9ffa105"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedIsometricOp.html#a381a5e419200c72518e62c40c9ffa105">row</a> (size_t r, T *buffer, size_t start, size_t end, <a class="el" href="classtatami_1_1Workspace.html">Workspace</a> *work=nullptr) const</td></tr>
<tr class="separator:a381a5e419200c72518e62c40c9ffa105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa09e2b36af415ca443d57cc0cda38ebe"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedIsometricOp.html#aa09e2b36af415ca443d57cc0cda38ebe">column</a> (size_t c, T *buffer, size_t start, size_t end, <a class="el" href="classtatami_1_1Workspace.html">Workspace</a> *work=nullptr) const</td></tr>
<tr class="separator:aa09e2b36af415ca443d57cc0cda38ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ff2329e314827b451d5cb9ed66b037"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedIsometricOp.html#a89ff2329e314827b451d5cb9ed66b037">sparse_row</a> (size_t r, T *vbuffer, IDX *ibuffer, size_t start, size_t end, <a class="el" href="classtatami_1_1Workspace.html">Workspace</a> *work=nullptr, bool sorted=true) const</td></tr>
<tr class="separator:a89ff2329e314827b451d5cb9ed66b037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7aeab23d06e74d1f67012438cd4d3b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedIsometricOp.html#aa7aeab23d06e74d1f67012438cd4d3b7">sparse_column</a> (size_t c, T *vbuffer, IDX *ibuffer, size_t start, size_t end, <a class="el" href="classtatami_1_1Workspace.html">Workspace</a> *work=nullptr, bool sorted=true) const</td></tr>
<tr class="separator:aa7aeab23d06e74d1f67012438cd4d3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff7ed215617739acaa9571b43df40db"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedIsometricOp.html#afff7ed215617739acaa9571b43df40db">nrow</a> () const</td></tr>
<tr class="separator:afff7ed215617739acaa9571b43df40db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452bca17a80a3c0813fd17af9a31b954"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedIsometricOp.html#a452bca17a80a3c0813fd17af9a31b954">ncol</a> () const</td></tr>
<tr class="separator:a452bca17a80a3c0813fd17af9a31b954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448bb035d018c38c490560ae08fbf532"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Workspace.html">Workspace</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedIsometricOp.html#a448bb035d018c38c490560ae08fbf532">new_workspace</a> (bool <a class="el" href="classtatami_1_1DelayedIsometricOp.html#a381a5e419200c72518e62c40c9ffa105">row</a>) const</td></tr>
<tr class="separator:a448bb035d018c38c490560ae08fbf532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7993cbcf05de154adb696169a7fa4003"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedIsometricOp.html#a7993cbcf05de154adb696169a7fa4003">sparse</a> () const</td></tr>
<tr class="separator:a7993cbcf05de154adb696169a7fa4003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac7d662db8f3b0da5431b3035a903e1e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedIsometricOp.html#aac7d662db8f3b0da5431b3035a903e1e">prefer_rows</a> () const</td></tr>
<tr class="separator:aac7d662db8f3b0da5431b3035a903e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classtatami_1_1Matrix"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classtatami_1_1Matrix')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix&lt; T, IDX &gt;</a></td></tr>
<tr class="memitem:afcc867565e4358ef0fe69bfafd416883 inherit pub_methods_classtatami_1_1Matrix"><td class="memItemLeft" align="right" valign="top">virtual std::pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#afcc867565e4358ef0fe69bfafd416883">dimension_preference</a> () const</td></tr>
<tr class="separator:afcc867565e4358ef0fe69bfafd416883 inherit pub_methods_classtatami_1_1Matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b7f1a03c5d7b38a985e23e843c2b364 inherit pub_methods_classtatami_1_1Matrix"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a5b7f1a03c5d7b38a985e23e843c2b364">row</a> (size_t r, T *buffer, <a class="el" href="classtatami_1_1Workspace.html">Workspace</a> *work=nullptr) const</td></tr>
<tr class="separator:a5b7f1a03c5d7b38a985e23e843c2b364 inherit pub_methods_classtatami_1_1Matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507a8cb3cc86db770d54ba278bf16ce3 inherit pub_methods_classtatami_1_1Matrix"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a507a8cb3cc86db770d54ba278bf16ce3">row</a> (size_t r, size_t first, size_t last, <a class="el" href="classtatami_1_1Workspace.html">Workspace</a> *work=nullptr) const</td></tr>
<tr class="separator:a507a8cb3cc86db770d54ba278bf16ce3 inherit pub_methods_classtatami_1_1Matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978dfa6e30f683f979f2344cea0556db inherit pub_methods_classtatami_1_1Matrix"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a978dfa6e30f683f979f2344cea0556db">row</a> (size_t r, <a class="el" href="classtatami_1_1Workspace.html">Workspace</a> *work=nullptr) const</td></tr>
<tr class="separator:a978dfa6e30f683f979f2344cea0556db inherit pub_methods_classtatami_1_1Matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a0d8fec5a38386835eb1f5547f1a79 inherit pub_methods_classtatami_1_1Matrix"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#ad7a0d8fec5a38386835eb1f5547f1a79">column</a> (size_t c, T *buffer, <a class="el" href="classtatami_1_1Workspace.html">Workspace</a> *work=nullptr) const</td></tr>
<tr class="separator:ad7a0d8fec5a38386835eb1f5547f1a79 inherit pub_methods_classtatami_1_1Matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600e224eea6be2a3134376c91f252d5e inherit pub_methods_classtatami_1_1Matrix"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a600e224eea6be2a3134376c91f252d5e">column</a> (size_t c, size_t first, size_t last, <a class="el" href="classtatami_1_1Workspace.html">Workspace</a> *work=nullptr) const</td></tr>
<tr class="separator:a600e224eea6be2a3134376c91f252d5e inherit pub_methods_classtatami_1_1Matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48244ef791f96e644dcb9f5578757e58 inherit pub_methods_classtatami_1_1Matrix"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a48244ef791f96e644dcb9f5578757e58">column</a> (size_t c, <a class="el" href="classtatami_1_1Workspace.html">Workspace</a> *work=nullptr) const</td></tr>
<tr class="separator:a48244ef791f96e644dcb9f5578757e58 inherit pub_methods_classtatami_1_1Matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2efe74e91680a3110fc063a0dca166f inherit pub_methods_classtatami_1_1Matrix"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#af2efe74e91680a3110fc063a0dca166f">row_copy</a> (size_t r, T *buffer, size_t first, size_t last, <a class="el" href="classtatami_1_1Workspace.html">Workspace</a> *work=nullptr) const</td></tr>
<tr class="separator:af2efe74e91680a3110fc063a0dca166f inherit pub_methods_classtatami_1_1Matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4973775c67a823afa5388dd5bd26e158 inherit pub_methods_classtatami_1_1Matrix"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a4973775c67a823afa5388dd5bd26e158">row_copy</a> (size_t r, T *buffer, <a class="el" href="classtatami_1_1Workspace.html">Workspace</a> *work=nullptr) const</td></tr>
<tr class="separator:a4973775c67a823afa5388dd5bd26e158 inherit pub_methods_classtatami_1_1Matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bedd90001d499fef7ffc3f50dbc398a inherit pub_methods_classtatami_1_1Matrix"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a9bedd90001d499fef7ffc3f50dbc398a">column_copy</a> (size_t c, T *buffer, size_t first, size_t last, <a class="el" href="classtatami_1_1Workspace.html">Workspace</a> *work=nullptr) const</td></tr>
<tr class="separator:a9bedd90001d499fef7ffc3f50dbc398a inherit pub_methods_classtatami_1_1Matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3cac7b2d129d2c3cfada8b31aaa78d5 inherit pub_methods_classtatami_1_1Matrix"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#af3cac7b2d129d2c3cfada8b31aaa78d5">column_copy</a> (size_t c, T *buffer, <a class="el" href="classtatami_1_1Workspace.html">Workspace</a> *work=nullptr) const</td></tr>
<tr class="separator:af3cac7b2d129d2c3cfada8b31aaa78d5 inherit pub_methods_classtatami_1_1Matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9784b84b453add7ac5dff0d4eccb79b1 inherit pub_methods_classtatami_1_1Matrix"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a9784b84b453add7ac5dff0d4eccb79b1">sparse_row</a> (size_t r, T *vbuffer, IDX *ibuffer, <a class="el" href="classtatami_1_1Workspace.html">Workspace</a> *work=nullptr, bool sorted=true) const</td></tr>
<tr class="separator:a9784b84b453add7ac5dff0d4eccb79b1 inherit pub_methods_classtatami_1_1Matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b08c27e7c8ad3370e476b282b6d860c inherit pub_methods_classtatami_1_1Matrix"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1SparseRangeCopy.html">SparseRangeCopy</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a9b08c27e7c8ad3370e476b282b6d860c">sparse_row</a> (size_t r, size_t first, size_t last, <a class="el" href="classtatami_1_1Workspace.html">Workspace</a> *work=nullptr, bool sorted=true) const</td></tr>
<tr class="separator:a9b08c27e7c8ad3370e476b282b6d860c inherit pub_methods_classtatami_1_1Matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1ea8f7db63824c4d6ee8e831fbc3bf4 inherit pub_methods_classtatami_1_1Matrix"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1SparseRangeCopy.html">SparseRangeCopy</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#aa1ea8f7db63824c4d6ee8e831fbc3bf4">sparse_row</a> (size_t r, <a class="el" href="classtatami_1_1Workspace.html">Workspace</a> *work=nullptr, bool sorted=true) const</td></tr>
<tr class="separator:aa1ea8f7db63824c4d6ee8e831fbc3bf4 inherit pub_methods_classtatami_1_1Matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce02b5af761599a58aa7f83379d0316 inherit pub_methods_classtatami_1_1Matrix"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#abce02b5af761599a58aa7f83379d0316">sparse_column</a> (size_t c, T *vbuffer, IDX *ibuffer, <a class="el" href="classtatami_1_1Workspace.html">Workspace</a> *work=nullptr, bool sorted=true) const</td></tr>
<tr class="separator:abce02b5af761599a58aa7f83379d0316 inherit pub_methods_classtatami_1_1Matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab20ad4040e9c9e983738b2662c260bdb inherit pub_methods_classtatami_1_1Matrix"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1SparseRangeCopy.html">SparseRangeCopy</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#ab20ad4040e9c9e983738b2662c260bdb">sparse_column</a> (size_t c, size_t first, size_t last, <a class="el" href="classtatami_1_1Workspace.html">Workspace</a> *work=nullptr, bool sorted=true) const</td></tr>
<tr class="separator:ab20ad4040e9c9e983738b2662c260bdb inherit pub_methods_classtatami_1_1Matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad431a47a5116f088f8c670c87d2f5cfd inherit pub_methods_classtatami_1_1Matrix"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1SparseRangeCopy.html">SparseRangeCopy</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#ad431a47a5116f088f8c670c87d2f5cfd">sparse_column</a> (size_t c, <a class="el" href="classtatami_1_1Workspace.html">Workspace</a> *work=nullptr, bool sorted=true) const</td></tr>
<tr class="separator:ad431a47a5116f088f8c670c87d2f5cfd inherit pub_methods_classtatami_1_1Matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d30aebc99aec770e80897923e1a88c inherit pub_methods_classtatami_1_1Matrix"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a58d30aebc99aec770e80897923e1a88c">sparse_row_copy</a> (size_t r, T *vbuffer, IDX *ibuffer, size_t first, size_t last, <a class="el" href="SparseRange_8hpp.html#ac4dba1039cc39910b0dd3bcccfea0f71">SparseCopyMode</a> copy, <a class="el" href="classtatami_1_1Workspace.html">Workspace</a> *work=nullptr, bool sorted=true) const</td></tr>
<tr class="separator:a58d30aebc99aec770e80897923e1a88c inherit pub_methods_classtatami_1_1Matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf2de7c10581c7b8b44df48f8acad68 inherit pub_methods_classtatami_1_1Matrix"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#afdf2de7c10581c7b8b44df48f8acad68">sparse_row_copy</a> (size_t r, T *vbuffer, IDX *ibuffer, <a class="el" href="SparseRange_8hpp.html#ac4dba1039cc39910b0dd3bcccfea0f71">SparseCopyMode</a> copy, <a class="el" href="classtatami_1_1Workspace.html">Workspace</a> *work=nullptr, bool sorted=true) const</td></tr>
<tr class="separator:afdf2de7c10581c7b8b44df48f8acad68 inherit pub_methods_classtatami_1_1Matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f36d4d4fa94163212dac37856743c1d inherit pub_methods_classtatami_1_1Matrix"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a7f36d4d4fa94163212dac37856743c1d">sparse_column_copy</a> (size_t c, T *vbuffer, IDX *ibuffer, size_t first, size_t last, <a class="el" href="SparseRange_8hpp.html#ac4dba1039cc39910b0dd3bcccfea0f71">SparseCopyMode</a> copy, <a class="el" href="classtatami_1_1Workspace.html">Workspace</a> *work=nullptr, bool sorted=true) const</td></tr>
<tr class="separator:a7f36d4d4fa94163212dac37856743c1d inherit pub_methods_classtatami_1_1Matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50759885edd0fac8386717539088758c inherit pub_methods_classtatami_1_1Matrix"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; T, IDX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a50759885edd0fac8386717539088758c">sparse_column_copy</a> (size_t c, T *vbuffer, IDX *ibuffer, <a class="el" href="SparseRange_8hpp.html#ac4dba1039cc39910b0dd3bcccfea0f71">SparseCopyMode</a> copy, <a class="el" href="classtatami_1_1Workspace.html">Workspace</a> *work=nullptr, bool sorted=true) const</td></tr>
<tr class="separator:a50759885edd0fac8386717539088758c inherit pub_methods_classtatami_1_1Matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classtatami_1_1Matrix"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classtatami_1_1Matrix')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix&lt; T, IDX &gt;</a></td></tr>
<tr class="memitem:a748cb0b5464085347243c9d26a300005 inherit pub_types_classtatami_1_1Matrix"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a748cb0b5464085347243c9d26a300005">value</a></td></tr>
<tr class="separator:a748cb0b5464085347243c9d26a300005 inherit pub_types_classtatami_1_1Matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8a0b1b3493d8ae573d8157fcff1c90 inherit pub_types_classtatami_1_1Matrix"><td class="memItemLeft" align="right" valign="top">typedef IDX&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html#a0f8a0b1b3493d8ae573d8157fcff1c90">index</a></td></tr>
<tr class="separator:a0f8a0b1b3493d8ae573d8157fcff1c90 inherit pub_types_classtatami_1_1Matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename IDX, class OP&gt;<br />
class tatami::DelayedIsometricOp&lt; T, IDX, OP &gt;</h3>

<p>Delayed isometric operations on a matrix. </p>
<p>Implements any operation that preserves the shape of the matrix and operates on each matrix value independently. This operation is "delayed" in that it is only evaluated on request, e.g., with <code><a class="el" href="classtatami_1_1DelayedIsometricOp.html#a381a5e419200c72518e62c40c9ffa105">row()</a></code> or friends.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of matrix value. </td></tr>
    <tr><td class="paramname">OP</td><td>Functor class implementing the operation. This should accept the row index, column index and value, and return the modified value after applying the operation. </td></tr>
    <tr><td class="paramname">IDX</td><td>Type of index value. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac35c661c2c7ca2de94468b43aee46a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac35c661c2c7ca2de94468b43aee46a54">&#9670;&nbsp;</a></span>DelayedIsometricOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX , class OP &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedIsometricOp.html">tatami::DelayedIsometricOp</a>&lt; T, IDX, OP &gt;::<a class="el" href="classtatami_1_1DelayedIsometricOp.html">DelayedIsometricOp</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; T, IDX &gt; &gt;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OP&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to the underlying matrix. </td></tr>
    <tr><td class="paramname">op</td><td>Instance of the functor class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa09e2b36af415ca443d57cc0cda38ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa09e2b36af415ca443d57cc0cda38ebe">&#9670;&nbsp;</a></span>column()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX , class OP &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classtatami_1_1DelayedIsometricOp.html">tatami::DelayedIsometricOp</a>&lt; T, IDX, OP &gt;::column </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtatami_1_1Workspace.html">Workspace</a> *&#160;</td>
          <td class="paramname"><em>work</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><code>buffer</code> may not necessarily be filled upon extraction if a pointer can be returned to the underlying data store. This can be checked by comparing the returned pointer to <code>buffer</code>; if they are the same, <code>buffer</code> has been filled.</p>
<p>If <code>work</code> is not a null pointer, it should have been generated by <code><a class="el" href="classtatami_1_1DelayedIsometricOp.html#a448bb035d018c38c490560ae08fbf532">new_workspace()</a></code> with <code>row = false</code>. This is optional and should only affect the efficiency of extraction, not the contents.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Index of the column. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to an array with enough space for at least <code>last - first</code> values. </td></tr>
    <tr><td class="paramname">first</td><td>First row to extract for column <code>c</code>. </td></tr>
    <tr><td class="paramname">last</td><td>One past the last row to extract in <code>c</code>. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to a workspace.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the values of column <code>c</code>, starting from the value in the <code>first</code> row and containing <code>last - first</code> valid entries. </dd></dl>

<p>Implements <a class="el" href="classtatami_1_1Matrix.html#a9ac0dd5b8352b1c2270ecfaeec369eae">tatami::Matrix&lt; T, IDX &gt;</a>.</p>

</div>
</div>
<a id="a452bca17a80a3c0813fd17af9a31b954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a452bca17a80a3c0813fd17af9a31b954">&#9670;&nbsp;</a></span>ncol()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX , class OP &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classtatami_1_1DelayedIsometricOp.html">tatami::DelayedIsometricOp</a>&lt; T, IDX, OP &gt;::ncol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Number of columns. </dd></dl>

<p>Implements <a class="el" href="classtatami_1_1Matrix.html#a1049bd5cbe37b618db795787725930e4">tatami::Matrix&lt; T, IDX &gt;</a>.</p>

</div>
</div>
<a id="a448bb035d018c38c490560ae08fbf532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a448bb035d018c38c490560ae08fbf532">&#9670;&nbsp;</a></span>new_workspace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX , class OP &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classtatami_1_1Workspace.html">Workspace</a>&gt; <a class="el" href="classtatami_1_1DelayedIsometricOp.html">tatami::DelayedIsometricOp</a>&lt; T, IDX, OP &gt;::new_workspace </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A null pointer or a shared pointer to a <code><a class="el" href="classtatami_1_1Workspace.html" title="Virtual workspace class.">Workspace</a></code> object, depending on the underlying (pre-operation) matrix. </dd></dl>

<p>Reimplemented from <a class="el" href="classtatami_1_1Matrix.html#a4e297749a340e7a723728db91ee0bbce">tatami::Matrix&lt; T, IDX &gt;</a>.</p>

</div>
</div>
<a id="afff7ed215617739acaa9571b43df40db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff7ed215617739acaa9571b43df40db">&#9670;&nbsp;</a></span>nrow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX , class OP &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classtatami_1_1DelayedIsometricOp.html">tatami::DelayedIsometricOp</a>&lt; T, IDX, OP &gt;::nrow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Number of rows. </dd></dl>

<p>Implements <a class="el" href="classtatami_1_1Matrix.html#a48e1342556ff97cc8367b25d244195a9">tatami::Matrix&lt; T, IDX &gt;</a>.</p>

</div>
</div>
<a id="aac7d662db8f3b0da5431b3035a903e1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac7d662db8f3b0da5431b3035a903e1e">&#9670;&nbsp;</a></span>prefer_rows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX , class OP &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtatami_1_1DelayedIsometricOp.html">tatami::DelayedIsometricOp</a>&lt; T, IDX, OP &gt;::prefer_rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if row-wise extraction is preferred by the underlying (pre-operation) matrix, otherwise returns <code>false</code>. </dd></dl>

<p>Reimplemented from <a class="el" href="classtatami_1_1Matrix.html#ac31ddc309419b4b2f6a2d0a01837e7a3">tatami::Matrix&lt; T, IDX &gt;</a>.</p>

</div>
</div>
<a id="a381a5e419200c72518e62c40c9ffa105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a381a5e419200c72518e62c40c9ffa105">&#9670;&nbsp;</a></span>row()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX , class OP &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classtatami_1_1DelayedIsometricOp.html">tatami::DelayedIsometricOp</a>&lt; T, IDX, OP &gt;::row </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtatami_1_1Workspace.html">Workspace</a> *&#160;</td>
          <td class="paramname"><em>work</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><code>buffer</code> may not necessarily be filled upon extraction if a pointer can be returned to the underlying data store. This can be checked by comparing the returned pointer to <code>buffer</code>; if they are the same, <code>buffer</code> has been filled.</p>
<p>If <code>work</code> is not a null pointer, it should have been generated by <code><a class="el" href="classtatami_1_1DelayedIsometricOp.html#a448bb035d018c38c490560ae08fbf532">new_workspace()</a></code> with <code>row = true</code>. This is optional and should only affect the efficiency of extraction, not the contents.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Index of the row. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to an array with enough space for at least <code>last - first</code> values. </td></tr>
    <tr><td class="paramname">first</td><td>First column to extract for row <code>r</code>. </td></tr>
    <tr><td class="paramname">last</td><td>One past the last column to extract in <code>r</code>. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to a workspace.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the values of row <code>r</code>, starting from the value in the <code>first</code> column and containing <code>last - first</code> valid entries. </dd></dl>

<p>Implements <a class="el" href="classtatami_1_1Matrix.html#a4236a9e624782a86433374436a90c1e8">tatami::Matrix&lt; T, IDX &gt;</a>.</p>

</div>
</div>
<a id="a7993cbcf05de154adb696169a7fa4003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7993cbcf05de154adb696169a7fa4003">&#9670;&nbsp;</a></span>sparse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX , class OP &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtatami_1_1DelayedIsometricOp.html">tatami::DelayedIsometricOp</a>&lt; T, IDX, OP &gt;::sparse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both the underlying (pre-operation) matrix is sparse and the operation preserves sparsity. Otherwise returns <code>false</code>. </dd></dl>

<p>Reimplemented from <a class="el" href="classtatami_1_1Matrix.html#a05f69722541e0ed9a8f19aad2d44f1c4">tatami::Matrix&lt; T, IDX &gt;</a>.</p>

</div>
</div>
<a id="aa7aeab23d06e74d1f67012438cd4d3b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7aeab23d06e74d1f67012438cd4d3b7">&#9670;&nbsp;</a></span>sparse_column()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX , class OP &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt;T, IDX&gt; <a class="el" href="classtatami_1_1DelayedIsometricOp.html">tatami::DelayedIsometricOp</a>&lt; T, IDX, OP &gt;::sparse_column </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>vbuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IDX *&#160;</td>
          <td class="paramname"><em>ibuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtatami_1_1Workspace.html">Workspace</a> *&#160;</td>
          <td class="paramname"><em>work</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sorted</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><code>vbuffer</code> may not necessarily be filled upon extraction if a pointer can be returned to the underlying data store. This be checked by comparing the returned <code><a class="el" href="structtatami_1_1SparseRange.html#af58b18de602bb4e82e5223b0d7168a08">SparseRange::value</a></code> pointer to <code>vbuffer</code>; if they are the same, <code>vbuffer</code> has been filled. The same applies for <code>ibuffer</code> and the returned <code><a class="el" href="structtatami_1_1SparseRange.html#ac7dd33e84bcc456c04e848bdc51ade73">SparseRange::index</a></code> pointer.</p>
<p>Values in <code>vbuffer</code> are not guaranteed to be non-zero. If zeroes are explicitly initialized in the underlying representation, they will be reported here. However, one can safely assume that all values <em>not</em> in <code>vbuffer</code> are zero.</p>
<p>If <code>work</code> is not a null pointer, it should have been generated by <code><a class="el" href="classtatami_1_1DelayedIsometricOp.html#a448bb035d018c38c490560ae08fbf532">new_workspace()</a></code> with <code>row = true</code>. This is optional and should only affect the efficiency of extraction, not the contents.</p>
<p>Setting <code>sorted = false</code> can reduce computational work in situations where the order of non-zero elements does not matter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Index of the column. </td></tr>
    <tr><td class="paramname">vbuffer</td><td>Pointer to an array with enough space for at least <code>last - first</code> values. </td></tr>
    <tr><td class="paramname">ibuffer</td><td>Pointer to an array with enough space for at least <code>last - first</code> indices. </td></tr>
    <tr><td class="paramname">first</td><td>First row to extract for column <code>c</code>. </td></tr>
    <tr><td class="paramname">last</td><td>One past the last row to extract in <code>c</code>. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to a workspace. </td></tr>
    <tr><td class="paramname">sorted</td><td>Should the non-zero elements be sorted by their indices?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structtatami_1_1SparseRange.html" title="A range of a sparse vector.">SparseRange</a></code> object containing the number of non-zero elements in <code>c</code> from column <code>first</code> up to <code>last</code>. This also contains pointers to arrays containing their row indices and values. </dd></dl>

<p>Reimplemented from <a class="el" href="classtatami_1_1Matrix.html#ad9f6947fe9f2cde1f5ee028d4f016271">tatami::Matrix&lt; T, IDX &gt;</a>.</p>

</div>
</div>
<a id="a89ff2329e314827b451d5cb9ed66b037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89ff2329e314827b451d5cb9ed66b037">&#9670;&nbsp;</a></span>sparse_row()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX , class OP &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt;T, IDX&gt; <a class="el" href="classtatami_1_1DelayedIsometricOp.html">tatami::DelayedIsometricOp</a>&lt; T, IDX, OP &gt;::sparse_row </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>vbuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IDX *&#160;</td>
          <td class="paramname"><em>ibuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtatami_1_1Workspace.html">Workspace</a> *&#160;</td>
          <td class="paramname"><em>work</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sorted</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><code>vbuffer</code> may not necessarily be filled upon extraction if a pointer can be returned to the underlying data store. This be checked by comparing the returned <code><a class="el" href="structtatami_1_1SparseRange.html#af58b18de602bb4e82e5223b0d7168a08">SparseRange::value</a></code> pointer to <code>vbuffer</code>; if they are the same, <code>vbuffer</code> has been filled. The same applies for <code>ibuffer</code> and the returned <code><a class="el" href="structtatami_1_1SparseRange.html#ac7dd33e84bcc456c04e848bdc51ade73">SparseRange::index</a></code> pointer.</p>
<p>Values in <code>vbuffer</code> are not guaranteed to be non-zero. If zeroes are explicitly initialized in the underlying representation, they will be reported here. However, one can safely assume that all values <em>not</em> in <code>vbuffer</code> are zero.</p>
<p>If <code>work</code> is not a null pointer, it should have been generated by <code><a class="el" href="classtatami_1_1DelayedIsometricOp.html#a448bb035d018c38c490560ae08fbf532">new_workspace()</a></code> with <code>row = false</code>. This is optional and should only affect the efficiency of extraction, not the contents.</p>
<p>Setting <code>sorted = false</code> can reduce computational work in situations where the order of non-zero elements does not matter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Index of the row. </td></tr>
    <tr><td class="paramname">vbuffer</td><td>Pointer to an array with enough space for at least <code>last - first</code> values. </td></tr>
    <tr><td class="paramname">ibuffer</td><td>Pointer to an array with enough space for at least <code>last - first</code> indices. </td></tr>
    <tr><td class="paramname">first</td><td>First column to extract for row <code>r</code>. </td></tr>
    <tr><td class="paramname">last</td><td>One past the last column to extract in <code>r</code>. </td></tr>
    <tr><td class="paramname">work</td><td>Pointer to a workspace. </td></tr>
    <tr><td class="paramname">sorted</td><td>Should the non-zero elements be sorted by their indices?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structtatami_1_1SparseRange.html" title="A range of a sparse vector.">SparseRange</a></code> object containing the number of non-zero elements in <code>r</code> from column <code>first</code> up to <code>last</code>. This also contains pointers to arrays containing their column indices and values. </dd></dl>

<p>Reimplemented from <a class="el" href="classtatami_1_1Matrix.html#a12b2ee3e856575e093d08d8117e3c40d">tatami::Matrix&lt; T, IDX &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>tatami/base/<a class="el" href="DelayedIsometricOp_8hpp_source.html">DelayedIsometricOp.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
